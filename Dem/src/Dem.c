
/* ********************************************************************************************************************
 *  COPYRIGHT
 *  -------------------------------------------------------------------------------------------------------------------
 *  \verbatim
 *  Copyright (c) 2015 by Vector Informatik GmbH.                                                  All rights reserved.
 *
 *                This software is copyright protected and proprietary to Vector Informatik GmbH.
 *                Vector Informatik GmbH grants to you only those rights as set out in the license conditions.
 *                All other rights remain with Vector Informatik GmbH.
 *  \endverbatim
 *  -------------------------------------------------------------------------------------------------------------------
 *  FILE DESCRIPTION
 *  -------------------------------------------------------------------------------------------------------------------
 *         File:  Dem.c
 *      Project:  MICROSAR Diagnostic Event Manager (Dem)
 *       Module:  -
 *    Generator:  -
 *
 *  Description:  Implementation file for the MICROSAR Dem
 *
 *********************************************************************************************************************/

/* ********************************************************************************************************************
 *  AUTHOR IDENTITY
 *  -------------------------------------------------------------------------------------------------------------------
 *  Name                          Initials      Company
 *  -------------------------------------------------------------------------------------------------------------------
 *  Stefan Huebner                vishrs        Vector Informatik GmbH
 *  Alexander Ditte               visade        Vector Informatik GmbH
 *  Matthias Heil                 vismhe        Vector Informatik GmbH
 *  Thomas Dedler                 visdth        Vector Informatik GmbH
 *  Anna Hoessle                  visanh        Vector Informatik GmbH
 *  -------------------------------------------------------------------------------------------------------------------
 *  REVISION HISTORY
 *  -------------------------------------------------------------------------------------------------------------------
 *  Version   Date        Author  Change Id     Description
 *  -------------------------------------------------------------------------------------------------------------------
 *  04.00.00  2012-06-29  vismhe  ESCAN00057159 AR4-82: DEM 4.x
 *                        visade  ESCAN00057159 AR4-82: DEM 4.x
 *  04.01.00  2012-09-07  vismhe  ESCAN00061254 VersionInfo API returns wrong version number
 *            2012-09-14  vismhe  ESCAN00061429 Autostart cycle has no effect
 *            2012-09-20  vismhe  ESCAN00061565 Wrong snapshot record number reported for 19 03
 *            2012-10-26  vismhe  ESCAN00062489 Compiler warning: Condition is always true
 *            2012-10-26  vismhe  ESCAN00062490 Compiler warning: Condition is always true
 *            2012-10-26  vismhe  ESCAN00062483 Unexpected ClearAllowed callback
 *  04.02.00  2012-11-05  vismhe  ESCAN00062646 Compiler warning: Function "Dem_Queue_CancelOperation" was declared but never referenced
 *            2012-11-05  vismhe  ESCAN00062647 Compiler warning: Variable "Dem_Mem_PrimaryInfo" was declared but never referenced
 *            2012-11-05  vismhe  ESCAN00062644 Compiler warning: Variable "lResult" was set but never used
 *            2012-11-06  vismhe  ESCAN00062645 Compiler warning: Variable "lOldEventStatus" was set but never used
 *            2012-11-06  visade  ESCAN00062771 Memory corruption after call of Dem_SetDTCFilter()
 *            2012-12-07  vismhe  ESCAN00061769 AR4-207: Support VCC Diagnostic specification and required Diagnostic RFCs
 *  04.03.00  2013-02-04  visdth  ESCAN00061747 OBDII Support: IUMPR handling added
 *            2013-03-05  vismhe  ESCAN00065600 DET error DEM_E_UNINIT in Dem_Mainfunction
 *            2013-03-08  visade  ESCAN00061747 AR4-55: DEM - OBDII Support
 *            2013-03-13  visdth  ESCAN00063590 OBD IUMPR Counting Misbehavior
 *            2013-03-13  visdth  ESCAN00065851 Support User Controlled Warning Indicator Request
 *            2013-03-13  visdth  ESCAN00065853 Support suppression of permanent DTC storage
 *            2013-03-13  visdth  ESCAN00065854 Support MIL Groups
 *            2013-03-13  vismhe  ESCAN00065867 Allow PendingDTC independent from event storage
 *            2013-03-13  vismhe  ESCAN00065868 Support different DTC aging protocols
 *  04.04.00  2013-04-02  visade  ESCAN00066314 Compiler warning: multiple dead assignments within Dem.c
 *            2013-04-03  vismhe  ESCAN00065209 AR4-375: Add Support of "Suppress DTC" in Dem
 *            2013-04-10  visdth  ESCAN00066201 Extension of Interface to read IUMPR data
 *            2013-04-26  vismhe  ESCAN00067007 Secondary Memory DTCs do not report Severity and FunctionalUnit information
 *  04.04.01  2013-05-15  visade  ESCAN00067368 Compiler error: OdometerAtClear is not a member of Dem_Cfg_AdminDataType_s
 *            2013-05-15  visade  ESCAN00067372 Compiler error: Dem_Cfg_ObdGetGlobalDenominator() not a modifiable lvalue
 *            2013-05-15  visade  ESCAN00067155 Missing type definitions if Dem is used without Rte
 *            2013-05-15  visade  ESCAN00067025 Include FiM.h only if IUMPR or FiM notification is enabled
 *            2013-05-22  vismhe  ESCAN00067180 Compiler warning: uninitialized local variable 'lDtcStatusNew' used
 *            2013-05-22  vismhe  ESCAN00067354 Compilation error: Undefined symbol
 *            2013-05-22  vismhe  ESCAN00067345 Compilation error: Undefined symbol
 *            2013-05-22  vismhe  ESCAN00067459 Compiler warning: dead assignment to "lReturnValue" eliminated
 *  04.05.00  2013-06-03  visade  ESCAN00067673 Change Permanent Activation Distance from absolute to relative distance calculation
 *            2013-06-10  visade  ESCAN00067618 Out-parameter not initialized in Dem_GetIUMPRGeneralData
 *            2013-06-19  visdth  ESCAN00068159 MIL Group trip counter not reset on ClearDTC
 *            2013-06-19  vismhe  ESCAN00067715 AR4-418: Support Event Combination Type 1
 *            2013-06-19  vismhe  ESCAN00068164 Immediately persist event status on ClearDTC
 *            2013-06-19  vismhe  ESCAN00068389 Extended use of Dem_GetSeverityOfDTC and Dem_GetFunctionalUnitOfDTC
 *            2013-06-27  vismhe  ESCAN00068390 OperationCycles not stopped during Shutdown
 *            2013-09-18  vismhe  ESCAN00070478 Unexpected value for EventStatusChanged and DTCStatusChanged callbacks
 *  04.05.01  2013-07-03  vismhe  ESCAN00068511 Compiler error: Dem.c: 'Dem_Cbk_InitMonitor' undefined
 *  04.05.02  2013-07-03  vismhe  ESCAN00068562 Mode 0x02 does not return data
 *            2013-07-04  vismhe  ESCAN00068508 IUMPR: Numerator is incremented without qualified test result
 *            2013-07-04  vismhe  ESCAN00068569 Suppression or UserControlled WIR has no effect
 *  04.05.03  2013-07-10  visade  ESCAN00068885 Provide OBD FreezeFrame in 0x1904 although Snapshots Records are disabled
 *            2013-07-18  visade  ESCAN00069154 Missing cast truncates OBD DTC number
 *            2013-07-22  vismhe  ESCAN00069132 Mixed internal and external data records are stored misaligned
 *            2013-07-22  vismhe  ESCAN00069237 Allow to override static / inline specific to Dem module
 *            2013-07-23  vismhe  ESCAN00069270 Too many increments of occurrence counter
 *            2013-07-23  vismhe  ESCAN00069271 DTC starts aging although it is still pending
 *            2013-07-23  visdth  ESCAN00068577 IUMPR Counters may be incremented more than once per DCY
 *  04.06.00  2013-07-24  visade  ESCAN00069311 Missing DID/PID validation check in Dem_GetEventFreezeFrameData()
 *            2013-07-24  visade  ESCAN00068636 AR4-419: Support Multiple OBD Freeze Frames
 *            2013-08-02  visade  ESCAN00069587 The code shall compile if NVM support is disabled and OBD support is enabled
 *            2013-08-06  visade  ESCAN00069626 OBD DTC Status does not qualify
 *            2013-08-07  visade  ESCAN00069423 OBD relevant data is not reset on configuration change
 *            2013-08-08  visade  ESCAN00069683 Erroneous indicator decrement during Mode 0x04
 *            2013-08-14  vismhe  ESCAN00069801 BSW error reporting after PreInit and before Init not possible
 *  05.00.00  2013-09-03  vismhe  ESCAN00068165 Compiler warning: Condition is always constant
 *            2013-09-03  vismhe  ESCAN00068395 AR4-292: Reporting of DET and DEM errors via DLT
 *            2013-09-03  vismhe  ESCAN00068416 AR4-420: Postbuild Loadable Support
 *            2013-09-03  vismhe  ESCAN00068465 AR4-371: Support signal interface
 *            2013-09-03  vismhe  ESCAN00068526 AR4-409: Support of OEM Volvo AB
 *            2013-09-03  vismhe  ESCAN00068530 AR4-542: Support of OEM Ford
 *            2013-09-03  vismhe  ESCAN00069882 Internal event is not cleared
 *            2013-09-03  vismhe  ESCAN00069989 Compiler warning: variable "lEntry" was set but never used
 *            2013-09-03  vismhe  ESCAN00069805 Add verification of EventKind to ReportErrorStatus and SetEventStatus
 *            2013-09-04  visdth  ESCAN00070048 OBD IUMPR: reading the same ratio several times is not possible
 *            2013-09-11  vismhe  ESCAN00070346 AgingCounter is reported with incorrect value
 *            2013-09-16  vismhe  ESCAN00069943 Delay WarmUpCycle until restart of Driving Cycle
 *            2013-09-16  vismhe  ESCAN00070219 Reset PID 0x21 if no OBD DTC requests the MIL for 40 warm-up cycles
 *            2013-09-19  vismhe  ESCAN00070500 Remove DET for consecutive qualified DCY reports
 *            2013-09-26  vismhe  ESCAN00070686 ConfirmedDTC is reset on initialization
 *            2013-10-02  vismhe  ESCAN00070834 Incorrect event displaced on overflow
 *            2013-11-27  vismhe  ESCAN00072203 Memory overwritten during initialization
 *  05.00.01  2013-11-13  vismhe  ESCAN00071873 DTCs do not age
 *            2013-11-14  vismhe  ESCAN00071948 Compiler warning: Definition different from declaration
 *  05.01.00  2013-10-17  visade  ESCAN00071182 Incorrect MIL group behavior after ClearAllDTCs
 *            2013-10-22  visade  ESCAN00071161 Change initialization of PID 0x31
 *            2013-10-22  visade  ESCAN00071162 Support ClearSingleDtc for OBD ECUs
 *            2013-10-25  visade  ESCAN00071244 Provide Dem internal EventId in Environmental Data
 *            2013-10-25  visade  ESCAN00071425 Provide OBD DTC in Environmental Data
 *            2013-10-30  visade  ESCAN00071346 Support application interface providing the permanent DTC activation state
 *            2013-11-20  vismhe  ESCAN00072084 Incorrect value for maximum FDC in current cycle
 *            2013-11-20  vismhe  ESCAN00071550 Incorrect status report handling for BSW errors
 *            2013-11-21  visade  ESCAN00072122 Stored UDS DTC does not have Confirmed and WarningIndicator bit set
 *            2013-11-28  vismhe  ESCAN00072310 Incorrect PID21 handling
 *  06.00.00  2014-02-04  visade  ESCAN00072994 Admin data is not persisted during shutdown if no Operation Cycle was started
 *            2014-02-04  vismhe  ESCAN00073575 Compile/Validation error: Incompatible prototypes
 *            2014-02-04  vismhe  ESCAN00073578 Rework NV MemoryAbstraction
 *            2014-02-04  vismhe  ESCAN00070873 AR4-402: Support of OEM Ford
 *            2014-02-04  visade  ESCAN00071380 AR4-465: Support for J1939 Diagnostics - API to DCM according AR 4.1.2
 *            2014-02-04  visade  ESCAN00071379 AR4-465: Support for J1939 Diagnostics
 *            2014-02-14  visade  ESCAN00073721 Driving cycle remains qualified after automatic end
 *            2014-02-18  vismhe  ESCAN00073792 Diagnostics locked when clearing DTCs
 *            2014-02-18  vismhe  ESCAN00079177 Compiler warning: Name Dem_DTCGroupType has already been declared
 *  06.01.00  2014-03-10  visdth  ESCAN00073613 Numerator is only incremented with fulfilled General Denominator conditions
 *            2014-03-12  vismhe  ESCAN00074193 NRC "conditions not correct" for services 19 04, 19 06
 *            2014-03-12  vismhe  ESCAN00074203 AR4-673: Diag_Asr4J1939Dcm + Diag_Asr4Dem shall work without Diag_Asr4Dcm
 *            2014-03-13  vismhe  ESCAN00074248 Compiler error: Missing type definition Dem_J1939DcmDiagnosticReadinessNType
 *            2014-03-12  visade  ESCAN00073876 Lock Numerator increment during active tester communication
 *            2014-03-13  visade  ESCAN00074253 Compile error if Aging is configured to start at passed
 *            2014-03-21  vismhe  ESCAN00074493 DTC does not re-enable after suppression
 *            2014-03-21  vismhe  ESCAN00074494 DTCs do not respect multiple trips
 *            2014-03-25  vismhe  ESCAN00074541 Hide Dependent OBD DTCs in UDS diagnostic services
 *            2014-03-25  vismhe  ESCAN00074410 Incorrect old DTC status in DtcStatusChangeCbk
 *            2014-03-26  vismhe  ESCAN00074566 Event does not debounce correctly
 *            2014-03-27  vismhe  ESCAN00074598 Significance value reported incorrectly in extended records
 *            2014-03-28  vismhe  ESCAN00074644 Time debounced events report wrong maximum debounce value
 *            2014-03-28  vismhe  ESCAN00074647 Occurrence Counter reported incorrectly
 *            2014-03-28  vismhe  ESCAN00073289 Add Operating Hours to Standardized Environmental Data
 *            2014-04-02  visade  ESCAN00074740 Possible out of bound access for variable Dem_Cfg_ObdIumprData.Status
 *            2014-04-02  vismhe  ESCAN00074743 Wrong result when reporting invalid event status
 *  06.02.00  2014-04-23  vismhe  ESCAN00074202 AR4-670: Support DTC Pre-storage
 *            2014-04-23  vismhe  ESCAN00075221 Support 16 Operation Cycles
 *            2014-04-23  vismhe  ESCAN00075100 Usage of OSEK OS symbol can cause errors during preprocessing
 *            2014-04-24  vismhe  ESCAN00075205 Provide API Dem_SetEventAvailable
 *            2014-04-24  vismhe  ESCAN00075207 Suppressed Events do not confirm
 *            2014-04-28  visade  ESCAN00073569 Do not track the ratio for suppressed DTCs/Events
 *            2014-05-05  vismhe  ESCAN00075368 Incorrect new DTC status reported in DTC status changed callback
 *            2014-05-07  visade  ESCAN00075400 PID 0x21 is not cleared if MIL is not triggered
 *            2014-05-08  visade  ESCAN00074965 Loop underrun in function Dem_EnablePermanentStorage()
 *            2014-06-04  vismhe  ESCAN00075786 Dem does not compile if PID 0x21 is not enabled
 *            2014-05-21  vismhe  ESCAN00075810 OBD Freeze Frame is not cleared correctly
 *            2014-06-04  vismhe  ESCAN00076016 Compile Error: Multiple errors for OBD DEM with feature OBD disabled
 *            2014-06-04  vismhe  ESCAN00076021 Compiler error: Undefined preprocessor identifier in Dem_Dcm.h
 *  07.00.00  2014-06-25  vismhe  ESCAN00076615 AR4-732: Application Trigger for NV Synchronization
 *            2014-06-25  vismhe  ESCAN00076615 AR4-732: Extend aging behavior to not require TFTOC==false
 *            2014-06-30  vismhe  ESCAN00076615 AR4-732: Added support for Clear DTC Limitation
 *            2014-07-02  vismhe  ESCAN00076615 AR4-732: Added support FDC trip / once per cycle
 *            2014-06-25  vismhe  ESCAN00076450 Compiler error: inline function's body is not declared previously
 *            2014-06-30  vismhe  ESCAN00077724 AR4-698: Move InitPointer to Dem_Init
 *            2014-07-02  visade  ESCAN00076529 AR4-607: Option to store the Fault Detection Counter in NVRAM
 *            2014-07-02  vismhe  ESCAN00076664 Improve DTC status recovery after power loss
 *            2014-07-02  visade  ESCAN00076667 Remove support of DEM_DTC_FORMAT_OBD from DTC suppression
 *            2014-07-10  vismhe  ESCAN00076878 Improve robustness against Shutdown
 *            2014-07-11  vismhe  ESCAN00076920 Wrong result when extended record is not stored
 *            2014-07-11  vismhe  ESCAN00076982 Implausible value for extended data records mapped to aging counter
 *            2014-07-23  visade  ESCAN00076612 AR4-741: Support multiple J1939 nodes in DEM and J1939DCM
 *            2014-08-07  vismhe  ESCAN00077685 Improve robustness of disable DTC record update
 *            2014-08-07  visade  ESCAN00077680 Do not report previously OBD relevant DTCs in Mode 0x0A
 *            2014-08-08  vismhe  ESCAN00077722 Compiler warning: 'EventId' : unreferenced formal parameter
 *            2014-08-12  vismhe  ESCAN00074759 Feature J1939 and EventCombination does not work together
 *            2014-08-25  vismhe  ESCAN00074190 Restore ConfirmedBit when StorageTrigger == Confirmed
 *            2014-08-25  vismhe  ESCAN00077999 Service 19 02 does not report all DTCs
 *            2014-09-12  vismhe  ESCAN00078381 Dem_GetIUMPRGeneralData returns an incorrect value for 'NumberOfRatios'
 *            2014-09-30  vismhe  ESCAN00078498 Recover external visible OBD Freeze Frame if event in memory is not OBD relevant by configuration (anymore)
 *            2014-10-01  visade  ESCAN00078639 Add NVRAM Recovery for Permanent Memesry
 *            2014-10-10  vismhe  ESCAN00078806 Wrong event displaced from event memory
 *            2014-10-13  vismhe  ESCAN00078902 Event availability not working with combined events
 *            2014-10-13  vismhe  ESCAN00068635 Compiler warning: expression always constant
 *            2014-10-13  vismhe  ESCAN00070124 Compiler warning: conditional expression is constant
 *            2014-10-13  vismhe  ESCAN00076527 AR4-572: Ford/Mazda Feature Complete - Ford in AR environment
 *            2014-10-13  vismhe  ESCAN00076605 AR4-669: Support for J1939 Diagnostics
 *            2014-10-13  vismhe  ESCAN00080571 Memory corruption when aging DTCs
 *            2015-01-14  vismhe  ESCAN00081016 Out of bound memory read access for Dem_Cfg_ObdIumprData.Status
 *  08.00.00  2014-11-24  vismhe  ESCAN00079766 Remove API Dem_GetNextIUMPRRatioData
 *            2014-11-24  vismhe  ESCAN00079776 Combined events not correctly unavailable in postbuild configuration
 *            2014-11-24  vismhe  ESCAN00079653 Change return value for API Dem_SetOperationCycleState()
 *            2014-11-24  visade  ESCAN00079787 Compiler warning: Dead assignment in function Dem_Data_PermanentEntryFind()
 *            2014-12-04  visade  ESCAN00079994 1-Trip DTC without the need for a qualified driving cycle
 *            2014-12-04  vismhe  ESCAN00079778 A Monitor Report is lost
 *            2014-12-05  vismhe  ESCAN00080187 FEAT-412 Support latching TestFailed of confirmed DTCs
 *            2014-12-11  vismhe  ESCAN00080187 FEAT-412 Support Freezing/Resetting the debouncing state by API
 *            2014-12-11  vismhe  ESCAN00080187 FEAT-412 Support init monitor notification when debouncing is reenabled
 *            2014-12-11  vismhe  ESCAN00080187 FEAT-412 Transport NvM error result to ClearDTC Api
 *            2014-12-17  visade  ESCAN00080224 Support of 3 Byte OBD DTC for DEM internal data element
 *            2015-01-12  vismhe  ESCAN00079539 FEAT-1200: Support of length information in Snapshot
 *            2015-01-12  vismhe  ESCAN00079539 FEAT-1200: Option to rest TF bit on operation cycle start
 *            2015-01-14  vismhe  ESCAN00080283 FEAT-427: Refactoring of large functions, rework function headers
 *            2015-01-21  visade  ESCAN00080705 Permanent DTC without permanent memory activation
 *            2015-01-21  visade  ESCAN00080718 Remove DCY wait state for permanent DTCs after CodeClear
 *            2015-01-21  visade  ESCAN00080178 Add DCY qualification as permanent DTC erase condition
 *            2015-01-28  vismhe  ESCAN00080898 Out of bounds memory read access
 *            2015-02-06  visade  ESCAN00081089 Improve NVRAM recovery for combined events in permanent memory
 *            2015-02-06  visade  ESCAN00081024 IUMPR - erroneous numerator increment
 *            2015-02-12  vismhe  ESCAN00081038 Event reports are not processed correctly before Dem_Init()
 *            2015-02-12  vismhe  ESCAN00081188 Keep auto-start cycles active after shutdown
 *            2015-02-15  vismhe  ESCAN00080245 FEAT-473: Support default initialization for event available state
 *            2015-02-18  vismhe  ESCAN00081328 Critical section is kept in lock state
 *            2015-02-20  vismhe  ESCAN00080555 Compiler warning: 'FreezeFrameIndex' : unreferenced formal parameter
 *            2015-02-23  visade  ESCAN00081400 Make active DTC immediately visible after permanent memory activation
 *            2015-02-25  visade  ESCAN00079859 FEAT-643: Support WWH OBD (Beta)
 *            2015-02-27  vismhe  ESCAN00081529 Blocking of ClearDTC while processing ClearSingleDTC
 *            2015-03-10  vismhe  ESCAN00081708 DTC aging starts too early
 *            2015-03-19  vismhe  ESCAN00079199 Compiler warning: 'FreezeFrameIndex' : unreferenced formal parameter
 *            2015-03-19  vismhe  ESCAN00079200 Compiler warning: 'SRecIndex' : unreferenced formal parameter
 *  09.00.00  2015-03-24  visade  ESCAN00082399 FEAT-1446: Make OBD II Freeze Frame optional in Service 0x1904
 *            2015-03-31  visade  ESCAN00082399 FEAT-1446: Optionally restart DCY on ClearAllDTCs
 *            2015-04-01  vismhe  ESCAN00082199 Compiler warning: Unitialized variable lReturnValue
 *            2015-04-08  visade  ESCAN00082399 FEAT-1446: Add option to displace Pending OBD Freeze Frame
 *            2015-04-09  vismhe  ESCAN00082289 Displacement of wrong DTC
 *            2015-04-09  vismhe  ESCAN00082319 Compiler error: Missing 'else' block
 *            2015-04-20  vismhe  ESCAN00082534 Compiler error or warning:  initializer type incompatible with object type
 *            2015-04-20  vismhe  ESCAN00082346 FEAT-56: Support data callbacks with EventId parameter
 *            2015-04-23  vismhe  ESCAN00082348 FEAT-285: Support healing for events without indicator
 *            2015-04-23  vismhe  ESCAN00082348 FEAT-285: Support debouncing while enable conditions are locked
 *            2015-05-05  visade  ESCAN00082811 Environmental data is missing for confirmed DTC
 *            2015-05-22  vismhe  ESCAN00082348 FEAT-285: Support entry retry
 *            2015-06-03  vismhe  ESCAN00082346 FEAT-56: Support data callbacks without NV storage
 *            2015-06-03  vismhe  ESCAN00082346 FEAT-56: Support JLR specific snapshot trigger
 *            2015-06-09  vismhe  ESCAN00082346 FEAT-56: Support aging at passed trigger for aging target == 0
 *            2015-06-26  vismhe  ESCAN00079889 Status change callback called without change of status
 *            2015-06-29  visade  ESCAN00083654 1-Trip DTC not available in Mode 0x0A
 *            2015-07-02  vismhe  ESCAN00083400 Compiler warning:  narrowing or signed-to-unsigned type conversion found
 *            2015-07-06  vismhe  ESCAN00083803 Combined events age without completed test
 *            2015-07-08  vismhe  ESCAN00082762 Compiler error: E0516: Zero sized structure 'DebounceInfo', E0823: Too long macro expansion 'VStdMemSet'
 *            2015-07-21  vismhe  ESCAN00084110 DID length is not included in snapshot record
 *  09.01.00  2015-09-04  vismhe  ESCAN00084615 ClearDTC for secondary memory deletes wrong DTCs
 *            2015-09-10  vismhe  ESCAN00085009 Support non-volatile availability setting
 *            2015-09-10  vismhe  ESCAN00084044 Indicator is reported active without requesting DTC
 *********************************************************************************************************************/
#define DEM_SOURCE

/* ********************************************************************************************************************
 *  GLOBAL MISRA VIOLATIONS
 *********************************************************************************************************************/

/* PRQA S 0828 EOF */ /* MD_MSR_1.1_828 */
/* PRQA S 0857 EOF */ /* MD_MSR_1.1_857 */

/* ********************************************************************************************************************
 *  INCLUDES
 *********************************************************************************************************************/

                                                       /* Dem module headers */
/* ------------------------------------------------------------------------- */
#include "Dem.h"
#include "Dem_Cbk.h"

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
# include "Dem_Dcm.h"
#endif

/* vendor specific version information is BCD coded */
#if (  (DEM_SW_MAJOR_VERSION != (0x09)) \
    || (DEM_SW_MINOR_VERSION != (0x01)) \
    || (DEM_SW_PATCH_VERSION != (0x00)) )
  #error "Vendor specific version numbers of Dem.c and Dem.h are inconsistent"
#endif

                            /* Development error tracer, for Det_ReportError */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
# include "Det.h"
#endif
/* ------------------------------------------------------------------------- */

                   /* Diagnostic Logger and Tracer, for callback declaration */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_NOTIFY_DLT == STD_ON)
# include "Dlt.h"
#endif
/* ------------------------------------------------------------------------- */

      /* Fault inhibition manager, for callbacks and IUMPR inhibition matrix */
/* ------------------------------------------------------------------------- */
#if (((DEM_CFG_SUPPORT_OBDII == STD_ON) || (DEM_CFG_SUPPORT_WWHOBD == STD_ON)) \
   && (DEM_CFG_SUPPORT_IUMPR == STD_ON)) || (DEM_CFG_NOTIFY_FIM == STD_ON)
# include "FiM.h"
#endif
/* ------------------------------------------------------------------------- */

                                  /* Schedule Manager, for critical sections */
/* ------------------------------------------------------------------------- */
#include "SchM_Dem.h"
/* ------------------------------------------------------------------------- */

                               /* Rte for forward global callback prototypes */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_USE_RTE == STD_ON)
# include "Rte_Dem.h"
#endif
/* ------------------------------------------------------------------------- */

                                            /* Dcm for notification callback */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_NOTIFY_DCM == STD_ON)
# include "Dcm.h"
#endif
/* ------------------------------------------------------------------------- */

                                       /* J1939Dcm for notification callback */
/* ------------------------------------------------------------------------- */
/* ------------------------------------------------------------------------- */

                                                          /* NvM for its API */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_USE_NVM == STD_ON)
# include "NvM.h"
#endif
/* ------------------------------------------------------------------------- */

                                                       /* EcuM for ErrorHook */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_VARIANT_POSTBUILD_LOADABLE == STD_ON)
# include "EcuM_Error.h"
#endif

                                      /* vstdlib for optimized copy routines */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_USE_MEMCOPY_MACROS != STD_ON)
# include "vstdlib.h"
#endif
/* ------------------------------------------------------------------------- */

/* ********************************************************************************************************************
 *  VERSION CHECK
 *********************************************************************************************************************/

/* versions of all included configuration header files shall be checked */
#if (  (DEM_CFG_SW_MAJOR_VERSION != (0x09)) \
    || (DEM_CFG_SW_MINOR_VERSION != (0x01)) )
# error "Version numbers of Dem.c and Dem_Cfg.h are inconsistent!"
#endif

#if (DEM_CFG_GEN_MAJOR_VERSION != (0x06))
# error "Incompatible configuration file version used!"
#endif

/* ********************************************************************************************************************
 *  OVERRIDES (define in user config file to change default behavior)
 *********************************************************************************************************************/
#if !defined (DEM_CFG_AGING_START_CLEARS_OBD_FF)
# define DEM_CFG_AGING_START_CLEARS_OBD_FF       STD_ON
#endif

/* ********************************************************************************************************************
 *  PRECOMPILE CONSTANT EVALUATION
 *********************************************************************************************************************/
#if (DEM_CFG_USE_DEFENSIVE_BEHAVIOR == STD_ON) || (DEM_CFG_USE_DET == STD_ON)
# define DEM_CFG_SUPPORT_ERROR_CHECKS            STD_ON
#else
# define DEM_CFG_SUPPORT_ERROR_CHECKS            STD_OFF
#endif

#define DEM_CFG_ISCONST_EVENTAVAILABLE           DEM_C_ISDEF_EVENTAVAILABLE
#define DEM_CFG_CONST_EVENTAVAILABLE             DEM_C_EQ2_EVENTAVAILABLE

#define DEM_CFG_ISCONST_DESTINATION              DEM_C_ISDEF_EVENTDESTINATIONOFEVENTTABLE
#define DEM_CFG_CONST_DESTINATION                DEM_C_EQ2_EVENTDESTINATIONOFEVENTTABLE

#define DEM_CFG_ISCONST_HEALINGTARGET            DEM_C_ISDEF_HEALINGTARGETOFEVENTTABLE
#define DEM_CFG_CONST_HEALINGTARGET              DEM_C_EQ2_HEALINGTARGETOFEVENTTABLE

#define DEM_CFG_ISCONST_AGINGTARGET              DEM_C_ISDEF_AGINGCYCLECOUNTERTHRESHOLDOFEVENTTABLE
#define DEM_CFG_CONST_AGINGTARGET                DEM_C_EQ2_AGINGCYCLECOUNTERTHRESHOLDOFEVENTTABLE

#if (DEM_C_EVENTLATCHTFOFEVENTTABLE == STD_ON)
# define DEM_CFG_ISCONST_LATCHTESTFAILED         DEM_C_ISDEF_EVENTLATCHTFOFEVENTTABLE
# define DEM_CFG_CONST_LATCHTESTFAILED           DEM_C_EQ2_EVENTLATCHTFOFEVENTTABLE
#else
# define DEM_CFG_ISCONST_LATCHTESTFAILED         STD_ON
# define DEM_CFG_CONST_LATCHTESTFAILED           FALSE
#endif

#if (DEM_C_EVENTDEBOUNCEBEHAVIOROFDEBOUNCETABLE == STD_ON)
# define DEM_CFG_ISCONST_DEBOUNCERESET           DEM_C_ISDEF_EVENTDEBOUNCEBEHAVIOROFDEBOUNCETABLE
# define DEM_CFG_CONST_DEBOUNCERESET             DEM_C_EQ2_EVENTDEBOUNCEBEHAVIOROFDEBOUNCETABLE
#else
# define DEM_CFG_ISCONST_DEBOUNCERESET           STD_ON
# define DEM_CFG_CONST_DEBOUNCERESET             FALSE
#endif

#if (DEM_C_DEBOUNCECONTINUOUSOFDEBOUNCETABLE == STD_ON)
# define DEM_CFG_ISCONST_DEBOUNCECONTINUOUS      DEM_C_ISDEF_DEBOUNCECONTINUOUSOFDEBOUNCETABLE
# define DEM_CFG_CONST_DEBOUNCECONTINUOUS        DEM_C_EQ2_DEBOUNCECONTINUOUSOFDEBOUNCETABLE
#else
# define DEM_CFG_ISCONST_DEBOUNCECONTINUOUS      STD_ON
# define DEM_CFG_CONST_DEBOUNCECONTINUOUS        FALSE
#endif

#if (DEM_C_AGINGALLOWEDOFEVENTTABLE == STD_ON)
# define DEM_CFG_ISCONST_SUPPORTAGING            DEM_C_ISDEF_AGINGALLOWEDOFEVENTTABLE
# define DEM_CFG_CONST_SUPPORTAGING              DEM_C_EQ2_AGINGALLOWEDOFEVENTTABLE
#else
# define DEM_CFG_ISCONST_SUPPORTAGING            STD_ON
# define DEM_CFG_CONST_SUPPORTAGING              FALSE
#endif

#if (DEM_C_JUMPDOWNOFDEBOUNCETABLE == STD_ON)
# define DEM_CFG_ISCONST_SUPPORTJUMPDOWN         DEM_C_ISDEF_JUMPDOWNOFDEBOUNCETABLE
# define DEM_CFG_CONST_SUPPORTJUMPDOWN           DEM_C_EQ2_JUMPDOWNOFDEBOUNCETABLE
#else
# define DEM_CFG_ISCONST_SUPPORTJUMPDOWN         STD_ON
# define DEM_CFG_CONST_SUPPORTJUMPDOWN           FALSE
#endif

#if (DEM_C_JUMPUPOFDEBOUNCETABLE == STD_ON)
# define DEM_CFG_ISCONST_SUPPORTJUMPUP           DEM_C_ISDEF_JUMPUPOFDEBOUNCETABLE
# define DEM_CFG_CONST_SUPPORTJUMPUP             DEM_C_EQ2_JUMPUPOFDEBOUNCETABLE
#else
# define DEM_CFG_ISCONST_SUPPORTJUMPUP           STD_ON
# define DEM_CFG_CONST_SUPPORTJUMPUP             FALSE
#endif

#if (DEM_C_BEHAVIOROFSPECIALINDICATORTABLE == STD_ON)
# define DEM_CFG_ISCONST_SPECIALINDICATORSTATE   DEM_C_ISDEF_BEHAVIOROFSPECIALINDICATORTABLE
# define DEM_CFG_CONST_SPECIALINDICATORSTATE     DEM_C_EQ2_BEHAVIOROFSPECIALINDICATORTABLE
#else
# define DEM_CFG_ISCONST_SPECIALINDICATORSTATE   STD_ON
# define DEM_CFG_CONST_SPECIALINDICATORSTATE     DEM_INDICATOR_OFF
#endif

#if (DEM_C_BEHAVIOROFNORMALINDICATORTABLE == STD_ON)
# define DEM_CFG_ISCONST_USERINDICATORSTATE      DEM_C_ISDEF_BEHAVIOROFNORMALINDICATORTABLE
# define DEM_CFG_CONST_USERINDICATORSTATE        DEM_C_EQ2_BEHAVIOROFNORMALINDICATORTABLE
#else
# define DEM_CFG_ISCONST_USERINDICATORSTATE      STD_ON
# define DEM_CFG_CONST_USERINDICATORSTATE        DEM_INDICATOR_OFF
#endif

#if (DEM_CFG_SUPPORT_NVM_IMMEDIATE == STD_ON)
# if (DEM_C_IMMEDIATENVSTORAGEOFDTCTABLE == STD_ON)
#  define DEM_CFG_ISCONST_NVM_IMMEDIATE          DEM_C_ISDEF_IMMEDIATENVSTORAGEOFDTCTABLE
#  define DEM_CFG_CONST_NVM_IMMEDIATE            DEM_C_EQ2_IMMEDIATENVSTORAGEOFDTCTABLE
# else
#  define DEM_CFG_ISCONST_NVM_IMMEDIATE          STD_ON
#  define DEM_CFG_CONST_NVM_IMMEDIATE            FALSE
# endif
#else
# define DEM_CFG_ISCONST_NVM_IMMEDIATE           STD_ON
# define DEM_CFG_CONST_NVM_IMMEDIATE             FALSE
#endif

#define DEM_CFG_ISCONST_TRIPTARGET               DEM_C_ISDEF_EVENTFAILURECYCLECOUNTERTHRESHOLDOFEVENTTABLE
#define DEM_CFG_CONST_TRIPTARGET                 DEM_C_EQ2_EVENTFAILURECYCLECOUNTERTHRESHOLDOFEVENTTABLE

#define DEM_CFG_ISCONST_PRIORITY                 DEM_C_ISDEF_EVENTPRIORITYOFEVENTTABLE
#define DEM_CFG_CONST_PRIORITY                   DEM_C_EQ2_EVENTPRIORITYOFEVENTTABLE

#if (DEM_C_FFUPDATEOFFREEZEFRAMENUMTABLE == STD_ON)
# define DEM_CFG_ISCONST_SREC_UPDATE             DEM_C_ISDEF_FFUPDATEOFFREEZEFRAMENUMTABLE
# define DEM_CFG_CONST_SREC_UPDATE               DEM_C_EQ2_FFUPDATEOFFREEZEFRAMENUMTABLE
#else
# define DEM_CFG_ISCONST_SREC_UPDATE             STD_ON
# define DEM_CFG_CONST_SREC_UPDATE               FALSE
#endif

#if ((DEM_CFG_SUPPORT_DEBOUNCE_TIME_HR == STD_ON) || (DEM_CFG_SUPPORT_DEBOUNCE_TIME_LR == STD_ON))
# define DEM_FEATURE_NEED_DEBOUNCE_TIME          STD_ON
#else
# define DEM_FEATURE_NEED_DEBOUNCE_TIME          STD_OFF
#endif

#if ((DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) || (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON))
# define DEM_FEATURE_NEED_DEBOUNCE               STD_ON
#else
# define DEM_FEATURE_NEED_DEBOUNCE               STD_OFF
#endif

#if ( (DEM_FEATURE_NEED_DEBOUNCE_TIME != STD_ON)   \
   || (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER != STD_ON) \
   || (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL != STD_ON) )
# define DEM_FEATURE_NEED_DEBOUNCE_INVALID       STD_ON
#else
# define DEM_FEATURE_NEED_DEBOUNCE_INVALID       STD_OFF
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE == STD_ON)
# if (DEM_CFG_ISCONST_DEBOUNCERESET == STD_ON)
#  if (DEM_CFG_CONST_DEBOUNCERESET == TRUE)
#   define DEM_FEATURE_NEED_DEBOUNCERESET        STD_ON
#  else
#   define DEM_FEATURE_NEED_DEBOUNCERESET        STD_OFF
#  endif
#  if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) || (DEM_CFG_CONST_DEBOUNCERESET == FALSE)
#   define DEM_FEATURE_NEED_DEBOUNCEFREEZE       STD_ON
#  else
#   define DEM_FEATURE_NEED_DEBOUNCEFREEZE       STD_OFF
#  endif
# else
#  define DEM_FEATURE_NEED_DEBOUNCERESET         STD_ON
#  if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
#   define DEM_FEATURE_NEED_DEBOUNCEFREEZE       STD_ON
#  else
#   define DEM_FEATURE_NEED_DEBOUNCEFREEZE       STD_OFF
#  endif
# endif
#else
# define DEM_FEATURE_NEED_DEBOUNCERESET          STD_OFF
# define DEM_FEATURE_NEED_DEBOUNCEFREEZE         STD_OFF
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE == STD_ON)
# if (DEM_CFG_ISCONST_DEBOUNCECONTINUOUS == STD_ON)
#  if (DEM_CFG_CONST_DEBOUNCECONTINUOUS == TRUE)
#   define DEM_FEATURE_NEED_DEBOUNCECONTINUOUS   STD_ON
#   define DEM_FEATURE_NEED_DEBOUNCEDISABLE      STD_OFF
#  else
#   define DEM_FEATURE_NEED_DEBOUNCECONTINUOUS   STD_OFF
#   define DEM_FEATURE_NEED_DEBOUNCEDISABLE      STD_ON
#  endif
# else
#  define DEM_FEATURE_NEED_DEBOUNCECONTINUOUS    STD_ON
#  define DEM_FEATURE_NEED_DEBOUNCEDISABLE       STD_ON
# endif
#else
# define DEM_FEATURE_NEED_DEBOUNCECONTINUOUS     STD_OFF
# define DEM_FEATURE_NEED_DEBOUNCEDISABLE        STD_OFF
#endif

#if ( (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON) \
   || (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON) \
   || (DEM_CFG_STORAGE_AT_FDC == STD_ON) )
# define DEM_FEATURE_NEED_FDC_TRIP               STD_ON
#else
# define DEM_FEATURE_NEED_FDC_TRIP               STD_OFF
#endif

#if (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
# if (DEM_CFG_MAX_NUMBER_COMBINED_GROUP > 0)
#  define DEM_FEATURE_NEED_TYPE1_COMBINATION     STD_ON
# else
#  define DEM_FEATURE_NEED_TYPE1_COMBINATION     STD_OFF
# endif
#else
# define DEM_FEATURE_NEED_TYPE1_COMBINATION      STD_OFF
#endif

#if (DEM_CFG_ISCONST_SUPPORTJUMPDOWN == STD_ON)
# if (DEM_CFG_CONST_SUPPORTJUMPDOWN == TRUE)
# define DEM_FEATURE_NEED_JUMPDOWN               STD_ON
# define DEM_FEATURE_NEED_EVENT_JUMPDOWN         STD_OFF
# else
# define DEM_FEATURE_NEED_JUMPDOWN               STD_OFF
# define DEM_FEATURE_NEED_EVENT_JUMPDOWN         STD_OFF
# endif
#else
#define DEM_FEATURE_NEED_JUMPDOWN                STD_ON
#define DEM_FEATURE_NEED_EVENT_JUMPDOWN          STD_ON
#endif

#if (DEM_CFG_ISCONST_SUPPORTJUMPUP == STD_ON)
# if (DEM_CFG_CONST_SUPPORTJUMPUP == TRUE)
# define DEM_FEATURE_NEED_JUMPUP                 STD_ON
# define DEM_FEATURE_NEED_EVENT_JUMPUP           STD_OFF
# else
# define DEM_FEATURE_NEED_JUMPUP                 STD_OFF
# define DEM_FEATURE_NEED_EVENT_JUMPUP           STD_OFF
# endif
#else
#define DEM_FEATURE_NEED_JUMPUP                  STD_ON
#define DEM_FEATURE_NEED_EVENT_JUMPUP            STD_ON
#endif

#if (DEM_CFG_ISCONST_LATCHTESTFAILED == STD_ON)
# if (DEM_CFG_CONST_LATCHTESTFAILED == TRUE)
#  define DEM_FEATURE_NEED_LATCHTESTFAILED       STD_ON
# else
#  define DEM_FEATURE_NEED_LATCHTESTFAILED       STD_OFF
# endif
#else
# define DEM_FEATURE_NEED_LATCHTESTFAILED        STD_ON
#endif

#if ( (DEM_CFG_AGING_AFTER_HEALING == STD_ON)         \
   || (DEM_CFG_AGING_AFTER_HEALING_ALL_DTC == STD_ON) )
# define DEM_FEATURE_NEED_AGING_AFTER_HEALING    STD_ON
# define DEM_FEATURE_NEED_AGING_AFTER_HEALING_MIL_ONLY   STD_OFF
#else
# if (DEM_CFG_SUPPORT_OBDII == STD_ON) || (DEM_CFG_SUPPORT_WWHOBD == STD_ON)
#  define DEM_FEATURE_NEED_AGING_AFTER_HEALING   STD_ON
#  define DEM_FEATURE_NEED_AGING_AFTER_HEALING_MIL_ONLY  STD_ON
# else
#  define DEM_FEATURE_NEED_AGING_AFTER_HEALING   STD_OFF
#  define DEM_FEATURE_NEED_AGING_AFTER_HEALING_MIL_ONLY  STD_OFF
# endif
#endif

#if (DEM_CFG_ISCONST_SUPPORTAGING == STD_ON)
# if (DEM_CFG_CONST_SUPPORTAGING == TRUE)
#  define DEM_FEATURE_NEED_AGING_AGE             STD_ON
#  define DEM_FEATURE_NEED_AGING_LATCH           STD_OFF
#  if (DEM_CFG_ISCONST_AGINGTARGET == STD_ON)
#   if (DEM_CFG_CONST_AGINGTARGET == 0)
#    define DEM_FEATURE_NEED_AGING_IMMEDIATE     STD_ON
#    define DEM_FEATURE_NEED_AGING_DELAYED       STD_OFF
#   else
#    define DEM_FEATURE_NEED_AGING_IMMEDIATE     STD_OFF
#    define DEM_FEATURE_NEED_AGING_DELAYED       STD_ON
#   endif
#  else
#    define DEM_FEATURE_NEED_AGING_IMMEDIATE     STD_ON
#    define DEM_FEATURE_NEED_AGING_DELAYED       STD_ON
#  endif
# else
#  define DEM_FEATURE_NEED_AGING_AGE             STD_OFF
#  define DEM_FEATURE_NEED_AGING_LATCH           STD_ON
#  define DEM_FEATURE_NEED_AGING_IMMEDIATE       STD_OFF
#  define DEM_FEATURE_NEED_AGING_DELAYED         STD_OFF
# endif
#else
# define DEM_FEATURE_NEED_AGING_AGE              STD_ON
# define DEM_FEATURE_NEED_AGING_LATCH            STD_ON
# if (DEM_CFG_ISCONST_AGINGTARGET == STD_ON)
#  if (DEM_CFG_CONST_AGINGTARGET == 0)
#   define DEM_FEATURE_NEED_AGING_IMMEDIATE      STD_ON
#   define DEM_FEATURE_NEED_AGING_DELAYED        STD_OFF
#  else
#   define DEM_FEATURE_NEED_AGING_IMMEDIATE      STD_OFF
#   define DEM_FEATURE_NEED_AGING_DELAYED        STD_ON
#  endif
# else
#   define DEM_FEATURE_NEED_AGING_IMMEDIATE      STD_ON
#   define DEM_FEATURE_NEED_AGING_DELAYED        STD_ON
# endif
#endif

#if (DEM_CFG_PROCESS_CDTC_ALL_DTC == STD_ON)
# define DEM_FEATURE_NEED_AGING_REALLOCATION     STD_ON
#else
# define DEM_FEATURE_NEED_AGING_REALLOCATION     STD_OFF
#endif

#if (DEM_CFG_ISCONST_SREC_UPDATE == STD_ON)
# if (DEM_CFG_CONST_SREC_UPDATE == FALSE)
#  define DEM_FEATURE_NEED_SRECS_FROZEN          STD_ON
# else
#  define DEM_FEATURE_NEED_SRECS_FROZEN          STD_OFF
# endif
#else
# define DEM_FEATURE_NEED_SRECS_FROZEN           STD_ON
#endif

#if (DEM_CFG_ISCONST_DESTINATION == STD_ON)
# if (DEM_CFG_CONST_DESTINATION == DEM_CFG_MEMORYID_PRIMARY)
#  define DEM_FEATURE_NEED_SECONDARY             STD_OFF
# else
#  error "Primary memory is required"
# endif
#else
# define DEM_FEATURE_NEED_SECONDARY              DEM_CFG_SUPPORT_SECONDARY
# if (DEM_FEATURE_NEED_SECONDARY != STD_ON)
#  undef DEM_CFG_ISCONST_DESTINATION                                                                                             /* PRQA S 0841 */ /* MD_DEM_19.6 */
#  define DEM_CFG_ISCONST_DESTINATION            STD_ON
#  if defined (DEM_CFG_CONST_DESTINATION)
#   undef DEM_CFG_CONST_DESTINATION                                                                                              /* PRQA S 0841 */ /* MD_DEM_19.6 */
#  endif
#  define DEM_CFG_CONST_DESTINATION              DEM_CFG_MEMORYID_PRIMARY
# endif
#endif

#if (DEM_CFG_VARIANT_POSTBUILD_SELECTABLE == STD_ON)
# if (DEM_CFG_ISCONST_AVAILABLEINVARIANT == STD_ON)
#  define DEM_CFG_CONST_EVENTINVARIANT           DEM_C_EQ2_EVENTAVAILABLEINVARIANT
#  if (FALSE == DEM_CFG_CONST_EVENTINVARIANT)
#   error "It is not supported to disable all events in all variants"
#  endif
# else
#  define DEM_CFG_CONST_EVENTINVARIANT           TRUE
# endif
#else
# if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
#   error "Disabling events per variant is only supported in postbuild selectable configurations"
# endif
#endif

#if (DEM_CFG_USE_NVM == STD_ON)
# if ( (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON) \
    || (DEM_CFG_SUPPORT_NVM_IMMEDIATE == STD_ON) \
    || (DEM_CFG_SUPPORT_NVM_APPL_SYNCHRONIZE == STD_ON) \
    )
#  define DEM_FEATURE_NEED_NVM_IMMEDIATE         STD_ON
# else
#  define DEM_FEATURE_NEED_NVM_IMMEDIATE         STD_OFF
# endif
#else
# define DEM_FEATURE_NEED_NVM_IMMEDIATE          STD_OFF
#endif

#if (DEM_CFG_SUPPORT_NVM_IMMEDIATE == STD_ON)
# if (DEM_CFG_ISCONST_NVM_IMMEDIATE == STD_ON)
#  if (TRUE == DEM_CFG_CONST_NVM_IMMEDIATE)
#   define DEM_FEATURE_NEED_DIRTYIMMEDIATE       STD_ON
#   define DEM_FEATURE_NEED_DIRTY                STD_OFF
#   define DEM_FEATURE_NEED_NVM_WRITELIMIT       DEM_CFG_SUPPORT_NVM_WRITELIMIT
#  else
#   define DEM_FEATURE_NEED_DIRTYIMMEDIATE       STD_OFF
#   define DEM_FEATURE_NEED_DIRTY                STD_ON
#   define DEM_FEATURE_NEED_NVM_WRITELIMIT       STD_OFF
#  endif
# else
#  define DEM_FEATURE_NEED_DIRTYIMMEDIATE        STD_ON
#  define DEM_FEATURE_NEED_DIRTY                 STD_ON
#  define DEM_FEATURE_NEED_NVM_WRITELIMIT        DEM_CFG_SUPPORT_NVM_WRITELIMIT
# endif
#else
# define DEM_FEATURE_NEED_DIRTYIMMEDIATE         STD_OFF
# define DEM_FEATURE_NEED_DIRTY                  STD_ON
# define DEM_FEATURE_NEED_NVM_WRITELIMIT         STD_OFF
#endif

#if ( (DEM_CFG_NOTIFY_FIM == STD_ON) \
   || (DEM_CFG_NOTIFY_DLT == STD_ON) \
   || (DEM_CFG_NOTIFY_EVENT_STATUS == STD_ON) \
   || (DEM_CFG_NOTIFY_GENERAL_STATUS == STD_ON) )
# define DEM_FEATURE_NEED_NOTIFY_EVENT           STD_ON
#else
# define DEM_FEATURE_NEED_NOTIFY_EVENT           STD_OFF
#endif

#if ( (DEM_CFG_NOTIFY_DTC_STATUS == STD_ON) \
   || (DEM_CFG_NOTIFY_DCM == STD_ON) \
   || (DEM_CFG_NOTIFY_J1939DTC_STATUS == STD_ON) \
   || (DEM_CFG_NOTIFY_J1939DCM == STD_ON) )
# define DEM_FEATURE_NEED_NOTIFY_DTC             STD_ON
#else
# define DEM_FEATURE_NEED_NOTIFY_DTC             STD_OFF
#endif

#if ( (DEM_CFG_NOTIFY_EVENT_DATA == STD_ON) \
  || (DEM_CFG_NOTIFY_GENERAL_DATA == STD_ON) )
# define DEM_FEATURE_NEED_NOTIFY_DATA            STD_ON
#else
# define DEM_FEATURE_NEED_NOTIFY_DATA            STD_OFF
#endif

#if ( (DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON) \
  || (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON) \
  || (DEM_FEATURE_NEED_NOTIFY_DATA == STD_ON) )
# define DEM_FEATURE_NEED_NOTIFY                 STD_ON
#else
# define DEM_FEATURE_NEED_NOTIFY                 STD_OFF
#endif

#if (DEM_CFG_SUPPORT_OPCYCLE_STORAGE == STD_ON) && (DEM_CFG_SUPPORT_OPCYCLE_AUTOMATIC_END == STD_ON)
# define DEM_FEATURE_NEED_CYCLEAUTOMATICEND      STD_ON
#else
# define DEM_FEATURE_NEED_CYCLEAUTOMATICEND      STD_OFF
#endif

#if (DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON) || (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
# define DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE     STD_ON
#else
# define DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE     STD_OFF
#endif

#if (DEM_FEATURE_NEED_NVM_WRITELIMIT == STD_ON) || (DEM_CFG_DATA_OCCCTR == STD_ON) || (DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON) || (DEM_CFG_SUPPORT_J1939 == STD_ON)
# define DEM_FEATURE_NEED_OCC_COUNTER            STD_ON
#else
# define DEM_FEATURE_NEED_OCC_COUNTER            STD_OFF
#endif

#if (DEM_CFG_DATA_OVFLIND == STD_ON)
# define DEM_FEATURE_NEED_OVFLIND                STD_ON
#else
# define DEM_FEATURE_NEED_OVFLIND                DEM_CFG_SUPPORT_OVFLIND_API
#endif

#define DEM_FEATURE_NEED_SREC_OEMTRIGGER         STD_OFF

#if ((DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON) || (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON))
# define DEM_FEATURE_NEED_SUPPRESSION            STD_ON
#else
# define DEM_FEATURE_NEED_SUPPRESSION            STD_OFF
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
# define DEM_FEATURE_NEED_EVENTAVAILABLE_DEFAULT  DEM_CFG_SUPPORT_EVENTAVAILABLE_DEFAULT
#else
# define DEM_FEATURE_NEED_EVENTAVAILABLE_DEFAULT  STD_OFF
#endif

#if (DEM_CFG_ISCONST_EVENTAVAILABLE == STD_ON)
# if (DEM_CFG_CONST_EVENTAVAILABLE == TRUE)
#  define DEM_FEATURE_NEED_EVENTAVAILABLE         STD_ON
#  define DEM_FEATURE_NEED_EVENTNOTAVAILABLE      STD_OFF
# else
#  define DEM_FEATURE_NEED_EVENTAVAILABLE         STD_OFF
#  define DEM_FEATURE_NEED_EVENTNOTAVAILABLE      STD_ON
# endif
#else
# define DEM_FEATURE_NEED_EVENTAVAILABLE          STD_ON
# define DEM_FEATURE_NEED_EVENTNOTAVAILABLE       STD_ON
#endif

#if ( (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON) \
   || (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON) \
   || (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) \
   || (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON) )
# define DEM_FEATURE_NEED_TESTSUPPRESSION        STD_ON
#else
# define DEM_FEATURE_NEED_TESTSUPPRESSION        STD_OFF
#endif

#define DEM_FEATURE_NEED_OBD_ODOMETER            STD_OFF
#define DEM_FEATURE_NEED_FREEZEFRAME_OBDII       STD_OFF
#define DEM_FEATURE_NEED_FREEZEFRAME_WWHOBD      STD_OFF
#define DEM_FEATURE_NEED_OBD                     STD_OFF

#if (DEM_CFG_SUPPORT_INDICATORS == STD_ON)
# define DEM_FEATURE_NEED_USER_INDICATORS        DEM_C_NORMALINDICATORTABLE
#else
# define DEM_FEATURE_NEED_USER_INDICATORS        STD_OFF
#endif

#if (DEM_FEATURE_NEED_USER_INDICATORS == STD_ON) || (DEM_FEATURE_NEED_OBD == STD_ON)
# define DEM_FEATURE_NEED_INDICATORS             STD_ON
#else
# define DEM_FEATURE_NEED_INDICATORS             STD_OFF
#endif

#if (DEM_FEATURE_NEED_USER_INDICATORS == STD_ON)
# if (DEM_CFG_ISCONST_USERINDICATORSTATE == STD_ON)
#  if (DEM_CFG_CONST_USERINDICATORSTATE == DEM_INDICATOR_CONTINUOUS)
#   define DEM_FEATURE_NEED_USER_INDICATOR_CONTINUOUS  STD_ON
#   define DEM_FEATURE_NEED_USER_INDICATOR_BLINKING    STD_OFF
#  endif
#  if (DEM_CFG_CONST_USERINDICATORSTATE == DEM_INDICATOR_BLINKING)
#   define DEM_FEATURE_NEED_USER_INDICATOR_CONTINUOUS  STD_OFF
#   define DEM_FEATURE_NEED_USER_INDICATOR_BLINKING    STD_ON
#  endif
#  if (DEM_CFG_CONST_USERINDICATORSTATE == DEM_INDICATOR_BLINK_CONT)
#   define DEM_FEATURE_NEED_USER_INDICATOR_CONTINUOUS  STD_ON
#   define DEM_FEATURE_NEED_USER_INDICATOR_BLINKING    STD_ON
#  endif
# else
#  define DEM_FEATURE_NEED_USER_INDICATOR_CONTINUOUS   STD_ON
#  define DEM_FEATURE_NEED_USER_INDICATOR_BLINKING     STD_ON
# endif
#else
# define DEM_FEATURE_NEED_USER_INDICATOR_CONTINUOUS    STD_OFF
# define DEM_FEATURE_NEED_USER_INDICATOR_BLINKING      STD_OFF
#endif

#if (DEM_CFG_AGING_AFTER_HEALING_ALL_DTC == STD_ON) || (DEM_FEATURE_NEED_INDICATORS == STD_ON)
# define DEM_FEATURE_NEED_HEALING                STD_ON
#else
# define DEM_FEATURE_NEED_HEALING                STD_OFF
#endif

#if (DEM_CFG_ISCONST_TRIPTARGET == STD_ON)
# if (DEM_CFG_CONST_TRIPTARGET == 0)
#  define DEM_FEATURE_NEED_SINGLETRIP            STD_ON
#  define DEM_FEATURE_NEED_TWOTRIP               STD_OFF
#  define DEM_FEATURE_NEED_MULTITRIP             STD_OFF
# elif (DEM_CFG_CONST_TRIPTARGET == 1)
#  define DEM_FEATURE_NEED_SINGLETRIP            STD_OFF
#  define DEM_FEATURE_NEED_TWOTRIP               STD_ON
#  define DEM_FEATURE_NEED_MULTITRIP             STD_OFF
# else
#  define DEM_FEATURE_NEED_SINGLETRIP            STD_OFF
#  define DEM_FEATURE_NEED_TWOTRIP               STD_OFF
#  define DEM_FEATURE_NEED_MULTITRIP             STD_ON
# endif
#else
# if (DEM_CFG_SUPPORT_MULTITRIP == STD_ON)
#  define DEM_FEATURE_NEED_SINGLETRIP            STD_OFF
#  define DEM_FEATURE_NEED_TWOTRIP               STD_OFF
#  define DEM_FEATURE_NEED_MULTITRIP             STD_ON
# else
#  define DEM_FEATURE_NEED_SINGLETRIP            STD_ON
#  define DEM_FEATURE_NEED_TWOTRIP               STD_ON
#  define DEM_FEATURE_NEED_MULTITRIP             STD_OFF
# endif
#endif

#if (DEM_FEATURE_NEED_HEALING == STD_ON)
# if (DEM_CFG_ISCONST_HEALINGTARGET == STD_ON)
#  if (DEM_CFG_CONST_HEALINGTARGET == 0)
#   define DEM_FEATURE_NEED_IMMEDIATEHEAL        STD_ON
#   define DEM_FEATURE_NEED_SINGLEHEAL           STD_OFF
#   define DEM_FEATURE_NEED_MULTIHEAL            STD_OFF
#  elif (DEM_CFG_CONST_HEALINGTARGET == 1)
#   define DEM_FEATURE_NEED_IMMEDIATEHEAL        STD_OFF
#   define DEM_FEATURE_NEED_SINGLEHEAL           STD_ON
#   define DEM_FEATURE_NEED_MULTIHEAL            STD_OFF
#  else
#   define DEM_FEATURE_NEED_IMMEDIATEHEAL        STD_OFF
#   define DEM_FEATURE_NEED_SINGLEHEAL           STD_OFF
#   define DEM_FEATURE_NEED_MULTIHEAL            STD_ON
#  endif
# else
#  define DEM_FEATURE_NEED_IMMEDIATEHEAL         STD_ON
#  define DEM_FEATURE_NEED_SINGLEHEAL            STD_OFF
#  define DEM_FEATURE_NEED_MULTIHEAL             STD_ON
# endif
#else
# define DEM_FEATURE_NEED_IMMEDIATEHEAL          STD_OFF
# define DEM_FEATURE_NEED_SINGLEHEAL             STD_OFF
# define DEM_FEATURE_NEED_MULTIHEAL              STD_OFF
#endif

#if ((DEM_FEATURE_NEED_MULTITRIP == STD_ON) || (DEM_FEATURE_NEED_MULTIHEAL == STD_ON))
# define DEM_FEATURE_NEED_TRIPCOUNTER            STD_ON
#else
# define DEM_FEATURE_NEED_TRIPCOUNTER            STD_OFF
#endif

#if ((DEM_FEATURE_NEED_MULTITRIP == STD_ON) || (DEM_FEATURE_NEED_TWOTRIP == STD_ON))
# define DEM_FEATURE_NEED_TRIPPING               STD_ON
#else
# define DEM_FEATURE_NEED_TRIPPING               STD_OFF
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON))
# if ( (DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON) \
    || (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON) )
#  define DEM_FEATURE_NEED_CYCLE_COUNTERS        STD_ON
# else
#  define DEM_FEATURE_NEED_CYCLE_COUNTERS        STD_OFF
# endif
#else
# define DEM_FEATURE_NEED_CYCLE_COUNTERS         STD_OFF
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON))
# if ( (DEM_FEATURE_NEED_CYCLE_COUNTERS == STD_ON) \
    || (DEM_CFG_DATA_AGINGCTR == STD_ON)           \
    || (DEM_CFG_DATA_AGINGCTR_INVERTED == STD_ON) )
#  define DEM_FEATURE_NEED_AGING_CYCLE_DISTANCE  STD_ON
# else
#  define DEM_FEATURE_NEED_AGING_CYCLE_DISTANCE  STD_OFF
# endif
#else
# define DEM_FEATURE_NEED_AGING_CYCLE_DISTANCE   STD_OFF
#endif

#if (DEM_CFG_PROCESS_CDTC_STOREDONLY == STD_ON)
# define DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY STD_ON
#else
# define DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY STD_OFF
#endif

#define DEM_FEATURE_NEED_ENGINE_RUN_TIME         STD_OFF

#if (DEM_CFG_SUPPORT_API_VERSION_4_2_1 == STD_ON)
# if ( ((DEM_CFG_NOTIFY_INIT_MONITOR == STD_ON) || (DEM_CFG_NOTIFY_INIT_FUNC == STD_ON)) \
    && (DEM_CFG_NOTIFY_ENABLECONDITION == STD_ON) )
#  define DEM_FEATURE_NEED_NOTIFY_ENABLE_CONDITION     STD_ON
# else
#  define DEM_FEATURE_NEED_NOTIFY_ENABLE_CONDITION     STD_OFF
# endif
# if ( (DEM_FEATURE_NEED_DEBOUNCERESET == STD_ON) \
    || (DEM_FEATURE_NEED_DEBOUNCEFREEZE == STD_ON) \
    || (DEM_FEATURE_NEED_NOTIFY_ENABLE_CONDITION == STD_ON) )
#  define DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS  STD_ON
# else
# define DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS   STD_OFF
# endif
#else
# define DEM_FEATURE_NEED_NOTIFY_ENABLE_CONDITION      STD_OFF
# define DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS   STD_OFF
#endif

/* ********************************************************************************************************************
 *  LOCAL CONSTANT MACROS
 *********************************************************************************************************************/

#if !defined (DEM_LOCAL)
# define DEM_LOCAL                               static
#endif

#if !defined (DEM_LOCAL_INLINE)
# define DEM_LOCAL_INLINE                        LOCAL_INLINE
#endif

#if (DEM_CFG_SUPPORT_SPLIT_TASKS == STD_ON)
# define DEM_MAINFUNC_LINKAGE
#else
# define DEM_MAINFUNC_LINKAGE                    DEM_LOCAL_INLINE
#endif

#define DEM_1BYTE                                1
#define DEM_2BYTE                                2

#define DEM_MASK_1                               0xffU
#define DEM_MASK_2                               0xffffU
#define DEM_MASK(size)                           DEM_MASK_##size                                                                 /* PRQA S 0342, 3453 */ /* MD_DEM_19.13, MD_MSR_19.7 */

#define DEM_BIT(pos)                             (0x01U << (pos))                                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_BIT_MASK(pos, size)                  (DEM_MASK(size) ^ DEM_BIT(pos))                                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define DEM_NBIT(n, pos)                         ((DEM_MASK(1) >> (8u-(n))) << (pos))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_NBIT_MASK(n, pos, size)              (DEM_MASK(size) ^ DEM_NBIT(n, pos))                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define DEM_EVAL(x)                              (x)                                                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */

                                                                    /* Admin */
/* ------------------------------------------------------------------------- */

#define DEM_INIT_UNINITIALIZED                   (0U)                /* Initialization state directly after system startup */
#define DEM_INIT_PREINITIALIZED                  (1U)                /* Initialization state after Dem_PreInit */
#define DEM_INIT_SHUTDOWN                        (2U)                /* Initialization state after Dem_Shutdown */
#define DEM_INIT_INITIALIZED                     (3U)                /* Initialization state after Dem_Init */

                                                                    /* Queue */
/* ------------------------------------------------------------------------- */

#define DEM_QUEUE_CYCLE_STOPPED                  (1U)
#define DEM_QUEUE_CYCLE_STARTED                  (2U)
#define DEM_QUEUE_CYCLE_RESTARTED                (3U)

#define DEM_QUEUE_EVENT_NONE                     (0x00U)
#define DEM_QUEUE_EVENT_QUEUED                   (0x40U)
#define DEM_QUEUE_EVENT_PENDING                  (0x80U)

#define DEM_QUEUE_CLEARSTATE_IDLE                (0x00U)

                                                           /* Data Provision */
/* ------------------------------------------------------------------------- */

#define DEM_DATA_INVALID_DATA_PATTERN            (0xffU)

#if (DEM_CFG_PROCESS_OCCTR_CONFIRMED == STD_ON)
# define DEM_DATA_OCCURRENCE_INIT                (1U)
#else
# define DEM_DATA_OCCURRENCE_INIT                (0U)
#endif

#if (DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON)
# define DEM_DATA_OCCURRENCE_MAX                 (0xffffU)
#else
# define DEM_DATA_OCCURRENCE_MAX                 (0xffU)
#endif

                                                     /* Memory Manager [MEM] */
/* ------------------------------------------------------------------------- */

#define DEM_MEM_INVALID_MEMORY_INDEX             Dem_Cfg_GlobalNvBlockCount()

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
# define DEM_MEM_INVALID_PRESTORAGE_INDEX        Dem_Cfg_GlobalPrestorageSize()
# define DEM_MEM_INVALID_PRESTORAGE_REF          Dem_Cfg_GlobalPrestorageEventCount()
#endif
#define DEM_MEM_PID_AGING_COUNTER_THRESHOLD      0x28U

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */
#define DEM_ENABLECONDITION_CONTROLDTCSETTING    0

#define DEM_UDS_STATUS_INITIALIZE                (0x50U)
#define DEM_PC_STATUS_INITIALIZE                 (0x00U)

#define DEM_UDS_STATUS_TF_MASK                   DEM_BIT_MASK(0, DEM_1BYTE)
#define DEM_UDS_STATUS_TFTOC_MASK                DEM_BIT_MASK(1, DEM_1BYTE)
#define DEM_UDS_STATUS_PDTC_MASK                 DEM_BIT_MASK(2, DEM_1BYTE)
#define DEM_UDS_STATUS_CDTC_MASK                 DEM_BIT_MASK(3, DEM_1BYTE)
#define DEM_UDS_STATUS_TNCSLC_MASK               DEM_BIT_MASK(4, DEM_1BYTE)
#define DEM_UDS_STATUS_TFSLC_MASK                DEM_BIT_MASK(5, DEM_1BYTE)
#define DEM_UDS_STATUS_TNCTOC_MASK               DEM_BIT_MASK(6, DEM_1BYTE)
#define DEM_UDS_STATUS_WIR_MASK                  DEM_BIT_MASK(7, DEM_1BYTE)

/* Internal status bits */
#define DEM_ESM_DEBOUNCE_STATUS_SIZE             4
#define DEM_ESM_STORED_STATUS_SIZE               2
#define DEM_ESM_SUPPRESSED_EVENT_SIZE            1
#define DEM_ESM_SUPPRESSED_DTC_SIZE              1
#define DEM_ESM_DISCONNECTED_EVENT_SIZE          1
#define DEM_ESM_FDC_TRIP_SIZE                    1
#define DEM_ESM_FDC_MAX_SIZE                     1
#define DEM_ESM_FDC_TOC_SIZE                     1
#define DEM_ESM_AVAILABLEINVARIANT_SIZE          1

#define DEM_ESM_USER_CONTROLLED_WIR_POS          7

#if (DEM_CFG_SUPPORT_DEBOUNCE_TIME == STD_ON)
# define DEM_ESM_DEBOUNCE_STATUS_POS             0
# define DEM_ESM_DEBOUNCE_STATUS_END             (DEM_ESM_DEBOUNCE_STATUS_POS + DEM_ESM_DEBOUNCE_STATUS_SIZE)
#else
# define DEM_ESM_DEBOUNCE_STATUS_POS             0
# define DEM_ESM_DEBOUNCE_STATUS_END             0
#endif

#define DEM_ESM_STORED_STATUS_POS                DEM_ESM_DEBOUNCE_STATUS_END
#define DEM_ESM_STORED_STATUS_END                (DEM_ESM_STORED_STATUS_POS + DEM_ESM_STORED_STATUS_SIZE)

#if (DEM_FEATURE_NEED_SUPPRESSION == STD_ON)
# define DEM_ESM_SUPPRESSED_EVENT_POS            DEM_ESM_STORED_STATUS_END
# define DEM_ESM_SUPPRESSED_EVENT_END            (DEM_ESM_SUPPRESSED_EVENT_POS + DEM_ESM_SUPPRESSED_EVENT_SIZE)
#else
# define DEM_ESM_SUPPRESSED_EVENT_POS            DEM_ESM_STORED_STATUS_POS
# define DEM_ESM_SUPPRESSED_EVENT_END            DEM_ESM_STORED_STATUS_END
#endif

#if (DEM_FEATURE_NEED_SUPPRESSION == STD_ON)
# if ( (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) \
    && (DEM_ESM_SUPPRESSED_EVENT_END == DEM_ESM_USER_CONTROLLED_WIR_POS) )
#  define DEM_ESM_SUPPRESSED_DTC_POS             (DEM_ESM_SUPPRESSED_EVENT_END + 1)
# else
#  define DEM_ESM_SUPPRESSED_DTC_POS             DEM_ESM_SUPPRESSED_EVENT_END
# endif
# define DEM_ESM_SUPPRESSED_DTC_END              (DEM_ESM_SUPPRESSED_DTC_POS + DEM_ESM_SUPPRESSED_DTC_SIZE)
#else
# define DEM_ESM_SUPPRESSED_DTC_POS              DEM_ESM_SUPPRESSED_EVENT_POS
# define DEM_ESM_SUPPRESSED_DTC_END              DEM_ESM_SUPPRESSED_EVENT_END
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
# if ( (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) \
    && (DEM_ESM_SUPPRESSED_DTC_END == DEM_ESM_USER_CONTROLLED_WIR_POS) )
#  define DEM_ESM_DISCONNECTED_EVENT_POS         (DEM_ESM_SUPPRESSED_DTC_END + 1)
# else
#  define DEM_ESM_DISCONNECTED_EVENT_POS         DEM_ESM_SUPPRESSED_DTC_END
# endif
# define DEM_ESM_DISCONNECTED_EVENT_END          (DEM_ESM_DISCONNECTED_EVENT_POS + DEM_ESM_DISCONNECTED_EVENT_SIZE)
#else
# define DEM_ESM_DISCONNECTED_EVENT_POS          DEM_ESM_SUPPRESSED_DTC_POS
# define DEM_ESM_DISCONNECTED_EVENT_END          DEM_ESM_SUPPRESSED_DTC_END
#endif

#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
# if ( (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) \
    && (DEM_ESM_DISCONNECTED_EVENT_END == DEM_ESM_USER_CONTROLLED_WIR_POS) )
#  define DEM_ESM_FDC_TRIP_POS                   (DEM_ESM_DISCONNECTED_EVENT_END + 1)
# else
#  define DEM_ESM_FDC_TRIP_POS                   DEM_ESM_DISCONNECTED_EVENT_END
# endif
# define DEM_ESM_FDC_TRIP_END                    (DEM_ESM_FDC_TRIP_POS + DEM_ESM_FDC_TRIP_SIZE)
#else
# define DEM_ESM_FDC_TRIP_POS                    DEM_ESM_DISCONNECTED_EVENT_POS
# define DEM_ESM_FDC_TRIP_END                    DEM_ESM_DISCONNECTED_EVENT_END
#endif

#if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
# if ( (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) \
    && (DEM_ESM_FDC_TRIP_END == DEM_ESM_USER_CONTROLLED_WIR_POS) )
#  define DEM_ESM_FDC_MAX_POS                    (DEM_ESM_FDC_TRIP_END + 1)
# else
#  define DEM_ESM_FDC_MAX_POS                    DEM_ESM_FDC_TRIP_END
# endif
# define DEM_ESM_FDC_MAX_END                     (DEM_ESM_FDC_MAX_POS + DEM_ESM_FDC_MAX_SIZE)
#else
# define DEM_ESM_FDC_MAX_POS                     DEM_ESM_FDC_TRIP_POS
# define DEM_ESM_FDC_MAX_END                     DEM_ESM_FDC_TRIP_END
#endif

#if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON)
# if ( (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) \
    && (DEM_ESM_FDC_MAX_END == DEM_ESM_USER_CONTROLLED_WIR_POS) )
#  define DEM_ESM_FDC_TOC_POS                    (DEM_ESM_FDC_MAX_END + 1)
# else
#  define DEM_ESM_FDC_TOC_POS                    DEM_ESM_FDC_MAX_END
# endif
# define DEM_ESM_FDC_TOC_END                     (DEM_ESM_FDC_TOC_POS + DEM_ESM_FDC_TOC_SIZE)
#else
# define DEM_ESM_FDC_TOC_POS                     DEM_ESM_FDC_MAX_POS
# define DEM_ESM_FDC_TOC_END                     DEM_ESM_FDC_MAX_END
#endif

#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON) && (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
# if ( (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) \
    && (DEM_ESM_FDC_TOC_END == DEM_ESM_USER_CONTROLLED_WIR_POS) )
#  define DEM_ESM_AVAILABLEINVARIANT_POS         (DEM_ESM_FDC_TOC_END + 1)
# else
#  define DEM_ESM_AVAILABLEINVARIANT_POS         DEM_ESM_FDC_TOC_END
# endif
# define DEM_ESM_AVAILABLEINVARIANT_END          (DEM_ESM_AVAILABLEINVARIANT_POS + DEM_ESM_AVAILABLEINVARIANT_SIZE)
#else
# define DEM_ESM_AVAILABLEINVARIANT_POS          DEM_ESM_FDC_TOC_POS
# define DEM_ESM_AVAILABLEINVARIANT_END          DEM_ESM_FDC_TOC_END
#endif

#if (DEM_ESM_AVAILABLEINVARIANT_POS < 8)
# define DEM_ESM_INTERNAL_STATUS_BYTESIZE        DEM_1BYTE
#else
# define DEM_ESM_INTERNAL_STATUS_BYTESIZE        DEM_2BYTE
#endif

#define DEM_ESM_DEBOUNCE_STATUS                  DEM_NBIT(DEM_ESM_DEBOUNCE_STATUS_SIZE, DEM_ESM_DEBOUNCE_STATUS_POS)
#define DEM_ESM_DEBOUNCE_STATUS_MASK             DEM_NBIT_MASK(DEM_ESM_DEBOUNCE_STATUS_SIZE, DEM_ESM_DEBOUNCE_STATUS_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)

#define DEM_ESM_STORED_STATUS                    DEM_NBIT(DEM_ESM_STORED_STATUS_SIZE, DEM_ESM_STORED_STATUS_POS)
#define DEM_ESM_STORED_STATUS_MASK               DEM_NBIT_MASK(DEM_ESM_STORED_STATUS_SIZE, DEM_ESM_STORED_STATUS_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)

#define DEM_ESM_SUPPRESSED_EVENT                 DEM_BIT(DEM_ESM_SUPPRESSED_EVENT_POS)
#define DEM_ESM_SUPPRESSED_EVENT_MASK            DEM_BIT_MASK(DEM_ESM_SUPPRESSED_EVENT_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)

#define DEM_ESM_SUPPRESSED_DTC                   DEM_BIT(DEM_ESM_SUPPRESSED_DTC_POS)
#define DEM_ESM_SUPPRESSED_DTC_MASK              DEM_BIT_MASK(DEM_ESM_SUPPRESSED_DTC_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)

#define DEM_ESM_USER_CONTROLLED_WIR              DEM_BIT(DEM_ESM_USER_CONTROLLED_WIR_POS)
#define DEM_ESM_USER_CONTROLLED_WIR_MASK         DEM_BIT_MASK(DEM_ESM_USER_CONTROLLED_WIR_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)

#define DEM_ESM_DISCONNECTED_EVENT               DEM_BIT(DEM_ESM_DISCONNECTED_EVENT_POS)
#define DEM_ESM_DISCONNECTED_EVENT_MASK          DEM_BIT_MASK(DEM_ESM_DISCONNECTED_EVENT_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)

#define DEM_ESM_FDC_TRIP                         DEM_BIT(DEM_ESM_FDC_TRIP_POS)
#define DEM_ESM_FDC_TRIP_MASK                    DEM_BIT_MASK(DEM_ESM_FDC_TRIP_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)

#define DEM_ESM_FDC_MAX                          DEM_BIT(DEM_ESM_FDC_MAX_POS)
#define DEM_ESM_FDC_MAX_MASK                     DEM_BIT_MASK(DEM_ESM_FDC_MAX_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)

#define DEM_ESM_FDC_TOC                          DEM_BIT(DEM_ESM_FDC_TOC_POS)
#define DEM_ESM_FDC_TOC_MASK                     DEM_BIT_MASK(DEM_ESM_FDC_TOC_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)

#define DEM_ESM_AVAILABLEINVARIANT               DEM_BIT(DEM_ESM_AVAILABLEINVARIANT_POS)
#define DEM_ESM_AVAILABLEINVARIANT_MASK          DEM_BIT_MASK(DEM_ESM_AVAILABLEINVARIANT_POS, DEM_ESM_INTERNAL_STATUS_BYTESIZE)

#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
typedef uint8 Dem_Verify_SizeOfInternalStatus[DEM_ESM_INTERNAL_STATUS_BYTESIZE == sizeof(Dem_Cfg_EventInternalStatusType)?1:-1];
#endif

#define DEM_ESM_DEBOUNCE_STATUS_NONE             ((0x00U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*< Debouncing inactive */
#define DEM_ESM_DEBOUNCE_RESET_FAILED            ((0x01U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*< Debouncing started, init counter towards failed threshold */
#define DEM_ESM_DEBOUNCE_RESET_PASSED            ((0x02U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*< Debouncing started, init counter towards passed threshold */
#define DEM_ESM_DEBOUNCE_COUNT_FAILED            ((0x03U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*< Debouncing in progress, counting towards failed threshold */
#define DEM_ESM_DEBOUNCE_COUNT_PASSED            ((0x04U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*< Debouncing in progress, counting towards passed threshold */
#define DEM_ESM_DEBOUNCE_FREEZE_FAILED           ((0x05U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*< Debouncing paused while counting towards failed threshold */
#define DEM_ESM_DEBOUNCE_FREEZE_PASSED           ((0x06U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*< Debouncing paused while counting towards passed threshold */
#define DEM_ESM_DEBOUNCE_COUNT_FAILED_FDC        ((0x07U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*< Debouncing in progress, counting towards failed threshold, fdc trip already processed */
#define DEM_ESM_DEBOUNCE_FREEZE_FAILED_FDC       ((0x09U) << DEM_ESM_DEBOUNCE_STATUS_POS) /*< Debouncing paused while counting towards failed threshold, fdc trip already processed */
#define DEM_ESM_DEBOUNCE_DONE_PASSED             ((0x0aU) << DEM_ESM_DEBOUNCE_STATUS_POS) /*< Debouncing completed, passed threshold reached */
#define DEM_ESM_DEBOUNCE_DONE_FAILED             ((0x0bU) << DEM_ESM_DEBOUNCE_STATUS_POS) /*< Debouncing completed, failed threshold reached */

#define DEM_ESM_DEBOUNCE_DIR_PASSED              ((0x00U) << DEM_ESM_DEBOUNCE_STATUS_POS)

#define DEM_ESM_STORED_STATUS_NONE               (0U << DEM_ESM_STORED_STATUS_POS)
#define DEM_ESM_STORED_STATUS_ACTIVE             (1U << DEM_ESM_STORED_STATUS_POS)
#define DEM_ESM_STORED_STATUS_AGING              (2U << DEM_ESM_STORED_STATUS_POS)
#define DEM_ESM_STORED_STATUS_AGED               (3U << DEM_ESM_STORED_STATUS_POS)

#define DEM_ESM_PRESTORED_STATUS_FREE            (0x00U)
#define DEM_ESM_PRESTORED_STATUS_READY           (0x01U)
#define DEM_ESM_PRESTORED_STATUS_UPDATING        (0x02U)
#define DEM_ESM_PRESTORED_STATUS_LOCKED          (0x03U)
#define DEM_ESM_PRESTORED_STATUS_DISCARDED       (0x04U)

#define DEM_ESM_CYCLECOUNT_MAX                   (0xeeeeU)
#define DEM_ESM_CYCLECOUNT_LATCHED               (0xeeffU)
#define DEM_ESM_CYCLECOUNT_EVENT_AGED            (0xffeeU)
#define DEM_ESM_CYCLECOUNT_INVALID               (0xffffU)

#if (DEM_CFG_STORAGE_AT_CONFIRMED == STD_ON)
# define DEM_ESM_EVENT_STORAGE_TRIGGER           DEM_CFG_TRIGGER_CONFIRMED
#elif (DEM_CFG_STORAGE_AT_FAILED == STD_ON)
# define DEM_ESM_EVENT_STORAGE_TRIGGER           (DEM_CFG_TRIGGER_TESTFAILED|DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE)
#elif (DEM_CFG_STORAGE_AT_FDC == STD_ON)
# define DEM_ESM_EVENT_STORAGE_TRIGGER           (DEM_CFG_TRIGGER_FDC|DEM_CFG_TRIGGER_TESTFAILED)
#else
# error "No event storage trigger defined"
#endif

#if ( (DEM_CFG_PROCESS_CDTC_STOREDONLY == STD_ON)   \
   || (DEM_CFG_PROCESS_PDTC_STOREDONLY == STD_ON)   \
   || (DEM_CFG_PROCESS_WIR_STOREDONLY == STD_ON)    \
   || (DEM_CFG_PROCESS_TFSLC_STOREDONLY == STD_ON) )
# define DEM_FEATURE_NEED_STOREDONLY_BITS        STD_ON
#else
# define DEM_FEATURE_NEED_STOREDONLY_BITS        STD_OFF
#endif

#if (DEM_CFG_PROCESS_PDTC_STOREDONLY == STD_ON)
# define DEM_ESM_STOREDONLY_PDTC                 DEM_UDS_STATUS_PDTC
# define DEM_ESM_EVENT_NO_TRIGGER_PENDING        DEM_CFG_TRIGGER_PENDING
#else
# define DEM_ESM_STOREDONLY_PDTC                 0x00U
# define DEM_ESM_EVENT_NO_TRIGGER_PENDING        0x00U
#endif
#if (DEM_CFG_PROCESS_CDTC_STOREDONLY == STD_ON)
# define DEM_ESM_STOREDONLY_CDTC                 DEM_UDS_STATUS_CDTC
# define DEM_ESM_EVENT_NO_TRIGGER_CONFIRMED      DEM_CFG_TRIGGER_CONFIRMED
#else
# define DEM_ESM_STOREDONLY_CDTC                 0x00U
# define DEM_ESM_EVENT_NO_TRIGGER_CONFIRMED      0x00U
#endif
#if (DEM_CFG_PROCESS_WIR_STOREDONLY == STD_ON)
# define DEM_ESM_STOREDONLY_WIR                  DEM_UDS_STATUS_WIR
# define DEM_ESM_EVENT_NO_TRIGGER_INDICATOR      DEM_CFG_TRIGGER_INDICATOR
#else
# define DEM_ESM_STOREDONLY_WIR                  0x00U
# define DEM_ESM_EVENT_NO_TRIGGER_INDICATOR      0x00U
#endif
#if (DEM_CFG_PROCESS_TFSLC_STOREDONLY == STD_ON)
# define DEM_ESM_STOREDONLY_TFSLC                DEM_UDS_STATUS_TFSLC
#else
# define DEM_ESM_STOREDONLY_TFSLC                0x00U
#endif

#define DEM_ESM_STOREDONLY_BITS                  (DEM_ESM_STOREDONLY_CDTC|DEM_ESM_STOREDONLY_PDTC|\
                                                 DEM_ESM_STOREDONLY_TFSLC|DEM_ESM_STOREDONLY_WIR)

#define DEM_ESM_EVENT_UPDATE_TRIGGER             DEM_CFG_TRIGGER_TESTFAILED

#define DEM_ESM_EVENT_RESET_TRIGGER_MASK         ((uint8)(0xffU ^ (DEM_ESM_EVENT_NO_TRIGGER_PENDING   \
                                                                 | DEM_ESM_EVENT_NO_TRIGGER_CONFIRMED \
                                                                 | DEM_ESM_EVENT_NO_TRIGGER_INDICATOR)))

#define DEM_ESM_MIL_GROUP_INVALID                (uint16)0

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_TESTFAILED_STORAGE == STD_ON)
# define DEM_NVM_TF_MASK                         (0x01U)
#else
# define DEM_NVM_TF_MASK                         (0x00U)
#endif

#if ( (DEM_FEATURE_NEED_TWOTRIP == STD_ON)      \
   || (DEM_FEATURE_NEED_MULTITRIP == STD_ON)    \
   || (DEM_CFG_SUPPORT_OPCYCLE_STORAGE == STD_ON) )
# define DEM_NVM_TFTOC_MASK                      (0x02U)
#else
# define DEM_NVM_TFTOC_MASK                      (0x00U)
#endif

#if ( (DEM_FEATURE_NEED_TWOTRIP == STD_ON)   \
   || (DEM_FEATURE_NEED_MULTITRIP == STD_ON) )
# define DEM_NVM_PDTC_MASK                       (0x04U)
#else
# define DEM_NVM_PDTC_MASK                       (0x00U)
#endif

#define DEM_NVM_CDTC_MASK                        (0x08U)
#define DEM_NVM_NTSLC_MASK                       (0x10U)
#define DEM_NVM_TFSLC_MASK                       (0x20U)

#if ( (DEM_FEATURE_NEED_TWOTRIP == STD_ON)      \
   || (DEM_FEATURE_NEED_MULTITRIP == STD_ON)    \
   || (DEM_CFG_SUPPORT_OPCYCLE_STORAGE == STD_ON) )
# define DEM_NVM_NTTOC_MASK                      (0x40U)
#else
# define DEM_NVM_NTTOC_MASK                      (0x00U)
#endif

#define DEM_NVM_WIR_MASK                         (0x80U)

#define DEM_NVM_STATUS_MASK                      (DEM_NVM_TF_MASK|DEM_NVM_TFTOC_MASK|DEM_NVM_PDTC_MASK|    \
                                                  DEM_NVM_CDTC_MASK|DEM_NVM_NTSLC_MASK|DEM_NVM_TFSLC_MASK| \
                                                  DEM_NVM_NTTOC_MASK|DEM_NVM_WIR_MASK)

#define DEM_NVM_COMMIT_IDLE                      (0x00U)
#define DEM_NVM_COMMIT_WRITING                   (0x01U)
#define DEM_NVM_COMMIT_FINISHED                  (0x02U)
#define DEM_NVM_COMMIT_FAILED                    (0x03U)

#define DEM_NVM_BLOCKSTATE_UNMODIFIED            (0x00U)
#define DEM_NVM_BLOCKSTATE_DIRTY                 (0x01U)
#define DEM_NVM_BLOCKSTATE_DIRTYIMMEDIATE        (0x03U)
#define DEM_NVM_BLOCKSTATE_DIRTYCLEAREDIMMEDIATE  (0x07U)

#define DEM_NVM_BLOCKSTATE_IMMEDIATEFLAG         (0x02U)
#define DEM_NVM_BLOCKSTATE_CLEARFLAG             (0x04U)

                                                              /* Dcm filters */
/* ------------------------------------------------------------------------- */
#define DEM_DCM_CLIENT_DCM                       (0x00U)
#define DEM_DCM_CLIENT_APPLICATION               (0x01U)

#define DEM_DCM_CLIENT_COUNT                     (2U)

#define DEM_DCM_FILTERDATA_IDLE                  (0xFFU)
#define DEM_DCM_FILTERDATA_PENDING               (DEM_DISABLE_DTCRECUP_PENDING)
#define DEM_DCM_FILTERDATA_READY                 (DEM_DISABLE_DTCRECUP_OK)

                                                              /* Service API */
/* ------------------------------------------------------------------------- */

#define DEM_EVENT_STATUS_INVALID                 ((Dem_EventStatusType)(0x04U))
#define DEM_DEBOUNCE_STATUS_INVALID              ((Dem_DebounceResetStatusType)(0x02U))
#define DEM_CYCLE_STATE_INVALID                  ((Dem_OperationCycleStateType)(0x02U))
#define DEM_DTC_FORMAT_INVALID                   ((Dem_DTCFormatType)(0x03U))
#define DEM_DTC_ORIGIN_INVALID                   ((Dem_DTCOriginType)(0x05U))
#define DEM_DTC_KIND_INVALID                     ((Dem_DTCKindType)(0x03U))
#define DEM_FILTER_FOR_FDC_INVALID               ((Dem_FilterForFDCType)(0x02U))
#define DEM_FILTER_WITH_SEVERITY_INVALID         ((Dem_FilterWithSeverityType)(0x02U))

                                                                /* Utilities */
/* ------------------------------------------------------------------------- */

/* ********************************************************************************************************************
 *  LOCAL FUNCTION MACROS
 *********************************************************************************************************************/

                                                               /* Assertions */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
# define Dem_Det_ReportError(ApiId, ErrorCode)   (void)Det_ReportError(DEM_MODULE_ID, 0, (ApiId), (ErrorCode));                  /* PRQA S 3412, 3453 */ /* MD_MSR_19.4, MD_MSR_19.7 */
#else
# define Dem_Det_ReportError(ApiId, ErrorCode)
#endif

#if (DEM_CFG_USE_DET == STD_ON)
# define Dem_Det_ErrorRegisterDefine()           uint8 lErrorId;                                                                 /* PRQA S 3412, 3453 */ /* MD_MSR_19.4, MD_MSR_19.7 */
# define Dem_Det_ErrorRegisterSet(value)         lErrorId = (value);                                                             /* PRQA S 3412, 3453 */ /* MD_MSR_19.4, MD_MSR_19.7 */
# define Dem_Det_ErrorRegisterGet()              lErrorId                                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dem_Det_ErrorRegisterDefine()                                                                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Det_ErrorRegisterSet(value)                                                                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Det_ErrorRegisterGet()                                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/* Internal Development Assertion Macros */
#define Dem_Internal_AssertAlways(ErrorCode)
#define Dem_Internal_AssertReturnVoid(Condition, ErrorCode)
#define Dem_Internal_AssertReturnValue(Condition, ErrorCode, ReturnValue)
#define Dem_Internal_AssertContinue(Condition, ErrorCode)

                                                        /* Critical Sections */
/* ------------------------------------------------------------------------- */

#define Dem_EnterCritical_DiagMonitor()          SchM_Enter_Dem_DEM_EXCLUSIVE_AREA_0()                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_LeaveCritical_DiagMonitor()          SchM_Exit_Dem_DEM_EXCLUSIVE_AREA_0()                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_EnterCritical_StateManager()         SchM_Enter_Dem_DEM_EXCLUSIVE_AREA_1()                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_LeaveCritical_StateManager()         SchM_Exit_Dem_DEM_EXCLUSIVE_AREA_1()                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_EnterCritical_DcmApi()               SchM_Enter_Dem_DEM_EXCLUSIVE_AREA_2()                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_LeaveCritical_DcmApi()               SchM_Exit_Dem_DEM_EXCLUSIVE_AREA_2()                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

                                                                /* Utilities */
/* ------------------------------------------------------------------------- */

#define Dem_LROT1_Byte(b)                        { (b) = (uint8)(((b) == 0x80U)?(0x01U):((b) << 1)); }                           /* PRQA S 3412, 3453, 3458 */ /* MD_MSR_19.4, MD_MSR_19.7, MD_MSR_19.7 */
#define Dem_LROT1_ADD_Byte(acc, b)               { if ((b) == 0x80U) { ++(acc); (b) = 0x01; } else { (b) = (uint8)((b) << 1); }} /* PRQA S 3412, 3453, 3458 */ /* MD_MSR_19.4, MD_MSR_19.7, MD_MSR_19.7 */
#define Dem_LROT1_ADD_ACTION_Byte(acc, act, b)   { if ((b) == 0x80U) { ++(acc); (act); (b) = 0x01; } else { (b) = (uint8)((b) << 1); }} /* PRQA S 3412, 3453, 3458 */ /* MD_MSR_19.4, MD_MSR_19.7, MD_MSR_19.7 */
#define Dem_WrappingIncrement(Value, Max)        { ++(Value); if ((Value) >= (Max)) { (Value) = 0U; } }                          /* PRQA S 3412, 3453, 3458 */ /* MD_MSR_19.4, MD_MSR_19.7, MD_MSR_19.7 */

/* decompose a 16 bit (value) into a byte stream */
#define Dem_GetHiByte(value)                     ((uint8)((uint16)(value)>>8))                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_GetLoByte(value)                     ((uint8)((value)))                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* decompose a 32 bit (value) into a byte stream */
#define Dem_GetHiHiByte(value)                   ((uint8)((uint32)(value)>>24))                                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_GetHiLoByte(value)                   ((uint8)((uint32)(value)>>16))                                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_GetLoHiByte(value)                   ((uint8)((uint32)(value)>>8))                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_GetLoLoByte(value)                   ((uint8)(value))                                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* compose a 16 bit (value) from a byte stream */
# define Dem_Make16Bit(hiByte,loByte)            ((uint16)((((uint16)(hiByte))<<8)| \
                                                 ((uint16)(loByte))))                                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* compose a 32 bit (value) from a byte stream */
#define Dem_Make32Bit(hiHiByte, hiLoByte, loHiByte, loLoByte)   ((uint32)(((uint32)(hiHiByte)<<24)| \
                                                                ((uint32)(hiLoByte)<<16)| \
                                                                ((uint32)(loHiByte)<<8) | \
                                                                ((uint32)(loLoByte))))                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DEM_CFG_USE_MEMCOPY_MACROS == STD_ON)
# if !defined(Dem_MemCpy_Macro)
#  define Dem_MemCpy_Macro(dst, src, len)        { uint16_least lMemCopyIndex; \
                                                   for ( lMemCopyIndex = 0x00u; lMemCopyIndex < (len); ++lMemCopyIndex) \
                                                   { (dst)[lMemCopyIndex] = (src)[lMemCopyIndex]; \
                                                 } }                                                                             /* PRQA S 3453, 3458 */ /* MD_MSR_19.7, MD_MSR_19.7 */
# endif

# if !defined(Dem_MemSet_Macro)
#  define Dem_MemSet_Macro(dst, val, len)        { uint16_least lMemCopyIndex; \
                                                   for ( lMemCopyIndex = 0x00u; lMemCopyIndex < (len); ++lMemCopyIndex) \
                                                   { (dst)[lMemCopyIndex] = (val); \
                                                 } }                                                                             /* PRQA S 3453, 3458 */ /* MD_MSR_19.7, MD_MSR_19.7 */
# endif

# define Dem_MemCpy(dst, src, len)               Dem_MemCpy_Macro((dst), (src), (len))                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_MemSet(dst, val, len)               Dem_MemSet_Macro((dst), (val), (len))                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dem_MemCpy(dst, src, len)               VStdMemCpy((Dem_DataPtrType)(dst), (Dem_DataPtrType)(src), (len))               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_MemSet(dst, val, len)               VStdMemSet((Dem_DataPtrType)(dst), (val), (len))                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

                                                                    /* Queue */
/* ------------------------------------------------------------------------- */

#define Dem_Queue_GetEventStatus(EventId)        (Dem_Cfg_EventQueueStatus[EventId])                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Queue_SetEventStatus(EventId, Status)  (Dem_Cfg_EventQueueStatus[EventId] = (Status))                                /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Queue_IsPendingCycle(CycleId)        ((Dem_Queue_CycleFlag & ((uint8)(1U << (CycleId)))) != 0)                       /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Queue_GetClearMemory()               (Dem_Queue_ClearRequest.ClearMemoryId)                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Queue_SetClearMemory(MemoryId)       (Dem_Queue_ClearRequest.ClearMemoryId = (MemoryId))                             /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Queue_GetClearFormat()               (Dem_Queue_ClearRequest.ClearFormat)                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Queue_SetClearFormat(Format)         (Dem_Queue_ClearRequest.ClearFormat = (Format))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Queue_GetClearGroup()                (Dem_Queue_ClearRequest.ClearGroup)                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Queue_SetClearGroup(Group)           (Dem_Queue_ClearRequest.ClearGroup = (Group))                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Queue_GetClearEvent()                (Dem_Queue_ClearRequest.ClearEventId)                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Queue_SetClearEvent(Event)           (Dem_Queue_ClearRequest.ClearEventId = (Event))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Queue_GetClearClient()               (Dem_Queue_ClearRequest.ClearClient)                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Queue_SetClearClient(Client)         (Dem_Queue_ClearRequest.ClearClient = (Client))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Queue_GetClearState()                (Dem_Queue_ClearState)                                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Queue_SetClearState(State)           (Dem_Queue_ClearState = (State))                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define DEM_QUEUE_TESTCLEARSTATE_PENDING(State)  ((uint8)((State) & 0x01U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_QUEUE_SETCLEARSTATE_PENDING(State)   ((uint8)((State) | 0x01U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_QUEUE_RESETCLEARSTATE_PENDING(State) ((uint8)((State) & 0xfeU))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define DEM_QUEUE_TESTCLEARSTATE_DONE(State)     ((uint8)((State) & 0x02U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_QUEUE_SETCLEARSTATE_DONE(State)      ((uint8)((State) | 0x02U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_QUEUE_RESETCLEARSTATE_DONE(State)    ((uint8)((State) & 0xfdU))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define DEM_QUEUE_TESTCLEARSTATE_CANCEL(State)   ((uint8)((State) & 0x04U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_QUEUE_SETCLEARSTATE_CANCEL(State)    ((uint8)((State) | 0x04U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_QUEUE_RESETCLEARSTATE_CANCEL(State)  ((uint8)((State) & 0xfbU))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define DEM_QUEUE_TESTCLEARSTATE_FAILED(State)   ((uint8)((State) & 0x08U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_QUEUE_SETCLEARSTATE_FAILED(State)    ((uint8)((State) | 0x08U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_QUEUE_RESETCLEARSTATE_FAILED(State)  ((uint8)((State) & 0xf7U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define DEM_QUEUE_TESTCLEARSTATE_NVFAILED(State) ((uint8)((State) & 0x10U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_QUEUE_SETCLEARSTATE_NVFAILED(State)  ((uint8)((State) | 0x10U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_QUEUE_RESETCLEARSTATE_NVFAILED(State) ((uint8)((State) & 0xefU))                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Internal queuing status 'nothing - queued/pending - non-queued/pending' - */
#define DEM_QUEUE_GET_QUEUESTATE(Action)         ((Action) & 0xc0U)                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_QUEUE_SET_QUEUESTATE(Action, s)      ((uint8)(((uint8)((Action) & 0x3fU)) | ((uint8)((s) & 0xc0U))))                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define DEM_QUEUE_GET_QUEUEACTION(Action)        ((Action) & 0x1fU)                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_QUEUE_SET_QUEUEACTION(Action, s)     ((uint8)(((uint8)((Action) & 0xe0U)) | ((uint8)((s) & 0x1fU))))                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Internal queuing status 'fdc processing required ' ---------------------- */
#define DEM_QUEUE_TEST_FDCPROCESSING(Action)     ((uint8)((Action) & 0x20U))                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_QUEUE_SET_FDCPROCESSING(Action)      ((uint8)((Action) | 0x20U))                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_QUEUE_RESET_FDCPROCESSING(Action)    ((uint8)((Action) & 0xdfU))                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

#if ( (DEM_CFG_DEBOUNCETYPE_COUNTER  != 0) \
   || (DEM_CFG_DEBOUNCETYPE_TIMER    != 1) \
   || (DEM_CFG_DEBOUNCETYPE_EXTERNAL != 2) \
   || (DEM_CFG_DEBOUNCETYPE_INVALID  != 3) )
# error "Debouncing abstraction will not work anymore"
#endif

/* Status bit 'testFailed' ------------------------------------------------- */
#define DEM_ESM_TEST_UDS_STATUS_TF(Status)       (((Status) & DEM_UDS_STATUS_TF) != 0)                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_SET_UDS_STATUS_TF(Status)        ((uint8)((Status) | DEM_UDS_STATUS_TF))                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_RESET_UDS_STATUS_TF(Status)      ((uint8)((Status) & DEM_UDS_STATUS_TF_MASK))                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Status bit 'testFailedThisOperationCycle' ------------------------------- */
#define DEM_ESM_TEST_UDS_STATUS_TFTOC(Status)    (((Status) & DEM_UDS_STATUS_TFTOC) != 0)                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_SET_UDS_STATUS_TFTOC(Status)     ((uint8)((Status) | DEM_UDS_STATUS_TFTOC))                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_RESET_UDS_STATUS_TFTOC(Status)   ((uint8)((Status) & DEM_UDS_STATUS_TFTOC_MASK))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Status bit 'pendingDTC' ------------------------------------------------- */
#define DEM_ESM_TEST_UDS_STATUS_PDTC(Status)     (((Status) & DEM_UDS_STATUS_PDTC) != 0)                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_SET_UDS_STATUS_PDTC(Status)      ((uint8)((Status) | DEM_UDS_STATUS_PDTC))                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_RESET_UDS_STATUS_PDTC(Status)    ((uint8)((Status) & DEM_UDS_STATUS_PDTC_MASK))                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Status bit 'confirmedDTC' ----------------------------------------------- */
#define DEM_ESM_TEST_UDS_STATUS_CDTC(Status)     (((Status) & DEM_UDS_STATUS_CDTC) != 0)                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_SET_UDS_STATUS_CDTC(Status)      ((uint8)((Status) | DEM_UDS_STATUS_CDTC))                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_RESET_UDS_STATUS_CDTC(Status)    ((uint8)((Status) & DEM_UDS_STATUS_CDTC_MASK))                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Status bit 'testNotCompletedSinceLastClear' ----------------------------- */
#define DEM_ESM_TEST_UDS_STATUS_TNCSLC(Status)   (((Status) & DEM_UDS_STATUS_TNCSLC) != 0)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_SET_UDS_STATUS_TNCSLC(Status)    ((uint8)((Status) | DEM_UDS_STATUS_TNCSLC))                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_RESET_UDS_STATUS_TNCSLC(Status)  ((uint8)((Status) & DEM_UDS_STATUS_TNCSLC_MASK))                                /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Status bit 'testFailedSinceLastClear' ----------------------------------- */
#define DEM_ESM_TEST_UDS_STATUS_TFSLC(Status)    (((Status) & DEM_UDS_STATUS_TFSLC) != 0)                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_SET_UDS_STATUS_TFSLC(Status)     ((uint8)((Status) | DEM_UDS_STATUS_TFSLC))                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_RESET_UDS_STATUS_TFSLC(Status)   ((uint8)((Status) & DEM_UDS_STATUS_TFSLC_MASK))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Status bit 'testNotCompletedThisOperationCycle' ------------------------- */
#define DEM_ESM_TEST_UDS_STATUS_TNCTOC(Status)   (((Status) & DEM_UDS_STATUS_TNCTOC) != 0)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_SET_UDS_STATUS_TNCTOC(Status)    ((uint8)((Status) | DEM_UDS_STATUS_TNCTOC))                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_RESET_UDS_STATUS_TNCTOC(Status)  ((uint8)((Status) & DEM_UDS_STATUS_TNCTOC_MASK))                                /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Status bit 'warningIndicatorRequested' ---------------------------------- */
#define DEM_ESM_TEST_UDS_STATUS_WIR(Status)      (((Status) & DEM_UDS_STATUS_WIR) != 0)                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_SET_UDS_STATUS_WIR(Status)       ((uint8)((Status) | DEM_UDS_STATUS_WIR))                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_RESET_UDS_STATUS_WIR(Status)     ((uint8)((Status) & DEM_UDS_STATUS_WIR_MASK))                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Internal Event status 'current de-bounce direction and action' (time)     */
#if (DEM_CFG_SUPPORT_DEBOUNCE_TIME == STD_ON)
# define DEM_ESM_GET_DEBOUNCE_STATUS(Reg)        ((Dem_Cfg_EventInternalStatusType)((Reg) & DEM_ESM_DEBOUNCE_STATUS))            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_ESM_SET_DEBOUNCE_STATUS(Reg, State)  ((Dem_Cfg_EventInternalStatusType)(((Dem_Cfg_EventInternalStatusType)((Reg) & DEM_ESM_DEBOUNCE_STATUS_MASK)) \
                                                                                   | ((Dem_Cfg_EventInternalStatusType)((State) & DEM_ESM_DEBOUNCE_STATUS))))  /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define DEM_ESM_TEST_DEBOUNCE_DIR(Status)       ((DEM_ESM_GET_DEBOUNCE_STATUS(Status) & 0x01U) != 0)                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# if ( ((DEM_ESM_DEBOUNCE_COUNT_FAILED & 0x01) == 0) \
    || ((DEM_ESM_DEBOUNCE_COUNT_PASSED & 0x01) != 0) \
    || ((DEM_ESM_DEBOUNCE_COUNT_FAILED_FDC & 0x01) == 0) \
    || ((DEM_ESM_DEBOUNCE_FREEZE_FAILED & 0x01) == 0) \
    || ((DEM_ESM_DEBOUNCE_FREEZE_PASSED & 0x01) != 0) \
    || ((DEM_ESM_DEBOUNCE_FREEZE_FAILED_FDC & 0x01) == 0) \
    || ((DEM_ESM_DEBOUNCE_RESET_FAILED & 0x01) == 0) \
    || ((DEM_ESM_DEBOUNCE_RESET_PASSED & 0x01) != 0) \
    || ((DEM_ESM_DEBOUNCE_DONE_FAILED & 0x01) == 0)  \
    || ((DEM_ESM_DEBOUNCE_DONE_PASSED & 0x01) != 0) )
#  error "Inconsistent state definition for timebased debouncing"
# endif
#endif

/* Internal event status 'storage' ----------------------------------------- */
#define DEM_ESM_GET_STORED_STATUS(Reg)           ((Dem_Cfg_EventInternalStatusType)((Reg) & DEM_ESM_STORED_STATUS))              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_SET_STORED_STATUS(Reg, State)    ((Dem_Cfg_EventInternalStatusType)(((Reg) & DEM_ESM_STORED_STATUS_MASK) | ((State) & DEM_ESM_STORED_STATUS)))  /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Internal status bit 'event suppressed' ---------------------------------- */
#if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
# define DEM_ESM_TEST_EVENT_SUPPRESSED(Status)   (((Status) & DEM_ESM_SUPPRESSED_EVENT) != 0)                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_ESM_SET_EVENT_SUPPRESSED(Status)    ((Dem_Cfg_EventInternalStatusType)((Status) | DEM_ESM_SUPPRESSED_EVENT))        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_ESM_RESET_EVENT_SUPPRESSED(Status)  ((Dem_Cfg_EventInternalStatusType)((Status) & DEM_ESM_SUPPRESSED_EVENT_MASK))   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/* Internal status bit 'DTC suppressed' ------------------------------------ */
#if (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON)
# define DEM_ESM_TEST_DTC_SUPPRESSED(Status)     (((Status) & DEM_ESM_SUPPRESSED_DTC) != 0)                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_ESM_SET_DTC_SUPPRESSED(Status)      ((Dem_Cfg_EventInternalStatusType)((Status) | DEM_ESM_SUPPRESSED_DTC))          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_ESM_RESET_DTC_SUPPRESSED(Status)    ((Dem_Cfg_EventInternalStatusType)((Status) & DEM_ESM_SUPPRESSED_DTC_MASK))     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/* Internal status bit 'event available' ----------------------------------- */
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
# define DEM_ESM_TEST_EVENT_DISCONNECTED(Status)  (((Status) & DEM_ESM_DISCONNECTED_EVENT) != 0)                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_ESM_SET_EVENT_DISCONNECTED(Status)  ((Dem_Cfg_EventInternalStatusType)((Status) | DEM_ESM_DISCONNECTED_EVENT))      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_ESM_RESET_EVENT_DISCONNECTED(Status)  ((Dem_Cfg_EventInternalStatusType)((Status) & DEM_ESM_DISCONNECTED_EVENT_MASK))  /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/* Internal status bit 'event crossed FDC threshold in this cycle' --------- */
#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
# define DEM_ESM_TEST_FDC_TRIP(Status)           (((Status) & DEM_ESM_FDC_TRIP) != 0)                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_ESM_SET_FDC_TRIP(Status)            ((Dem_Cfg_EventInternalStatusType)((Status) | DEM_ESM_FDC_TRIP))                /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_ESM_RESET_FDC_TRIP(Status)          ((Dem_Cfg_EventInternalStatusType)((Status) & DEM_ESM_FDC_TRIP_MASK))           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/* Internal status bit 'event crossed FDC threshold in this cycle' --------- */
#if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
# define DEM_ESM_TEST_FDC_MAX(Status)            (((Status) & DEM_ESM_FDC_MAX) != 0)                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_ESM_SET_FDC_MAX(Status)             ((Dem_Cfg_EventInternalStatusType)((Status) | DEM_ESM_FDC_MAX))                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_ESM_RESET_FDC_MAX(Status)           ((Dem_Cfg_EventInternalStatusType)((Status) & DEM_ESM_FDC_MAX_MASK))            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/* Internal status bit 'event crossed FDC threshold in this cycle' --------- */
#if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON)
# define DEM_ESM_TEST_FDC_TOC(Status)            (((Status) & DEM_ESM_FDC_TOC) != 0)                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_ESM_SET_FDC_TOC(Status)             ((Dem_Cfg_EventInternalStatusType)((Status) | DEM_ESM_FDC_TOC))                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_ESM_RESET_FDC_TOC(Status)           ((Dem_Cfg_EventInternalStatusType)((Status) & DEM_ESM_FDC_TOC_MASK))            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/* Internal status bit 'DTC disabled by PB selectable' --------------------- */
#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON) && (DEM_CFG_SUPPORT_TYPE1_COMBINATION == STD_ON)
# define DEM_ESM_TEST_AVAILABLEINVARIANT(Status)   (((Status) & DEM_ESM_AVAILABLEINVARIANT) != 0)                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_ESM_SET_AVAILABLEINVARIANT(Status)    ((Dem_Cfg_EventInternalStatusType)((Status) | DEM_ESM_AVAILABLEINVARIANT))    /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_ESM_RESET_AVAILABLEINVARIANT(Status)  ((Dem_Cfg_EventInternalStatusType)((Status) & DEM_ESM_AVAILABLEINVARIANT_MASK))  /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/* Internal status bit 'user controlled warning indicator' ----------------- */
#if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON)
# define DEM_ESM_TEST_USER_CONTROLLED_WIR(Status)   (((Status) & DEM_ESM_USER_CONTROLLED_WIR) != 0)                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_ESM_SET_USER_CONTROLLED_WIR(Status)    ((Dem_Cfg_EventInternalStatusType)((Status) | DEM_ESM_USER_CONTROLLED_WIR))  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_ESM_RESET_USER_CONTROLLED_WIR(Status)  ((Dem_Cfg_EventInternalStatusType)((Status) & DEM_ESM_USER_CONTROLLED_WIR_MASK))  /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/* Bitfield for enable condition states ------------------------------------ */
#define DEM_ESM_SET_ENABLECONDITION(Reg, Idx)    ((Reg) | (uint32)(((uint32)1u) << (Idx)))                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_RESET_ENABLECONDITION(Reg, Idx)  ((Reg) & ((uint32)(~((uint32)(((uint32)1u) << (Idx))))))                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_TEST_ENABLECONDITION(Reg, Idx)   ((Reg) & ((uint32)(((uint32)1u) << (Idx))))                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Selector expression to distinguish between combined and non-combined setups */
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
# define Dem_Esm_SelectStorageEffects(EventContext) (EventContext)->DtcEffects                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#else
# define Dem_Esm_SelectStorageEffects(EventContext) (EventContext)->EventEffects                                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

/* Entry->State currently used bits: 0x89 */
#define DEM_MEM_GET_QUALIFIED_MASK(Reg)          ((uint8)((Reg) | 0x77U)) /* Returns a mask, hence the | operator */             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_MEM_SET_QUALIFIED_MASK(Reg, Mask)    ((uint8)(((Reg) & 0x77U) | ((Mask) & 0x88U)))                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define DEM_MEM_TEST_AGING_ONLY(State)           ((uint8)((State) & 0x01U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_MEM_SET_AGING_ONLY(State)            ((uint8)((State) | 0x01U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_ESM_RESET_AGING_ONLY(State)          ((uint8)((State) & 0xfeU))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define DEM_MEM_INIT_COMMIT_NUMBER               (0x00U)
#define DEM_MEM_TEST_COMMIT_STARTED(State)       ((uint8)((State) & 0x80U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_MEM_SET_COMMIT_STARTED(State)        ((uint8)((State) |= 0x80U))                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_MEM_SET_COMMIT_FINISHED(State)       ((uint8)(((State) + 1) & 0x7fU))                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Mem_GetCycleCounter(CycleId)         (Dem_Cfg_AdminData.CycleCounter[CycleId])                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_SetCycleCounter(CycleId, Value)  (Dem_Cfg_AdminData.CycleCounter[CycleId] = (Value))                             /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
# define Dem_Mem_GetMemoryOverflow()             (Dem_Cfg_AdminData.MemoryOverflow)                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_SetMemoryOverflow(Value)        (Dem_Cfg_AdminData.MemoryOverflow = (Value))                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#define Dem_Mem_EventGetStatus(EventId)          (Dem_Cfg_StatusData.EventStatus[EventId])                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_EventSetStatus(EventId, Status)  (Dem_Cfg_StatusData.EventStatus[EventId] = (Status))                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DEM_FEATURE_NEED_TRIPCOUNTER == STD_ON)
# define Dem_Mem_EventGetTripCount(EvtId)        (Dem_Cfg_StatusData.TripCount[EvtId])                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_EventSetTripCount(EvtId, Count) (Dem_Cfg_StatusData.TripCount[EvtId] = (Count))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#define Dem_Mem_EventGetInternalStatus(EventId)  (Dem_Cfg_EventInternalStatus[EventId])                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_EventSetInternalStatus(EventId, Status)  (Dem_Cfg_EventInternalStatus[EventId] = (Status))                       /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
# define Dem_Mem_CombinedGroupGetStatus(GroupId)  (Dem_Cfg_CombinedGroupStatus[GroupId])                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_CombinedGroupSetStatus(GroupId, Status)  (Dem_Cfg_CombinedGroupStatus[GroupId] = (Status))                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dem_Mem_CombinedGroupGetInternalStatus(GroupId)  (Dem_Cfg_CombinedGroupInternalStatus[GroupId])                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_CombinedGroupSetInternalStatus(GroupId, Status)  (Dem_Cfg_CombinedGroupInternalStatus[GroupId] = (Status))      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#define Dem_Mem_EventGetDebounceValue(EventId)   (Dem_Cfg_EventDebounceValue[EventId])                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_EventSetDebounceValue(EventId, Value)  (Dem_Cfg_EventDebounceValue[EventId] = (Value))                           /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Mem_EventGetDebounceValueMax(EventId)  (Dem_Cfg_EventMaxDebounceValues[EventId])                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_EventSetDebounceValueMax(EventId, Value)  (Dem_Cfg_EventMaxDebounceValues[EventId] = (Value))                    /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
# define Dem_Mem_GetNvDebounceValue(Index)       (Dem_Cfg_DebounceData[Index])                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_SetNvDebounceValue(Index, Value)  (Dem_Cfg_DebounceData[Index] = (Value))                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) && (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
# define Dem_Mem_EventGetAvailableMask(Index)    (Dem_Cfg_EventAvailableData[Index])                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_EventSetAvailableMask(Index, Mask)  (Dem_Cfg_EventAvailableData[Index] = (Mask))                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/* Prestorage */
#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
# define Dem_Mem_PrestoredEntryGetEventId(Entry)  ((Entry)->EventId)                                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_PrestoredEntrySetEventId(Entry, Id)  (Entry)->EventId = (Id)                                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dem_Mem_PrestoredEntryGetNext(Entry)    ((Dem_Cfg_PrestorageIndexType)((Entry)->EventId))                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_PrestoredEntrySetNext(Entry, Idx)  (Entry)->EventId = (Dem_EventIdType)(Idx)                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dem_Mem_PrestoredEntryGetState(Entry)   ((Entry)->State)                                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_PrestoredEntrySetState(Entry, Status)  (Entry)->State = (Status)                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dem_Mem_PrestorageGetEntry(Index)       (&Dem_Cfg_Prestorage[Index])                                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dem_Mem_PrestorageGetRef(Event)         (Dem_Cfg_PrestorageIndex[Dem_Cfg_EventPrestorageIndex(Event)])                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_PrestorageSetRef(Event, Index)  (Dem_Cfg_PrestorageIndex[Dem_Cfg_EventPrestorageIndex(Event)] = (Index))        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/* Event Memory */
#define Dem_Mem_PrimaryGetChronology(Index)      (Dem_Cfg_PrimaryChronology[Index])                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_PrimarySetChronology(Index, Id)  (Dem_Cfg_PrimaryChronology[Index] = (Id))                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
# define Dem_Mem_SecondaryGetChronology(Index)   (Dem_Cfg_SecondaryChronology[Index])                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_SecondarySetChronology(Index, Id)  (Dem_Cfg_SecondaryChronology[Index] = (Id))                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif /* (DEM_CFG_SUPPORT_SECONDARY == STD_ON) */

#define Dem_Mem_EntryGetEventId(Entry)           ((Entry)->EventId)                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_EntrySetEventId(Entry, Id)       (Entry)->EventId = (Id)                                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Mem_EntryGetTimestamp(Entry)         ((Entry)->Timestamp)                                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_EntrySetTimestamp(Entry, Time)   (Entry)->Timestamp = (Time)                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Mem_EntryGetDebounceValueMax(Entry)  ((Entry)->MaxDebounceValue)                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_EntrySetDebounceValueMax(Entry, Cnt)  (Entry)->MaxDebounceValue = (Cnt)                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Mem_EntryGetState(Entry)             ((Entry)->State)                                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_EntrySetState(Entry, Status)     (Entry)->State = (Status)                                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Macros are optional to ease identifying coding errors */
#define Dem_Mem_EntryGetAgingCount(Entry)        ((Entry)->AgingCounter)                                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_EntrySetAgingCount(Entry, Cnt)   (Entry)->AgingCounter = (Cnt)                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* Macros are optional to ease identifying coding errors */
#if (DEM_FEATURE_NEED_OCC_COUNTER == STD_ON)
# define Dem_Mem_EntryGetOccurrenceCount(Entry)  ((Entry)->OccurrenceCounter)                                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_EntrySetOccurrenceCount(Entry, Cnt)  (Entry)->OccurrenceCounter = (Cnt)                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

/* Macros are optional to ease identifying coding errors */
#if (DEM_CFG_DATA_FAILED_CYCLES == STD_ON)
# define Dem_Mem_EntryGetFailedCycleCount(Entry)  ((Entry)->FailedCycleCounter)                                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_EntrySetFailedCycleCount(Entry, Cnt)  (Entry)->FailedCycleCounter = (Cnt)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#if (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
# define Dem_Mem_EntryGetConsecutiveFailedCycleCount(Entry)  ((Entry)->ConsecutiveFailedCycleCounter)                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_EntrySetConsecutiveFailedCycleCount(Entry, Cnt)  (Entry)->ConsecutiveFailedCycleCounter = (Cnt)                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#if (DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON)
# define Dem_Mem_EntryGetFirstFailedCycleCount(Entry)  ((Entry)->CyclesSinceFirstFailed)                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_EntrySetFirstFailedCycleCount(Entry, Cnt)  (Entry)->CyclesSinceFirstFailed = (Cnt)                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#if (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON)
# define Dem_Mem_EntryGetTestedSinceFirstFailedCycleCount(Entry)  ((Entry)->TestedCyclesSinceFirstFailed)                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_EntrySetTestedSinceFirstFailedCycleCount(Entry, Cnt)  (Entry)->TestedCyclesSinceFirstFailed = (Cnt)             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#if (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON)
# define Dem_Mem_EntryGetLastFailedCycleCount(Entry)  ((Entry)->CyclesSinceLastFailed)                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_EntrySetLastFailedCycleCount(Entry, Cnt)  (Entry)->CyclesSinceLastFailed = (Cnt)                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#define Dem_Mem_GetFirstFailedEvent()            (Dem_Cfg_StatusData.FirstFailedEvent)                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_SetFirstFailedEvent(EventId)     (Dem_Cfg_StatusData.FirstFailedEvent = (EventId))                               /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Mem_GetFirstConfirmedEvent()         (Dem_Cfg_StatusData.FirstConfirmedEvent)                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_SetFirstConfirmedEvent(EventId)  (Dem_Cfg_StatusData.FirstConfirmedEvent = (EventId))                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Mem_GetMostRecentFailedEvent()       (Dem_Cfg_StatusData.MostRecentFailedEvent)                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_SetMostRecentFailedEvent(EventId)  (Dem_Cfg_StatusData.MostRecentFailedEvent = (EventId))                        /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Mem_GetMostRecentConfmdEvent()       (Dem_Cfg_StatusData.MostRecentConfmdEvent)                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_SetMostRecentConfmdEvent(EventId)  (Dem_Cfg_StatusData.MostRecentConfmdEvent = (EventId))                        /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Mem_MemoryUpdateInit(Index)          (Dem_Cfg_MemoryCommitNumber[Index] = DEM_MEM_INIT_COMMIT_NUMBER)                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_MemoryUpdateStart(Index)         (Dem_Cfg_MemoryCommitNumber[Index] = DEM_MEM_SET_COMMIT_STARTED(Dem_Cfg_MemoryCommitNumber[Index])) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_MemoryUpdateFinish(Index)        (Dem_Cfg_MemoryCommitNumber[Index] = DEM_MEM_SET_COMMIT_FINISHED(Dem_Cfg_MemoryCommitNumber[Index])) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_MemoryUpdateGetState(Index)      (Dem_Cfg_MemoryCommitNumber[Index])                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_UpdateTestInProgress(State)      ((uint8)((State) & 0x80U))                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Mem_MemoryIndexAll_Begin()           (Dem_Cfg_MemoryPrimaryIndex())                                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_MemoryIndexAll_End()             (Dem_Mem_MemoryIndexAll_Begin() + Dem_Cfg_GlobalPrimarySize() + Dem_Cfg_GlobalSecondarySize()) /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_MemoryGetEntry(Index)            ((Dem_Mem_EntryPtrType)Dem_Cfg_MemoryDataPtr[Index])                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Mem_IsMemoryEntryIndex(Index)        (((Index) >= Dem_Mem_MemoryIndexAll_Begin()) && ((Index) < Dem_Mem_MemoryIndexAll_End())) /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
# define Dem_Mem_AdminSetBlockState(State)          Dem_Nvm_SetBlockStateImmediate(Dem_Cfg_MemoryAdminIndex(), State)            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_StatusSetBlockState(State)         Dem_Nvm_PendingStatusBlockState = (State)                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
# if (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
#  define Dem_Mem_EventAvailableSetBlockState(State)  Dem_Nvm_PendingEventAvailabilityBlockState = (State)                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
# define Dem_Mem_MemorySetBlockState(Index, State)  Dem_Nvm_SetBlockStateImmediate(Index, State)                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
# if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
#  define Dem_Mem_DebounceSetBlockState(State)      Dem_Nvm_SetBlockStateImmediate(Dem_Cfg_MemoryDebounceIndex(), State)         /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
#else
# define Dem_Mem_AdminSetBlockState(State)          Dem_Nvm_SetBlockState(Dem_Cfg_MemoryAdminIndex(), State)                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_StatusSetBlockState(State)         Dem_Nvm_SetBlockState(Dem_Cfg_MemoryStatusIndex(), State)                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
# if (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
#  define Dem_Mem_EventAvailableSetBlockState(State)  Dem_Nvm_SetBlockState(Dem_Cfg_MemoryEventAvailableIndex(), State)          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
# define Dem_Mem_MemorySetBlockState(Index, State)  Dem_Nvm_SetBlockState(Index, State)                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
#  define Dem_Mem_DebounceSetBlockState(State)      Dem_Nvm_SetBlockState(Dem_Cfg_MemoryDebounceIndex(), State)                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
#endif

#if (DEM_CFG_ISCONST_DESTINATION == STD_ON)
# define DEM_MEM_MEMORYINFO_PARAM
# define DEM_MEM_MEMORYINFO_PARAM_VARDEF
# define DEM_MEM_MEMORYINFO_PARAM_INIT(MemoryId)                                                                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define DEM_MEM_MEMORYINFO_PRIMARY_INIT
# define DEM_MEM_MEMORYINFO_PARAMDEF_ONLY        void                                                                            /* PRQA S 3460 */ /* MD_DEM_19.4 */
# define DEM_MEM_MEMORYINFO_PARAMDEF_FIRST
# define DEM_MEM_MEMORYINFO_PARAM_ONLY
# define DEM_MEM_MEMORYINFO_PARAM_FIRST

# if (DEM_CFG_CONST_DESTINATION == DEM_CFG_MEMORYID_PRIMARY)
#  define Dem_Mem_MemoryId()                     DEM_CFG_MEMORYID_PRIMARY                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dem_Mem_MemoryAllocateIndex(EventId)   (Dem_Mem_MemoryAllocateIndex_Internal(EventId))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dem_Mem_MemoryAllocateAging(EventId)   (Dem_Mem_MemoryAllocateAging_Internal(EventId))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dem_Mem_MemoryFindIndex(EventId)       (Dem_Mem_MemoryFindIndex_Internal(EventId))                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dem_Mem_MemoryFreeIndex(Index)         (Dem_Mem_MemoryFreeIndex_Internal(Index))                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dem_Mem_MemoryUpdateIndex(Index)       (Dem_Mem_MemoryUpdateIndex_Internal(Index))                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dem_Mem_MemoryGetChronology(Index)     (Dem_Mem_PrimaryGetChronology(Index))                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dem_Mem_MemorySetChronology(Index, Val) (Dem_Mem_PrimarySetChronology(Index, Val))                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dem_Mem_MemoryIndex_Begin()            (Dem_Cfg_MemoryPrimaryIndex())                                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dem_Mem_MemoryIndex_End()              (Dem_Mem_MemoryIndex_Begin() + Dem_Mem_MemoryGetMaxSize())                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dem_Mem_MemoryGetMaxSize()             (Dem_Cfg_GlobalPrimarySize())                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dem_Mem_MemoryGetCurrentSize()         (Dem_Mem_PrimaryCurrentCount)                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dem_Mem_MemorySetCurrentSize(Val)      (Dem_Mem_PrimaryCurrentCount = (Val))                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dem_Mem_MemoryGetFirstEvent()          (Dem_Cfg_GlobalPrimaryFirst())                                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dem_Mem_MemoryGetLastEvent()           (Dem_Cfg_GlobalPrimaryLast())                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
# if (DEM_CFG_CONST_DESTINATION == DEM_CFG_MEMORYID_SECONDARY)
#  error "Configuration is not supported, please set up at least one event in primary memory"
# endif
#else /* (DEM_CFG_ISCONST_DESTINATION == STD_OFF) */
# define DEM_MEM_MEMORYINFO_PARAM                MemoryInfo
# define DEM_MEM_MEMORYINFO_PARAM_VARDEF         P2CONST(Dem_Mem_MemoryInfoType, AUTOMATIC, DEM_CONST) DEM_MEM_MEMORYINFO_PARAM; /* PRQA S 3412,3453 */ /* MD_MSR_19.4, MD_MSR_19.7 */
# define DEM_MEM_MEMORYINFO_PARAM_INIT(MemId)    if ((MemId) == DEM_CFG_MEMORYID_PRIMARY)               \
                                                 { DEM_MEM_MEMORYINFO_PARAM = &Dem_Mem_PrimaryInfo; }   \
                                                 else                                                   \
                                                 { DEM_MEM_MEMORYINFO_PARAM = &Dem_Mem_SecondaryInfo; }                          /* PRQA S 3412,3453 */ /* MD_MSR_19.4, MD_MSR_19.7 */
# define DEM_MEM_MEMORYINFO_PRIMARY_INIT         DEM_MEM_MEMORYINFO_PARAM = &Dem_Mem_PrimaryInfo;                                /* PRQA S 3412 */ /* MD_MSR_19.4 */
# define DEM_MEM_MEMORYINFO_PARAMDEF_ONLY        CONSTP2CONST(Dem_Mem_MemoryInfoType, AUTOMATIC, DEM_CONST) DEM_MEM_MEMORYINFO_PARAM
# define DEM_MEM_MEMORYINFO_PARAMDEF_FIRST       DEM_MEM_MEMORYINFO_PARAMDEF_ONLY,
# define DEM_MEM_MEMORYINFO_PARAM_ONLY           DEM_MEM_MEMORYINFO_PARAM
# define DEM_MEM_MEMORYINFO_PARAM_FIRST          DEM_MEM_MEMORYINFO_PARAM_ONLY,

# define Dem_Mem_MemoryId()                      (DEM_MEM_MEMORYINFO_PARAM->MemoryId)                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_MemoryAllocateIndex(EventId)    (Dem_Mem_MemoryAllocateIndex_Internal(DEM_MEM_MEMORYINFO_PARAM, EventId))       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_MemoryAllocateAging(EventId)    (Dem_Mem_MemoryAllocateAging_Internal(DEM_MEM_MEMORYINFO_PARAM, EventId))       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_MemoryFindIndex(EventId)        (Dem_Mem_MemoryFindIndex_Internal(DEM_MEM_MEMORYINFO_PARAM, EventId))           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_MemoryFreeIndex(Index)          (Dem_Mem_MemoryFreeIndex_Internal(DEM_MEM_MEMORYINFO_PARAM, Index))             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_MemoryUpdateIndex(Index)        (Dem_Mem_MemoryUpdateIndex_Internal(DEM_MEM_MEMORYINFO_PARAM, Index))           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_MemoryGetChronology(Index)      ((DEM_MEM_MEMORYINFO_PARAM->ChronoPtr)[Index])                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_MemorySetChronology(Index, Val) ((DEM_MEM_MEMORYINFO_PARAM->ChronoPtr)[Index] = (Val))                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_MemoryIndex_Begin()             (DEM_MEM_MEMORYINFO_PARAM->FirstMemoryIndex)                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_MemoryIndex_End()               ((Dem_Cfg_MemoryIndexType)(Dem_Mem_MemoryIndex_Begin() + Dem_Mem_MemoryGetMaxSize()))  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_MemoryGetMaxSize()              (DEM_MEM_MEMORYINFO_PARAM->MaxSize)                                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_MemoryGetCurrentSize()          (*(DEM_MEM_MEMORYINFO_PARAM->SizePtr))                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_MemorySetCurrentSize(Val)       (*(DEM_MEM_MEMORYINFO_PARAM->SizePtr) = (Val))                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_MemoryGetFirstEvent()           (DEM_MEM_MEMORYINFO_PARAM->FirstEvent)                                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Mem_MemoryGetLastEvent()            (DEM_MEM_MEMORYINFO_PARAM->LastEvent)                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_USE_NVM == STD_ON)
# define Dem_Nvm_GetBlockId(Index)               ((NvM_BlockIdType)Dem_Cfg_MemoryBlockId[Index])                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dem_Nvm_GetBlockState(Index)            (Dem_Cfg_MemoryStatus[Index])                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Nvm_SetBlockState(Index, State)     (Dem_Cfg_MemoryStatus[Index] = (State))                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dem_Nvm_AdminGetBlockState()            (Dem_Nvm_GetBlockState(Dem_Cfg_MemoryAdminIndex()))                             /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Nvm_AdminSetBlockState(State)       (Dem_Nvm_SetBlockState(Dem_Cfg_MemoryAdminIndex(), State))                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dem_Nvm_StatusGetBlockState()           (Dem_Nvm_GetBlockState(Dem_Cfg_MemoryStatusIndex()))                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Nvm_StatusSetBlockState(State)      (Dem_Nvm_SetBlockState(Dem_Cfg_MemoryStatusIndex(), State))                     /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dem_Nvm_EventAvailableGetBlockState()   (Dem_Nvm_GetBlockState(Dem_Cfg_MemoryEventAvailableIndex()))                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Nvm_EventAvailableSetBlockState(State)  (Dem_Nvm_SetBlockState(Dem_Cfg_MemoryEventAvailableIndex(), State))         /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dem_Nvm_PrimaryGetBlockState(Index)     (Dem_Nvm_GetBlockState(Index))                                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Nvm_PrimarySetBlockState(Index, State)  (Dem_Nvm_SetBlockState(Index, State))                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define Dem_Nvm_SecondaryGetBlockState(Index)   (Dem_Nvm_GetBlockState(Index))                                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Nvm_SecondarySetBlockState(Index, State)  (Dem_Nvm_SetBlockState(Index, State))                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */

# if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
#  define Dem_Nvm_DebounceGetBlockState()        (Dem_Nvm_GetBlockState(Dem_Cfg_MemoryDebounceIndex()))                          /* PRQA S 3453 */ /* MD_MSR_19.7 */
#  define Dem_Nvm_DebounceSetBlockState(State)   (Dem_Nvm_SetBlockState(Dem_Cfg_MemoryDebounceIndex(), State))                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif

# define Dem_Nvm_GetPendingClear()               (0 != Dem_Nvm_CommitData.PendingClearCount)                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define DEM_NVM_CHECK_DIRTY_STATUS(oldStatus, newStatus) \
                                                 if (0 != (((oldStatus) ^ (newStatus)) & DEM_NVM_STATUS_MASK)) \
                                                 { Dem_Mem_StatusSetBlockState(DEM_NVM_BLOCKSTATE_DIRTY); }                      /* PRQA S 3412,3453 */ /* MD_MSR_19.4, MD_MSR_19.7 */
#else /* DEM_CFG_USE_NVM == STD_OFF) */
# define Dem_Nvm_AdminSetBlockState(state)                                                                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Nvm_StatusSetBlockState(state)                                                                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Nvm_MemorySetBlockState(Index, state)                                                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Nvm_EventAvailableSetBlockState(state)                                                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
# if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
#  define Dem_Nvm_DebounceSetBlockState(state)                                                                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */
# endif
# define Dem_Nvm_SetBlockState(Index, state)                                                                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Nvm_SetBlockStateImmediate(Index, state)                                                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Nvm_GetPendingClear()                                                                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define DEM_NVM_CHECK_DIRTY_STATUS(oldStatus, newStatus)                                                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

                                                            /* DCM Interface */
/* ------------------------------------------------------------------------- */

#define Dem_Dcm_MemoryIdFromOrigin(Origin)       (Dem_Dcm_MemoryIdMapping[Origin])                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
# define Dem_Dcm_FilterGetReportedEvents(Index)  (Dem_Cfg_FilterReportedEvents[Index])                                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Dcm_FilterSetReportedEvents(Index, Value) (Dem_Cfg_FilterReportedEvents[Index] = (Value))                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#define Dem_Dcm_FilterGetCriteria()              (Dem_Dcm_FilterInfo.FilterFlags)                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Dcm_FilterSetCriteria(Criteria)      (Dem_Dcm_FilterInfo.FilterFlags = (Criteria))                                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Dcm_FilterDtcGetStatusMask()         (Dem_Dcm_FilterInfo.Filter.Dtc.StatusMask)                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Dcm_FilterDtcSetStatusMask(Mask)     (Dem_Dcm_FilterInfo.Filter.Dtc.StatusMask = (Mask))                             /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Dcm_FilterDtcGetMemoryId()           (Dem_Dcm_FilterInfo.Filter.Dtc.MemoryId)                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Dcm_FilterDtcSetMemoryId(Id)         (Dem_Dcm_FilterInfo.Filter.Dtc.MemoryId = (Id))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

#if (DEM_CFG_SUPPORT_SEVERITY == STD_ON)
# define Dem_Dcm_FilterDtcGetSeverityMask()      (Dem_Dcm_FilterInfo.Filter.Dtc.SeverityMask)                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
# define Dem_Dcm_FilterDtcSetSeverityMask(Mask)  (Dem_Dcm_FilterInfo.Filter.Dtc.SeverityMask = (Dem_DTCSeverityType)(Mask))      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#endif

#define Dem_Dcm_FilterDtcGetEventIndex()         (Dem_Dcm_FilterInfo.Filter.Dtc.EventIndex)                                      /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Dcm_FilterDtcSetEventIndex(Index)    (Dem_Dcm_FilterInfo.Filter.Dtc.EventIndex = (Index))                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Dcm_FilterDtcGetFunctionPtr()        (Dem_Dcm_FilterInfo.pFilterDtcFunction)                                         /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Dcm_FilterDtcSetFunctionPtr(FuncPtr) (Dem_Dcm_FilterInfo.pFilterDtcFunction = (FuncPtr))                             /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Dcm_FilterDtcGetFdc()                (Dem_Dcm_FilterInfo.Filter.Dtc.FaultDetectionCounter)                           /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Dcm_FilterDtcSetFdc(Fdc)             (Dem_Dcm_FilterInfo.Filter.Dtc.FaultDetectionCounter = (Fdc))                   /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Dcm_FilterRecordGetMemIndex()        (Dem_Dcm_FilterInfo.Filter.Record.PrimaryIndex)                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Dcm_FilterRecordSetMemIndex(Index)   (Dem_Dcm_FilterInfo.Filter.Record.PrimaryIndex = (Index))                       /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Dcm_FilterRecordGetSRecIndex()       (Dem_Dcm_FilterInfo.Filter.Record.SnapshotIndex)                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Dcm_FilterRecordSetSRecIndex(Index)  (Dem_Dcm_FilterInfo.Filter.Record.SnapshotIndex = (Index))                      /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Dcm_FilterRecordGetIterator()        (&Dem_Dcm_FilterInfo.Filter.Record.Iterator)                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Dcm_FilterDataGetState()             (Dem_Dcm_FilterInfo.FilterDataState)                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Dcm_FilterDataSetState(State)        (Dem_Dcm_FilterInfo.FilterDataState = (State))                                  /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Dcm_FilterTestCancelled()            (Dem_Dcm_FilterInfo.FilterCancelled)                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Dcm_FilterSetCancelled()             (Dem_Dcm_FilterInfo.FilterCancelled = TRUE)                                     /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Dcm_FilterResetCancelled()           (Dem_Dcm_FilterInfo.FilterCancelled = FALSE)                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Dcm_FilterDataGetEventId()           (Dem_Dcm_FilterInfo.Filter.Data.EventId)                                        /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Dcm_FilterDataSetEventId(Id)         (Dem_Dcm_FilterInfo.Filter.Data.EventId = (Id))                                 /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define Dem_Dcm_FilterDataGetMemoryId()          (Dem_Dcm_FilterInfo.Filter.Data.MemoryId)                                       /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define Dem_Dcm_FilterDataSetMemoryId(Id)        (Dem_Dcm_FilterInfo.Filter.Data.MemoryId = (Id))                                /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* DTC Filter Criteria ------------ */
#define DEM_DCM_TEST_FILTER_USESTATUSMASK(Criteria)     ((uint8)((Criteria) & 0x01U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_DCM_SET_FILTER_USESTATUSMASK(Criteria)      ((uint8)((Criteria) | 0x01U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_DCM_RESET_FILTER_USESTATUSMASK(Criteria)    ((uint8)((Criteria) & 0xfeU))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define DEM_DCM_TEST_FILTER_USEFDC(Criteria)            ((uint8)((Criteria) & 0x02U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_DCM_SET_FILTER_USEFDC(Criteria)             ((uint8)((Criteria) | 0x02U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_DCM_RESET_FILTER_USEFDC(Criteria)           ((uint8)((Criteria) & 0xfdU))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define DEM_DCM_TEST_FILTER_USESEVERITY(Criteria)       ((uint8)((Criteria) & 0x04U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_DCM_SET_FILTER_USESEVERITY(Criteria)        ((uint8)((Criteria) | 0x04U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_DCM_RESET_FILTER_USESEVERITY(Criteria)      ((uint8)((Criteria) & 0xfbU))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define DEM_DCM_TEST_FILTER_DTCFORMAT_OBD(Criteria)     ((uint8)((Criteria) & 0x08U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_DCM_SET_FILTER_DTCFORMAT_OBD(Criteria)      ((uint8)((Criteria) | 0x08U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_DCM_RESET_FILTER_DTCFORMAT_OBD(Criteria)    ((uint8)((Criteria) & 0xf7U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define DEM_DCM_TEST_FILTER_DTCKIND_EMISSION(Criteria)  ((uint8)((Criteria) & 0x10U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_DCM_SET_FILTER_DTCKIND_EMISSION(Criteria)   ((uint8)((Criteria) | 0x10U))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_DCM_RESET_FILTER_DTCKIND_EMISSION(Criteria) ((uint8)((Criteria) & 0xefU))                                            /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* DTC Filter Event Reported Marker ------------ */
#define DEM_DCM_FILTER_CALC_MARKER_SIZE(NumEvents)      (uint16)(((NumEvents)+7)/8)                                              /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_DCM_FILTER_CALC_MARKER_INDEX(EventId)       (uint16)((EventId)/8)                                                    /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_DCM_FILTER_CALC_MARKER_MASK(EventId)        (uint8)(0x01u << ((uint8)((EventId) % 8)))                               /* PRQA S 3453 */ /* MD_MSR_19.7 */

#define DEM_DCM_GET_FILTER_EVENT_MARKER(Value, Mask)    (uint8)((Value) & (Mask))                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_DCM_SET_FILTER_EVENT_MARKER(Value, Mask)    (uint8)((Value) | (Mask))                                                /* PRQA S 3453 */ /* MD_MSR_19.7 */
#define DEM_DCM_RESET_FILTER_EVENT_MARKER(Value, Mask)  (uint8)((Value) & ~(Mask))                                               /* PRQA S 3453 */ /* MD_MSR_19.7 */

# define DEM_J1939_NODE_ID            0x00U

                                                                /* Utilities */
/* ------------------------------------------------------------------------- */
# define Dem_Util_GlobalSpecialIndicatorState(indicatorId)   Dem_Cfg_GlobalSpecialIndicatorStates[indicatorId][0]                /* PRQA S 3453 */ /* MD_MSR_19.7 */

/* ********************************************************************************************************************
 *  LOCAL DATA TYPES AND STRUCTURES
 *********************************************************************************************************************/

                                                                /* Utilities */
/* ------------------------------------------------------------------------- */

struct Dem_Util_ForEachCombinedArgType_s
{
  struct
  {
    uint8 OldDtcStatus;
    uint8 NewDtcStatus;
  } Common;
  union
  {                                                                                                                              /* PRQA S 0750 */ /* MD_DEM_18.4 */
    struct
    {
      uint8 unused;
    } EventClearState;
    struct
    {
      uint8 unused;
    } EventDisplaced_Internal;
    struct
    {
      uint8 CycleStatus;
    } EventOpCycle_Internal;
    struct
    {
      uint8 unused;
    } EventAgingCycle_Internal;
  } Specific;
};

typedef struct Dem_Util_ForEachCombinedArgType_s Dem_Util_ForEachCombinedArgType;

typedef P2VAR(Dem_Util_ForEachCombinedArgType, TYPEDEF, DEM_VAR_NOINIT) Dem_Util_ForEachCombinedArgPtrType;

typedef P2FUNC(void, DEM_CODE, Dem_Util_ForEachCombinedFuncType)(
  Dem_EventIdType EventId,
  Dem_Util_ForEachCombinedArgPtrType ArgPtr
  );

                                                                    /* Queue */
/* ------------------------------------------------------------------------- */

struct Dem_Queue_ClearRequestType_s
{
  Dem_EventIdType ClearEventId;
  uint8  ClearMemoryId;
  uint8  ClearFormat;
  uint8  ClearGroup;
  uint8  ClearClient;
};

typedef struct Dem_Queue_ClearRequestType_s Dem_Queue_ClearRequestType;

                                                            /* DCM Interface */
/* ------------------------------------------------------------------------- */

typedef P2FUNC(Dem_EventIdType, DEM_CODE, Dem_Dcm_FilterFuncPtrType) (void);
typedef P2FUNC(Dem_ReturnClearDTCType, DEM_CODE, Dem_Dcm_ClearDtc_TestFuncPtrType)(
  uint32,
  P2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)
  );
typedef P2CONST(Dem_Dcm_ClearDtc_TestFuncPtrType, TYPEDEF, DEM_CONST) Dem_Dcm_ClearDtc_TestPtrType;

struct Dem_Dcm_CacheType_s
{
  uint32                     Dtc;
  Dem_EventIdType            EventId;
  uint8                      MemoryId;
};

typedef struct Dem_Dcm_CacheType_s Dem_Dcm_CacheType;

struct Dem_Dcm_FilterDtcInfoType_s
{
  Dem_EventIdType            EventIndex;
  uint8                      StatusMask;
  sint8                      FaultDetectionCounter;
  uint8                      MemoryId;
#if (DEM_CFG_SUPPORT_SEVERITY == STD_ON)
  Dem_DTCSeverityType        SeverityMask;
#endif
};

struct Dem_Dcm_FilterRecordInfoType_s
{
  uint8                      PrimaryIndex;
  uint8                      SnapshotIndex;
  Dem_Cfg_EventSRecIterType  Iterator;
};

struct Dem_Dcm_FilterDataInfoType_s
{
  Dem_EventIdType            EventId;
  uint8                      MemoryId;
};

struct Dem_Dcm_FilterInfoType_s
{
  union
  {                                                                                                                              /* PRQA S 0750 */ /* MD_DEM_18.4 */
    struct Dem_Dcm_FilterDtcInfoType_s    Dtc;
    struct Dem_Dcm_FilterRecordInfoType_s Record;
    struct Dem_Dcm_FilterDataInfoType_s   Data;
  }                          Filter;
  uint8                      FilterFlags;
  uint8                      FilterDataState;
  boolean                    FilterCancelled;
  Dem_Dcm_FilterFuncPtrType  pFilterDtcFunction;
};

typedef struct Dem_Dcm_FilterInfoType_s Dem_Dcm_FilterInfoType;

                                                        /* Data Provisioning */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_OCC_COUNTER == STD_ON)
# if (DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON)
typedef uint16 Dem_Data_OccurrenceCounterType;
# else
typedef uint8 Dem_Data_OccurrenceCounterType;
# endif
#endif

struct Dem_Data_CollectDidInfoType_s
{
  Dem_SharedDataPtrType  DestinationBuffer;
  Dem_EventIdType    EventId;
};

typedef struct Dem_Data_CollectDidInfoType_s Dem_Data_CollectDidInfoType;
typedef P2VAR(Dem_Data_CollectDidInfoType, TYPEDEF, AUTOMATIC) Dem_Data_CollectDidInfoPtrType;

struct Dem_Data_CopyDidInfoType_s
{
  Dem_ConstSharedDataPtrType        SourceBuffer;
  Dem_SharedDataPtrType             DestinationBuffer;
  Dem_ConstSharedMemoryEntryPtrType Entry;
  Dem_EventIdType                   EventId;
};

typedef struct Dem_Data_CopyDidInfoType_s Dem_Data_CopyDidInfoType;
typedef P2VAR(Dem_Data_CopyDidInfoType, TYPEDEF, AUTOMATIC) Dem_Data_CopyDidInfoPtrType;

                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_ISCONST_DESTINATION != STD_ON)
typedef struct Dem_Mem_MemoryInfoType_s Dem_Mem_MemoryInfoType;
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
typedef P2VAR(Dem_Cfg_PrestorageEntryType, TYPEDEF, DEM_VAR_NOINIT)  Dem_Mem_PrestoredEntryPtrType;
#endif

typedef P2VAR(Dem_Cfg_PrimaryEntryType, TYPEDEF, DEM_NVM_DATA)       Dem_Mem_EntryPtrType;
#if (DEM_CFG_SUPPORT_SRECS == STD_ON) || (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
typedef P2CONST(Dem_Cfg_PrimaryEntryType, TYPEDEF, DEM_NVM_DATA)     Dem_Mem_ConstEntryPtrType;
#endif
typedef CONSTP2VAR(uint8, TYPEDEF, DEM_VAR_NOINIT)                   Dem_Mem_ChronoStackPtrType;
typedef volatile CONSTP2VAR(uint8, TYPEDEF, DEM_VAR_NOINIT)          Dem_Mem_BlockCommitIdPtrType;
typedef CONSTP2VAR(uint8, TYPEDEF, DEM_VAR_NOINIT)                   Dem_Mem_CurrentSizePtrType;

struct Dem_Mem_MemoryInfoType_s
{
  Dem_Mem_ChronoStackPtrType    ChronoPtr;
  Dem_Mem_CurrentSizePtrType    SizePtr;
  Dem_Cfg_MemoryIndexType       FirstMemoryIndex;
  Dem_EventIdType               FirstEvent;
  Dem_EventIdType               LastEvent;
  uint8                         MaxSize;
  uint8                         MemoryId;
};

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

typedef struct Dem_DebounceInfoType_s Dem_DebounceInfoType;

typedef P2FUNC(void, DEM_CODE, DebounceVoidFunctionPtr)(
  P2VAR(Dem_DebounceInfoType, AUTOMATIC, AUTOMATIC)
  );
typedef P2FUNC(boolean, DEM_CODE, DebounceBoolFunctionPtr)(
  P2VAR(Dem_DebounceInfoType, AUTOMATIC, AUTOMATIC)
  );

struct Dem_DebounceFunctionTable_s
{
  DebounceBoolFunctionPtr Calculate;
  DebounceBoolFunctionPtr Validate;
  DebounceVoidFunctionPtr Commit;
  DebounceVoidFunctionPtr Freeze;
  DebounceVoidFunctionPtr Reset;
};

typedef struct Dem_DebounceFunctionTable_s Dem_DebounceFunctionTableType;
typedef P2CONST(Dem_DebounceFunctionTableType, TYPEDEF, DEM_CONST) Dem_DebounceFunctionTablePtrType;

struct Dem_DebounceInfoType_s
{
  struct
  {
    Dem_DebounceFunctionTablePtrType FunctionTable;
    Dem_EventIdType EventId;
    Dem_EventStatusType MonitorStatus;
    boolean DebouncingChanged;
#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
    boolean RequestProcessing;
#endif
  } Common;
  union
  {                                                                                                                              /* PRQA S 0750 */ /* MD_DEM_18.4 */
    struct
    {
      sint16 OldDebounceValue;
      sint16 NewDebounceValue;
#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
      Dem_Cfg_EventInternalStatusType OldInternalStatus;
      Dem_Cfg_EventInternalStatusType NewInternalStatus;
#endif
    } CounterBased;
    struct
    {
      Dem_Cfg_EventInternalStatusType OldInternalStatus;
      Dem_Cfg_EventInternalStatusType NewInternalStatus;
    } TimeBased;
    struct
    {
      sint8  NewFdc;
    } MonitorInternal;
  } Specific;
};

struct Dem_Esm_EventContext_s
{
  Dem_EventIdType EventId;
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType GroupId;
  uint8 OldDtcStatus;
  uint8 NewDtcStatus;
  uint8 DtcEffects;
#endif
  uint8 OldEventStatus;
  uint8 NewEventStatus;
  uint8 EventEffects;
};

typedef P2VAR(Dem_DebounceInfoType, TYPEDEF, AUTOMATIC) Dem_DebounceInfoPtrType;
typedef P2CONST(Dem_DebounceInfoType, TYPEDEF, AUTOMATIC) Dem_ConstDebounceInfoPtrType;

typedef struct Dem_Esm_EventContext_s Dem_Esm_EventContextType;

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
struct Dem_Nvm_CommitDataType_s
{
  Dem_Cfg_MemoryIndexType MemoryIndex;
  uint8 PendingCount;
  uint8 WriteState;
# if (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON)
  uint8 PendingClearCount;
  boolean BlockIsCleared;
# endif
};
typedef struct Dem_Nvm_CommitDataType_s Dem_Nvm_CommitDataType;
#endif

/* ********************************************************************************************************************
 *  LOCAL DATA
 *********************************************************************************************************************/

                                                            /* Administrator */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_VAR_INIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

DEM_LOCAL VAR(uint8, DEM_VAR_INIT)               Dem_InitState = DEM_INIT_UNINITIALIZED;

#define DEM_STOP_SEC_VAR_INIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_32BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

DEM_LOCAL volatile VAR(uint32, DEM_VAR_NOINIT)   Dem_CurrentEnableConditionStates;
#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
DEM_LOCAL volatile VAR(uint32, DEM_VAR_NOINIT)   Dem_NextEnableConditionStates;
#endif

#if (DEM_CFG_SUPPORT_STORAGE_CONDITIONS == STD_ON)
DEM_LOCAL volatile VAR(uint32, DEM_VAR_NOINIT)   Dem_StorageConditionStates;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_32BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                                                    /* Timer */
/* ------------------------------------------------------------------------- */
#define DEM_START_SEC_VAR_NOINIT_16BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_STOP_SEC_VAR_NOINIT_16BIT                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */
                                                                   /* Queues */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_CFG_SUPPORT_EVENT_QUEUE == STD_ON)
DEM_LOCAL volatile VAR(uint8, DEM_VAR_NOINIT)    Dem_Queue_EventReadIndex;
DEM_LOCAL volatile VAR(uint8, DEM_VAR_NOINIT)    Dem_Queue_EventWriteIndex;
#endif

DEM_LOCAL volatile VAR(uint8, DEM_VAR_NOINIT)    Dem_Queue_ClearState;

#define DEM_STOP_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_16BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

DEM_LOCAL VAR(uint16, DEM_VAR_NOINIT)            Dem_Queue_CycleState;
DEM_LOCAL volatile VAR(uint16, DEM_VAR_NOINIT)   Dem_Queue_CycleFlag;
DEM_LOCAL volatile VAR(uint16, DEM_VAR_NOINIT)   Dem_Queue_EventCount;
#if (DEM_CFG_SUPPORT_CLEAR_DTC_RUNTIME_LIMIT == STD_ON)
DEM_LOCAL VAR(uint16, DEM_VAR_NOINIT)            Dem_Queue_ClearEventIterator;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_16BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_32BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
DEM_LOCAL VAR(uint32, DEM_VAR_NOINIT)            Dem_Queue_EnableConditionStates;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_32BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

DEM_LOCAL volatile VAR(Dem_Queue_ClearRequestType, DEM_VAR_NOINIT)  Dem_Queue_ClearRequest;

#define DEM_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

DEM_LOCAL VAR(uint8, DEM_VAR_NOINIT)             Dem_Mem_PrimaryCurrentCount;
#if (DEM_FEATURE_NEED_SECONDARY == STD_ON)
DEM_LOCAL VAR(uint8, DEM_VAR_NOINIT)             Dem_Mem_SecondaryCurrentCount;
#endif
#define DEM_STOP_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_16BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

DEM_LOCAL VAR(uint16, DEM_VAR_NOINIT)            Dem_Mem_CurrentCycleState;
#define DEM_STOP_SEC_VAR_NOINIT_16BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_32BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

DEM_LOCAL VAR(uint32, DEM_VAR_NOINIT)            Dem_Mem_CurrentTimestamp;

#define DEM_STOP_SEC_VAR_NOINIT_32BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
DEM_LOCAL VAR(Dem_Cfg_PrestorageIndexType, DEM_VAR_NOINIT)  Dem_Mem_PrestorageHeadIndex;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_CFG_SUPPORT_DEBOUNCE_TIME_LR == STD_ON)
DEM_LOCAL VAR(uint8, DEM_VAR_NOINIT)             Dem_Esm_DebounceLoResTimer;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
DEM_LOCAL VAR(Dem_Cfg_PrestorageIndexType, DEM_VAR_NOINIT)  Dem_Esm_PrestorageLockedIndex;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
DEM_LOCAL VAR(uint8, DEM_VAR_NOINIT)             Dem_Nvm_PendingStatusBlockState;
#endif

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON) && (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
DEM_LOCAL VAR(uint8, DEM_VAR_NOINIT)             Dem_Nvm_PendingEventAvailabilityBlockState;
#endif

#if (DEM_CFG_SUPPORT_NVM_APPL_SYNCHRONIZE == STD_ON)
DEM_LOCAL VAR(uint8, DEM_VAR_NOINIT)             Dem_Nvm_SynchronizationRequest;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
DEM_LOCAL VAR(Dem_Nvm_CommitDataType, DEM_VAR_NOINIT)  Dem_Nvm_CommitData;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                                          /* ASR Service API */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_STOP_SEC_VAR_NOINIT_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
DEM_LOCAL VAR(Dem_Dcm_FilterInfoType, DEM_VAR_NOINIT)  Dem_Dcm_FilterInfo;
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) || (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
DEM_LOCAL volatile VAR(Dem_Dcm_CacheType, DEM_VAR_NOINIT)  Dem_Dcm_Cache[DEM_DCM_CLIENT_COUNT];                                  /* PRQA S 3218 */ /* MD_DEM_8.7 */
#endif

#define DEM_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/* ********************************************************************************************************************
 *  GLOBAL DATA
 *********************************************************************************************************************/

#define DEM_START_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_CFG_USE_INIT_POINTER == STD_ON)
P2CONST(Dem_ConfigType, DEM_VAR_NOINIT, DEM_PBCFG)  Dem_GlobalConfigPtr;
#endif

#define DEM_STOP_SEC_VAR_NOINIT_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/* ********************************************************************************************************************
 *  LOCAL INLINE FUNCTION DECLARATIONS
 *********************************************************************************************************************/

#define DEM_START_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */
                                                                /* Utilities */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_NOTIFY_CLEAR_ALLOWED == STD_ON)
/* ****************************************************************************
 * Dem_Util_CallClearEventAllowed
 *****************************************************************************/
/*!
 * \brief         Wrap call to user definied clear filter
 *
 * \details       This function calls a user defined clear allowed callback
 *                and handles the related error conditions.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *
 * \return        TRUE
 *                The event may be cleared
 * \return        FALSE
 *                The application does not allow clearing
 *
 * \pre           RTE is started
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Util_CallClearEventAllowed(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON)
/* ****************************************************************************
 * Dem_Util_DtcApplyUserControlledWIR
 *****************************************************************************/
/*!
 * \brief         Apply the user controlled WIR bit to the DTC's status
 *
 * \details       This function applies a user controlled WIR bit to the
 *                passed DTC status byte.
 *
 *                If at least one sub-event of a combined event has a user
 *                controlled WIR bit, the DTC will have the WIR bit set as
 *                well.
 *                The passed WIR status will never be reset by this function.
 *
 * \param[in]     DtcStatus
 *                Unmodified DTC status byte
 *
 * \param[in]     InternalStatus
 *                Internal event status information
 *
 * \return        The resulting DTC status
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Util_DtcApplyUserControlledWIR(
  uint8 DtcStatus,
  Dem_Cfg_EventInternalStatusType InternalStatus
  );
#endif

#if ( (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON) \
   || (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON) \
   || (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON) \
   || (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON) )
/* ****************************************************************************
 * Dem_Util_DtcApplyCombinedStatus
 *****************************************************************************/
/*!
 * \brief         Apply interdependent status bits on a combined status
 *
 * \details       This function corrects the status byte inconsistencies
 *                resulting from event combineation, according to the Autosar
 *                specification.
 *
 * \param[in]     DtcStatus
 *                Unmodified DTC status byte
 *
 * \return        The resulting DTC status
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Util_DtcApplyCombinedStatus(
  uint8  DtcStatus
  );
#endif

#if ( (DEM_CFG_SUPPORT_DCM == STD_ON) \
   || (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON) \
   || (DEM_FEATURE_NEED_NOTIFY_DATA == STD_ON) \
   )
/* ****************************************************************************
 * Dem_Util_DtcApplyExternalOnlyStatus
 *****************************************************************************/
/*!
 * \brief         Apply correction term for DTC status modification
 *
 * \details       This function applies a filter to the DTC status byte to set
 *                bits that are forced to true by different mechanisms than
 *                event status modification.
 *                Also, status bits are masked out if they are hidden.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 * \param[in]     DtcStatus
 *                Unmodified DTC status byte
 *
 * \return        The resulting DTC status
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Util_DtcApplyExternalOnlyStatus(
  Dem_EventIdType EventId,
  uint8 DtcStatus
  );
#endif

/* ****************************************************************************
 * Dem_Util_DtcGetInternalStatus
 *****************************************************************************/
/*!
 * \brief         Get the internal status byte independent of event combination
 *
 * \details       This function retrieves the event's internal status byte for
 *                normal events, and the group's internal status byte for
 *                combined events.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *
 * \return        The internal status byte relevant for the event or group.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Util_DtcGetInternalStatus(
  Dem_EventIdType EventId
  );

/* ****************************************************************************
 * Dem_Util_DtcSetInternalStatus
 *****************************************************************************/
/*!
 * \brief         Sets the internal status byte independent of event
 *                combination
 *
 * \details       This function stores the event's internal status byte for
 *                normal events, and the group's internal status byte for
 *                combined events.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 * \param[in]     InternalStatus
 *                New internal status to set
 *
 * \pre           Must be called within critical section DiagMonitor
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Util_DtcSetInternalStatus(
  Dem_EventIdType EventId,
  Dem_Cfg_EventInternalStatusType InternalStatus
  );

/* ****************************************************************************
 * Dem_Util_DtcGetStatus
 *****************************************************************************/
/*!
 * \brief         Gets the status byte independent of event combination
 *
 * \details       This function retrieves the event's status byte for normal
 *                events, and the group's status byte for combined events.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *
 * \return        The status byte relevant for the event or group
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Util_DtcGetStatus(
  Dem_EventIdType EventId
  );

#if ( (DEM_CFG_SUPPORT_DCM == STD_ON) \
  || (DEM_CFG_DATA_CURRENT_FDC == STD_ON) )
/* ****************************************************************************
 * Dem_Util_DtcGetFaultDetectionCounter
 *****************************************************************************/
/*!
 * \brief         Gets the FaultDetectionCounter (FDC) independent of event
 *                combination
 *
 * \details       This function retrieves the event's FDC for normal events,
 *                and the maximum FDC of the group's sub-events for combined
 *                events.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *
 * \return        The current FDC of the event or group.
 *
 * \pre           RTE must be started
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Util_DtcGetFaultDetectionCounter(
  Dem_EventIdType  EventId,
  P2VAR(sint8, AUTOMATIC, DEM_APPL_DATA)  FaultDetectionCounter
  );
#endif

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 * Dem_Util_CombinedGroupGetEvent
 *****************************************************************************/
/*!
 * \brief         Looks up the master event for a combined event
 *
 * \details       This function finds the master event based on any sub-event
 *                of an event combination group.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *
 * \return        The EventId representing the combined event group.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Util_CombinedGroupGetEvent(
  Dem_Cfg_CombinedGroupIndexType  GroupId
  );
#endif

#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
/* ****************************************************************************
 * Dem_Util_DtcAvailableInVariant
 *****************************************************************************/
/*!
 * \brief         Tests if a DTC is available based on the PB-S variant
 *
 * \details       For normal events, this function simply looks up the event
 *                configuration. A combined event is available only if at
 *                least one sub-event is available in the active variant.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *
 * \return        TRUE
 *                The event or group is available in the selected variant
 * \return        FALSE
 *                The event or group is not availabl in the selected variant
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Util_DtcAvailableInVariant(
  Dem_EventIdType EventId
  );
#endif

/* ****************************************************************************
 * Dem_Util_DtcGetMasterEvent
 *****************************************************************************/
/*!
 * \brief         Gets the master event of a DTC
 *
 * \details       Selects the representing event (master event) of an event
 *                combination group, or the event itself if it is not combined.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 *
 * \return        The EventId representing the event or group.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Util_DtcGetMasterEvent(
  Dem_EventIdType  EventId
  );

/* ****************************************************************************
 * Dem_Util_ForEachCombinedEvent
 *****************************************************************************/
/*!
 * \brief         Executes a combined operation.
 *
 * \details       Due to excessive code duplication it was necessary to fall
 *                back to higher order functions. This function takes a
 *                function pointer to an operation to be executed for all
 *                sub-events of a combined event.
 *                For normal events, the operation is executed for that event
 *                only, so the caller does not need to distinguish between
 *                combined and non-combined events too much.
 *
 *                The caller is still reponsible to call this function only
 *                once per combined event, e.g. by calling it only for the
 *                master event.
 *
 * \param[in]     EventId
 *                Unique handle of the Event.
 * \param[in]     FuncPtr
 *                Operation to perform on all subevents
 * \param[in]     ArgPtr
 *                Arguments passed to the operation.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Util_ForEachCombinedEvent(
  Dem_EventIdType  EventId,
  Dem_Util_ForEachCombinedFuncType FuncPtr,
  Dem_Util_ForEachCombinedArgPtrType ArgPtr
  );

                                                            /* Main Function */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_SUPPORT_SPLIT_TASKS != STD_ON)
/* ****************************************************************************
 * Dem_MainFunctionWorker
 *****************************************************************************/
/*!
 * \brief         Worker task of the Dem
 *
 * \details       This function performs the event processing. This is usually
 *                runtime intensive, but the function has no timing
 *                requirements - just call it often enough to process the
 *                events in time as required by the ECU
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_MAINFUNC_LINKAGE FUNC(void, DEM_CODE)
Dem_MainFunctionWorker(
  void
);

# if (DEM_FEATURE_NEED_ENGINE_RUN_TIME == STD_ON) || (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_MainFunctionTimer
 *****************************************************************************/
/*!
 * \brief         Timer task of the Dem
 *
 * \details       This function performs time processing. Since the Dem time
 *                base is established by this function, it needs to be called
 *                with the configured cycle time.
 *
 *                This function only processes the configured timers and defers
 *                all resulting work to the worker task.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_MAINFUNC_LINKAGE FUNC(void, DEM_CODE)
Dem_MainFunctionTimer(
  void
);
# endif
#endif

                                                      /* Queue Setter/Getter */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Queue_GetPendingCycle
 *****************************************************************************/
/*!
 * \brief         Looks up a pending cycle state change
 *
 * \param[in]     CycleId
 *                Unique handle of the Cycle.
 *
 * \details       This function looks up a pending cycle state change.
 *                The value returned is only meaningful if the modification
 *                flag is also set for this cycle (\see Dem_Queue_CycleFlag)
 *
 * \return        TRUE
 *                The cycle shall be in state started
 * \return        FALSE
 *                The cycle shall be in state stopped
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Queue_GetPendingCycle(
  uint8  CycleId
  );

/* ****************************************************************************
 * Dem_Queue_SetPendingCycle
 *****************************************************************************/
/*!
 * \brief         Stores a pending cycle state change
 *
 * \details       This function stores a pending cycle state change to be
 *                processed later on task context.
 *
 *                The queue can encode one STOP, one START or one STOP->START
 *                action. The modification flag (\see Dem_Queue_CycleFlag) is
 *                set always.
 *
 * \param[in]     CycleId
 *                Unique handle of the Cycle.
 * \param[in]     Status
 *                DEM_QUEUE_CYCLE_STARTED  To start a cycle
 *                DEM_QUEUE_CYCLE_STOPPED  To stop a cycle
 *
 * \pre           Must be called within critical section 'StateManager'
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_SetPendingCycle(
  uint8  CycleId,
  boolean  Status
  );

/* ****************************************************************************
 * Dem_Queue_SetPendingEvent_Enqueue
 *****************************************************************************/
/*!
 * \brief         Initializes an event queue entry
 *
 * \details       Up to Dem_Cfg_GlobalQueueSize() events are queued in order of
 *                first action. Other events still maintain their queued
 *                actions, but not in order of arrival.
 *
 * \return        Queue state of the event
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
  Dem_Queue_SetPendingEvent_Enqueue(
  Dem_EventIdType  EventId
  );

/* ****************************************************************************
 * Dem_Queue_SetPendingEvent_Queued
 *****************************************************************************/
/*!
 * \brief         Stores a pending event qualification to be processed later
 *
 * \details       The queue state can be stored for every event, and will be
 *                further processed on task level of the Dem. This function
 *                queues qualified actions without interpreting the current
 *                status byte. This means that a constant failed result will
 *                cause event processing (without effect), but the result can
 *                be queued even before initalization.
 *
 *                If the queing action limit is exceeded this function will
 *                return E_NOT_OK.

 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     MonitorStatus
 *                DEM_EVENT_STATUS_PASSED    To add a qualification to 'PASSED'
 *                DEM_EVENT_STATUS_FAILED    To add a qualification to 'FAILED'
 *                DEM_EVENT_STATUS_PREFAILED To not add qualification (FDC)
 *
 * \return        E_OK
 *                The event could be queued
 * \return        E_NOT_OK
 *                The event could not be queued.
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Queue_SetPendingEvent_Queued(
  Dem_EventIdType  EventId,
  uint8  MonitorStatus
  );

/* ****************************************************************************
 * Dem_Queue_SetPendingEvent_Immediate
 *****************************************************************************/
/*!
 * \brief         Stores a pending event qualification to be processed later
 *
 * \details       The queue state can be stored for every event, and will be
 *                further processed on task level of the Dem. This function
 *                queues qualified actions by interpreting the current status
 *                byte. This means that status changes are encoded in the queue
 *                state, so the current status can be changed withoud losing
 *                the triggers. On the other hand, the status byte is not
 *                available before initialization, so this function cannot
 *                queue events before initalization.
 *
 *                If the queing action limit is exceeded this function will
 *                return E_NOT_OK.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     MonitorResult
 *                DEM_EVENT_STATUS_PASSED    To add a qualification to 'PASSED'
 *                DEM_EVENT_STATUS_FAILED    To add a qualification to 'FAILED'
 *                DEM_EVENT_STATUS_PREFAILED To not add qualification (FDC)
 * \param[in]     EventStatus
 *                The current event status.
 *
 * \return        E_OK
 *                The event could be queued
 * \return        E_NOT_OK
 *                The event could not be queued.
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Queue_SetPendingEvent_Immediate(
  Dem_EventIdType  EventId,
  uint8  MonitorResult,
  uint8  EventStatus
  );

/* ****************************************************************************
 * Dem_Queue_ResetPendingEvent
 *****************************************************************************/
/*!
 * \brief         Clears queued event actions
 *
 * \details       Reset the queued action state of the event. The queue itself
 *                is not modified.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ResetPendingEvent(
  Dem_EventIdType  EventId
  );

                                                        /* Data Provisioning */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Data_EventFailed
 *****************************************************************************/
/*!
 * \brief         OnFailed hook to handle data updates
 *
 * \details       This function updates global failure statistics, like first
 *                failed event.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     Effects
 *                Trigger flags
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
  Dem_Data_EventFailed(
  Dem_EventIdType  EventId,
  uint8  Effects
);

                                                            /* Notifications */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
/* ****************************************************************************
 * Dem_Cbk_DtcStatusChanged
 *****************************************************************************/
/*!
 * \brief         Calls all configured DTC status notification functions
 *
 * \details       This function is a wrapper to \see
 *                Dem_Cbk_DtcStatusChanged_Internal. The Dtc status is modified
 *                before passing over, so the calls to \see
 *                Dem_Util_DtcApplyExternalOnlyStatus are not distributed
 *                across the code.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     EventStatusOld
 *                Old UDS status of the event
 * \param[in]     EventStatusNew
 *                New UDS status of the event
 *
 * \pre           RTE must be started
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Cbk_DtcStatusChanged(
  Dem_EventIdType              EventId,
  Dem_EventStatusExtendedType  EventStatusOld,
  Dem_EventStatusExtendedType  EventStatusNew
  );
#endif

#if (DEM_FEATURE_NEED_NOTIFY_DATA == STD_ON)
/* ****************************************************************************
 * Dem_Cbk_EventDataChanged
 *****************************************************************************/
/*!
 * \brief         Calls all configured event data notification functions
 *
 * \details       If configured, event specific and general data changed
 *                callbacks are invoked, unconditionally.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           RTE must be started
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Cbk_EventDataChanged(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_CFG_NOTIFY_INIT_MONITOR == STD_ON)
/* ****************************************************************************
 * Dem_Cbk_InitMonitorForEvent
 *****************************************************************************/
/*!
 * \brief         Calls all configured 'init monitor for event' callbacks.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     InitReason
 *                The reason why the the init callback is called
 *
 * \pre           RTE must be started
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Cbk_InitMonitorForEvent(
  Dem_EventIdType           EventId,
  Dem_InitMonitorReasonType InitReason
  );
#endif

#if (DEM_CFG_NOTIFY_INIT_FUNC == STD_ON)
/* ****************************************************************************
 * Dem_Cbk_InitMonitorForFunction
 *****************************************************************************/
/*!
 * \brief         Calls all configured 'init monitor for function' callbacks
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           RTE must be started
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Cbk_InitMonitorForFunction(
  Dem_EventIdType           EventId
  );
#endif

                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Mem_Init_RestoreMemory
 *****************************************************************************/
/*!
 * \brief         Initializes primary/secondary memory
 *
 * \details       This function verifies the integrity of memory entries and
 *                links them up into the runtime control structures.
 *
 * \param[in]     MemoryInfo (conditional)
 *                Event memory descriptor
 *
 * \pre           NvM must have restored NV mirrors
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_Init_RestoreMemory(
  DEM_MEM_MEMORYINFO_PARAMDEF_ONLY
  );

/* ****************************************************************************
 * Dem_Mem_GetCycleStatus
 *****************************************************************************/
/*!
 * \brief         Gets the current state of a cycle
 *
 * \param[in]     CycleId
 *                Unique Id of the cycle
 *
 * \return        DEM_QUEUE_CYCLE_STARTED
 *                The cycle is currently started
 * \return        DEM_QUEUE_CYCLE_STOPPED
 *                The cycle is currently stopped
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_GetCycleStatus(
  uint8  CycleId
  );

/* ****************************************************************************
 * Dem_Mem_SetCycleStatus
 *****************************************************************************/
/*!
 * \brief         Set current state of a cycle
 *
 * \param[in]     CycleId
 *                Unique Id of the cycle
 * \param[in]     Status
 *                The state of the cycle
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetCycleStatus(
  uint8  CycleId,
  uint8  Status
  );

#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
/* ****************************************************************************
 * Dem_Mem_GetOverflow
 *****************************************************************************/
/*!
 * \brief         Get overflow state for an event memory
 *
 * \param[in]     MemoryId
 *                Unique identifier of the event memory
 *
 * \return        TRUE
 *                The event memory has overflown
 * \return        FALSE
 *                The event memory has not overflown
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_GetOverflow(
  uint8  MemoryId
  );
#endif

#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
/* ****************************************************************************
 * Dem_Mem_SetOverflow
 *****************************************************************************/
/*!
 * \brief         Set the 'overflown' state for an event memory
 *
 * \param[in]     MemoryId
 *                Unique identifier of the event memory
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetOverflow(
  uint8  MemoryId
  );
#endif

#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
/* ****************************************************************************
 * Dem_Mem_ResetOverflow
 *****************************************************************************/
/*!
 * \brief         Clear the 'overflown' state for an event memory
 *
 * \param[in]     MemoryId
 *                Unique identifier of the event memory
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_ResetOverflow(
  uint8  MemoryId
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
/* ****************************************************************************
 * Dem_Mem_CopyDataDebounceNv
 *****************************************************************************/
/*!
 * \brief         Copies debounce values from debounce array to NVRAM mirror
 *
 * \details       This function copies all debounce counters and timer values
 *                that need to be stored in NV memory into the NV data buffer.
 *
 * \pre           Can only be called during Dem shutdown
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_CopyDataDebounceNv(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Mem_PrestorageInit
 *****************************************************************************/
/*!
 * \brief         Initializes the prestorage free list
 *
 * \pre           Can only be called during Dem initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_PrestorageInit(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Mem_PrestorageFindEntry
 *****************************************************************************/
/*!
 * \brief         Locate the prestored data entry of an event
 *
 * \details       This function looks up if a prestorage entry exists for the
 *                given event, and returns its handle if found.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \return        Index into Prestorage area, if one was found.
 *                DEM_MEM_INVALID_PRESTORAGE_INDEX otherwise.
 *
 * \pre           The event must support prestorage
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_PrestorageIndexType, DEM_CODE)
Dem_Mem_PrestorageFindEntry(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Mem_PrestorageAllocateEntry
 *****************************************************************************/
/*!
 * \brief         Allocate a new prestored entry for an event
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \details       This function consumes the next free prestorage entry (if
 *                available) and allocates it to the given event.
 *
 * \return        Index into Prestorage area, if one was found.
 *                DEM_MEM_INVALID_PRESTORAGE_INDEX otherwise.
 *
 * \pre           The event must support prestorage
 * \pre           The event must not have a prestored entry
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_Cfg_PrestorageIndexType, DEM_CODE)
Dem_Mem_PrestorageAllocateEntry(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Mem_PrestorageFreeEntry
 *****************************************************************************/
/*!
 * \brief         Free a prestored entry
 *
 * \details       This function removes the ownership of the prestored entry
 *                and returns it to the free list.
 *
 * \param[in]     PrestorageIndex
 *                Prestored entry to free
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_PrestorageFreeEntry(
  Dem_Cfg_PrestorageIndexType  PrestorageIndex
  );
#endif

/* ****************************************************************************
 * Dem_Mem_MemoryUpdateIndex_Internal
 *****************************************************************************/
/*!
 * \brief         Update one entry in primary memory
 *
 * \details       Moves the passed entry up to most current in the chronology
 *                list.
 *                Do not call this function directly, use
 *                Dem_Mem_MemoryUpdateIndex
 *
 * \param[in]     MemoryInfo (conditional)
 *                Event memory descriptor
 * \param[in]     MemoryIndex
 *                Memory entry index
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_MemoryUpdateIndex_Internal(
  DEM_MEM_MEMORYINFO_PARAMDEF_FIRST
  uint8  MemoryIndex
  );

/* ****************************************************************************
 * Dem_Mem_PreInit
 *****************************************************************************/
/*!
 * \brief         Pre-initializes backing memory
 *
 * \details       This function performs basic initialization to allow later
 *                full initialization.
 *
 * \pre           May only be called during pre-initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_PreInit(
  void
  );

/* ****************************************************************************
 * Dem_Mem_Init
 *****************************************************************************/
/*!
 * \brief         Initializes backing memory
 *
 * \details       This function controls initilaization of the memory
 *                subcomponent. After the function completes, event memories
 *                are available.
 *
 * \pre           May only be called during initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_Init(
  void
  );

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Esm_AddCycleCount
 *****************************************************************************/
/*!
 * \brief         Calculates wrapped cycle counter
 *
 * \details       This function increments and wraps a cycle count avoiding
 *                overflow and 'magic numbers'.
 *
 * \param[in]     CurrentCounter
 *                Current value of the cycle counter
 * \param[in]     DeltaValue
 *                Value by which CurrentCounter is incremented.
 *
 * \return        Value of (CurrentCounter + DeltaValue) mod X
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Esm_AddCycleCount(
  uint16  CurrentCounter,
  uint8  DeltaValue
  );

/* ****************************************************************************
 * Dem_Esm_DebounceInfoInit
 *****************************************************************************/
/*!
 * \brief         Initializes a debounce descriptor
 *
 * \details       This function initializes the basic common fields of a
 *                debounce descriptor. State information remains uninitialized
 *                as it is not known without context.
 *                The common fields that will be set here are 'EventId' and
 *                'FunctionTable'
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_DebounceInfoInit(
  Dem_EventIdType EventId,
  P2VAR(Dem_DebounceInfoType, AUTOMATIC, AUTOMATIC) DebounceInfo
  );

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Esm_PrestorageDiscard
 *****************************************************************************/
/*!
 * \brief         Marks a prestored entry as used
 *
 * \details       Prestored data (if available) is valid throughout the whole
 *                event processing step. This function marks the current data
 *                to be discarded after event processing completes.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PrestorageDiscard(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventPrestorageLock
 *****************************************************************************/
/*!
 * \brief         Locks a ready prestored entry to use its data
 *
 * \details       This function prepares the prestored data of the given event
 *                (if available) for consumption during the event processing
 *                step.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \return        E_OK
 *                A prestored entry was locked
 * \return        E_NOT_OK
 *                No prestored entry was found
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventPrestorageLock(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventPrestorageRelease
 *****************************************************************************/
/*!
 * \brief         Unlock the previously locked prestored entry
 *
 * \details       This function releases the prestored data locked by
 *                Dem_Esm_EventPrestorageLock, if such data exists.
 *
 *                If the data was consumed during the event processing step, it
 *                is discarded.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventPrestorageRelease(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventPrestorageUpdate
 *****************************************************************************/
/*!
 * \brief         Store prestored data for an event
 *
 * \details       This function tries to find a prestorage entry for the given
 *                event, allocating a new one if needed.
 *                If a prestorage entry is found, it is updated with sample
 *                data.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \return        E_OK
 *                Prestored data was successfully collected
 * \return        E_NOT_OK
 *                No data was collected
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventPrestorageUpdate(
  Dem_EventIdType  EventId
  );
#endif

/* ****************************************************************************
 * Dem_Esm_EventCreateMemory
 *****************************************************************************/
/*!
 * \brief         Allocate an event memory entry
 *
 * \details       This function tries to allocate en event memory entry for
 *                for the given event. This can displace existing memory
 *                entries if the memory is already full.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \return        MemoryIndex of the allocated memory entry. If no entry was
 *                allocated, DEM_MEM_INVALID_MEMORY_INDEX is returned.
 *
 * \pre           The event may not be stored already
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Esm_EventCreateMemory(
  Dem_EventIdType  EventId
  );

/* ****************************************************************************
 * Dem_Esm_EventUpdateMemory
 *****************************************************************************/
/*!
 * \brief         Mark an event entry as updated
 *
 * \details       This function updates an event memory after failure.
 *                An aged entry is reinitialized, and an active entry updates
 *                the time stamp when an occurrence was reported.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     Occurrence
 *                TRUE if the TF bit has transitioned FALSE->TRUE
 *
 * \return        MemoryIndex of the allocated memory entry.
 *
 * \pre           The event must be stored
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Esm_EventUpdateMemory(
  Dem_EventIdType  EventId,
  boolean  Occurrence
  );

#if (DEM_FEATURE_NEED_USER_INDICATORS == STD_ON)
/* ****************************************************************************
 * Dem_Esm_UserIndicatorEnable
 *****************************************************************************/
/*!
 * \brief         Updates user-defined indicator counters
 *
 * \details       Adds the event's contribution to the indicator states.
 *                Basically this adds 1 from each indicators continuous or
 *                blinking count, if the indicator is enabled bythe given
 *                event.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           Must be called inside of critical section 'DiagMonitor'
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_UserIndicatorEnable(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_FEATURE_NEED_USER_INDICATORS == STD_ON)
/* ****************************************************************************
 * Dem_Esm_UserIndicatorDisable
 *****************************************************************************/
/*!
 * \brief         Update user-defined indicator counters
 *
 * \details       Removes the event's contribution to the indicator states.
 *                Basically this subtracts 1 from each indicators continuous or
 *                blinking count, if the indicator is enabled by the given
 *                event
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           Must be called inside of critical section 'DiagMonitor'
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_UserIndicatorDisable(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_FEATURE_NEED_TESTSUPPRESSION == STD_ON)
/* ****************************************************************************
 * Dem_Esm_TestDtcSuppressed
 *****************************************************************************/
/*!
 * \brief         Tests an event's DTC suppression flag
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \return        TRUE
 *                The event's DTC is currently suppressed
 * \return        FALSE
 *                The event's DTC is currently not suppressed
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_TestDtcSuppressed(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_FEATURE_NEED_LATCHTESTFAILED == STD_ON)
/* ****************************************************************************
 * Dem_Esm_TestLatchedTestFailed
 *****************************************************************************/
/*!
 * \brief         Tests whether an event's latched failed restriction applies
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \return        TRUE
 *                The event is latched at TestFailed
 * \return        FALSE
 *                The event is not latched, process it normally
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_TestLatchedTestFailed(
  Dem_EventIdType EventId
  );
#endif

#if (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
/* ****************************************************************************
 * Dem_Esm_TestEventHealed
 *****************************************************************************/
/*!
 * \brief         Tests whether an event is healed
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     EventStatus
 *                Current event status of the event
 *
 * \return        TRUE
 *                The event is healed
 * \return        FALSE
 *                The event is not healed
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_TestEventHealed(
  Dem_EventIdType EventId,
  uint8 EventStatus
);
#endif

#if (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON) \
   && ((DEM_FEATURE_NEED_HEALING == STD_ON) \
     && ((DEM_CFG_AGING_START_TESTS_TFTOC == STD_OFF) || (DEM_CFG_AGING_AT_PASSED_00_TARGET_ONLY == STD_ON)) \
     || (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON))
/* ****************************************************************************
 % Dem_Esm_TestDtcHealed
 *****************************************************************************/
/*!
 * \brief         Tests whether an event or combined event is healed
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \return        TRUE
 *                The event is healed
 * \return        FALSE
 *                The event is not healed
 *
 * \pre           -
 *
 * \config        (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
  Dem_Esm_TestDtcHealed(
  Dem_EventIdType EventId
);
#endif

/* ****************************************************************************
 * Dem_Esm_EventResetDebounceState
 *****************************************************************************/
/*!
 * \brief         Reset an event's debouncing state
 *
 * \details       This function is used to reset or freeze the debouncing
 *                process for events that ar debounced by the Dem.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     Status
 *                Kind of reset
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventResetDebounceState(
  Dem_EventIdType  EventId,
  Dem_DebounceResetStatusType  Status
  );

#if (DEM_FEATURE_NEED_DEBOUNCE == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventResetDebounceValues
 *****************************************************************************/
/*!
 * \brief         Reset an event's debouncing counters/timers
 *
 * \details       This function sets the debouncing values (for events that are
 *                debounced by the Dem) back to initial values. This means the
 *                event's FDC would be 0 after this function completes.
 *
 *                If any 'max FDC' statistics are calculated, these are reset
 *                as well.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventResetDebounceValues(
  Dem_EventIdType EventId
  );
#endif

#if (DEM_FEATURE_NEED_EVENTAVAILABLE_DEFAULT == STD_ON) || (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventSetDisconnectedBit
 *****************************************************************************/
/*!
 * \brief         Set an event's disconnected bit
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     IsDisconnected
 *                TRUE: Set disconnected bit to TRUE
 *                FALSE: Set disconnected bit to FALSE
 *
 * \pre           Must be called within critical section DiagMonitor
 * \config        DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventSetDisconnectedBit(
  Dem_EventIdType EventId,
  boolean IsDisconnected
);
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventMayDisconnect
 *****************************************************************************/
/*!
 * \brief         Tests precondition for event disconnect
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           Must be called within critical section DiagMonitor
 * \config        DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventMayDisconnect(
  Dem_EventIdType EventId
);
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) && (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventDisconnect_Combined
 *****************************************************************************/
/*!
 * \brief         Marks a combined event unavailable
 *
 * \details       This function sets a sub-event unavailable and re-calculates
 *                the availability and suppression states for the combined
 *                DTC.
 *
 *                A stored DTC may not be set to unavailable, so this function
 *                performes no actions on stored DTCs and returns E_NOT_OK.
 *
 *                Do not call directly, use Dem_Esm_EventDisconnect instead.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 * \config           (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) 
 *                && (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventDisconnect_Combined(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventDisconnect_Normal
 *****************************************************************************/
/*!
 * \brief         Marks a normal event unavailable
 *
 * \details       This function sets the event unavailable if it is not stored.
 *                Otherwise, E_NOT_OK is returned.
 *
 *                Do not call directly, use Dem_Esm_EventDisconnect instead.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 * \config        DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventDisconnect_Normal(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventDisconnect
 *****************************************************************************/
/*!
 * \brief         Marks an event unavailable
 *
 * \details       This function sets an event unavailable, if its state allows
 *                to do so.
 *
 *                In case the event is set unavailable, its state is changed to
 *                0x00 and the FiM is informed.
 *
 *                Otherwise, this function returns E_NOT_OK.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \return        E_OK
 *                The event was set to unavailable
 * \return        E_NOT_OK
 *                The event was not set to unavailable
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventDisconnect(
   Dem_EventIdType  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) && (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventReconnect_Combined
 *****************************************************************************/
/*!
 * \brief         Marks a combined event available
 *
 * \details       This function sets a sub-event available and re-calculates
 *                the availability and suppression states for the combined
 *                DTC.
 *
 *                Do not call directly, use Dem_Esm_EventReconnect instead.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventReconnect_Combined(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventReconnect_Normal
 *****************************************************************************/
/*!
 * \brief         Marks a normal event available
 *
 * \details       This function sets a sub-event available and re-calculates
 *                the availability and suppression states for the combined
 *                DTC.
 *
 *                Do not call directly, use Dem_Esm_EventReconnect instead.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventReconnect_Normal(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventReconnect
 *****************************************************************************/
/*!
 * \brief         Marks an event available
 *
 * \details       This function sets an event available.
 *
 *                In case the event is set available, its state is changed to
 *                0x50 and the FiM is informed.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventReconnect(
   Dem_EventIdType  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventSetSuppression
 *****************************************************************************/
/*!
 * \brief         Marks an event suppressed
 *
 * \details       This function sets an event suppressed. For combined events,
 *                this also marks the combined event suppressed if all
 *                (available) sub-events are suppressed.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventSetSuppression(
   Dem_EventIdType  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventResetSuppression
 *****************************************************************************/
/*!
 * \brief         Marks an event unsuppressed
 *
 * \details       This function sets an event unsuppressed. For combined
 *                events, this also marks the combined event unsuppressed.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventResetSuppression(
   Dem_EventIdType  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventSetDtcSuppression
 *****************************************************************************/
/*!
 * \brief         Marks an event's DTC suppressed
 *
 * \details       This function sets an event's DTC suppressed.
 *                for combined events, it does not matter which sub-event is
 *                passed to this function.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventSetDtcSuppression(
   Dem_EventIdType  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventResetDtcSuppression
 *****************************************************************************/
/*!
 * \brief         Marks an event's DTC un-suppressed
 *
 * \details       This function sets an event's DTC un-suppressed.
 *                for combined events, it does not matter which sub-event is
 *                passed to this function.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventResetDtcSuppression(
   Dem_EventIdType  EventId
  );
#endif
/* ****************************************************************************
 * Dem_Esm_EventAged
 *****************************************************************************/
/*!
 * \brief         Completes aging of an event.
 *
 * \details       Depending on configuration this will clear the event's memory
 *                entry, or simply mark it as 'aged'.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     MemoryIndex
 *                Memory entry index
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventAged(
  Dem_EventIdType  EventId,
  Dem_Cfg_MemoryIndexType  MemoryIndex
  );

#if (DEM_FEATURE_NEED_AGING_IMMEDIATE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventAgingStartZeroTarget
 *****************************************************************************/
 /*!
 * \brief         Starts aging of an event with aging target 0
 *
 * \details       This function processes aging for events with aging target
 *                0. I.e. the event will age immediately. This function has
 *                no effect if the event in question is already aged or does
 *                not support aging.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
  */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventAgingStartZeroTarget(
  Dem_EventIdType  EventId
  );

#endif

#if (DEM_FEATURE_NEED_AGING_DELAYED == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventAgingStartMultiTarget
 *****************************************************************************/
/*!
 * \brief         Starts aging of an event.
 *
 * \details       This function sets up an event for aging. In case the event
 *                already ages (or does not support aging), this does nothing.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventAgingStartMultiTarget(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON) || (DEM_CFG_STORAGE_AT_FDC == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventFdcTrip
 *****************************************************************************/
/*!
 * \brief         Updates event data due to exceeding a FDC threshold
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     FirstThisCycle
 *                Flag to mark if FDC did already trip this cycle
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFdcTrip(
  Dem_EventIdType  EventId,
  boolean FirstThisCycle
  );
#endif

#if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventFdcMax
 *****************************************************************************/
/*!
 * \brief         Update event data 'maximum FDC since last clear'
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE for different EventId
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFdcMax(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
/* ****************************************************************************
 * Dem_Esm_ProcessFdc
 *****************************************************************************/
/*!
 * \brief         Process the event's FDC trip actions
 *
 * \details       This function processes the stored triggers from debounce
 *                values passing the FDC trip threshold.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_ProcessFdc(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_FEATURE_NEED_HEALING == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventPassed_ProcessHealing
 *****************************************************************************/
/*!
 * \brief         Tests if an event has healed (healing target 0)
 *
 * \param[in]     EventContext
 *                Event processing context
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventPassed_ProcessHealing(
  P2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext
  );
#endif
/* ****************************************************************************
 * Dem_Esm_EventPassed_Queued
 *****************************************************************************/
/*!
 * \brief         Process the event's queued qualified passed result
 *
 * \details       This function processes a passed result stored on the
 *                event queue, for events using the QUEUED mechanism. The
 *                triggers resulting from the status bit changes are calculated
 *                within this function, based on the current event status.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventPassed_Queued(
  Dem_EventIdType  EventId
  );

/* ****************************************************************************
 * Dem_Esm_EventPassed_Immediate
 *****************************************************************************/
/*!
 * \brief         Processes the event's queued qualified passed result
 *
 * \details       This function processes a passed result stored on the
 *                event queue, for events using the IMMEDIATE mechanism. The
 *                triggers are stored on the queue, and need to be passed to
 *                this function, the event status is assumed to have already
 *                changed according to those triggers.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     Effects
 *                Trigger flags
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventPassed_Immediate(
  Dem_EventIdType  EventId,
  uint8 Effects
  );

#if (DEM_FEATURE_NEED_TRIPPING == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventTestConfirmed
 *****************************************************************************/
/*!
 * \brief         Tests if an event has confirmed (completed tripping)
 *
 * \param[in]     EventContext
 *                Event processing context
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventTestConfirmed(
  P2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext
  );
#endif

/* ****************************************************************************
 * Dem_Esm_EventFailed_ProcessPending
 *****************************************************************************/
/*!
 * \brief         Processes the pendingDtc status change
 *
 * \param[in]     EventContext
 *                Event processing context
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_ProcessPending(
P2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext
);

/* ****************************************************************************
 * Dem_Esm_EventFailed_ProcessConfirmed
 *****************************************************************************/
/*!
 * \brief         Processes the confirmedDtc status change
 *
 * \param[in]     EventContext
 *                Event processing context
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_ProcessConfirmed(
P2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext
);

/* ****************************************************************************
 * Dem_Esm_EventFailed_ProcessStorage
 *****************************************************************************/
/*!
 * \brief         Process event storage into event memory
 *
 * \param[in]     EventContext
 *                Event processing context
 *
 * \return        TRUE
 *                Event data was modified
 * \return        FALSE
 *                Event data was not modified
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventFailed_ProcessStorage(
P2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext
);

/* ****************************************************************************
 * Dem_Esm_EventFailed_CommitToMemory
 *****************************************************************************/
/*!
 * \brief         Commits the event status changes into active memory
 *
 * \param[in]     EventContext
 *                Event processing context
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_CommitToMemory(
P2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext
);

#if (DEM_FEATURE_NEED_NOTIFY == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventFailed_ProcessNotifications
 *****************************************************************************/
/*!
 * \brief         Notifies all changes to observers
 *
 * \param[in]     EventContext
 *                Event processing context
 * \param[in]     DataModified
 *                Flags if data change notification is requested
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_ProcessNotifications(
P2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext,
boolean DataModified
);
#endif

/* ****************************************************************************
 * Dem_Esm_EventOpCycleStart
 *****************************************************************************/
/*!
 * \brief         Processes the start of the event's operation cycle
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventOpCycleStart(
  Dem_EventIdType  EventId
  );

#if ( (DEM_FEATURE_NEED_INDICATORS == STD_ON) \
   && ((DEM_FEATURE_NEED_MULTIHEAL == STD_ON) || (DEM_FEATURE_NEED_SINGLEHEAL == STD_ON)) )
/* ****************************************************************************
 * Dem_Esm_EventHealed
 *****************************************************************************/
/*!
 * \brief         Heals an event
 *
 * \details       Resets all warning indicator requests.
 *                This can modify the global indicator state if the indicator
 *                is no longer requested at all.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     EventStatus
 *                Current event status of the event
 *
 * \return        Modified event status based on the status passed
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Esm_EventHealed(
  Dem_EventIdType  EventId,
  uint8 EventStatus
  );
#endif

#if (DEM_FEATURE_NEED_HEALING == STD_ON)  && (DEM_FEATURE_NEED_MULTIHEAL == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventProcessHealing
 *****************************************************************************/
/*!
 * \brief         Processes an event's healing conditions
 *
 * \details       If the healing conditions configured for the event are
 *                fulfilled, the event is healed.
 *
 *                Otherwise the function has no effect.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     EventStatus
 *                Current event status of the event
 *
 * \return        Modified event status based on the status passed
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Esm_EventProcessHealing(
  Dem_EventIdType  EventId,
  uint8 EventStatus
  );
#endif

/* ****************************************************************************
 * Dem_Esm_EventOpCycleEnd
 *****************************************************************************/
/*!
 * \brief         Processes the end of the event's operation cycle
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     OldDtcStatus
 *                Dtc status before cycle restart
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventOpCycleEnd(
  Dem_EventIdType  EventId,
  uint8 OldDtcStatus
  );

#if ((DEM_CFG_AGING_NEXT_TESTS_TNCTOC == STD_ON) || (DEM_CFG_AGING_NEXT_TESTS_TFTOC == STD_ON))
/* ****************************************************************************
 * Dem_Esm_TestStatusForAgingCycle
 *****************************************************************************/
/*!
 * \brief         Tests whether the current cycle can be counted as aging
 *                cycle
 *
 * \param[in]     EventStatus
 *                UDS event status to test
 *
 * \return        TRUE
 *                The aging conditions are fulfilled for this cycle
 * \return        FALSE
 *                the aging conditions are not fulfilled for this cycle
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_TestStatusForAgingCycle(
  uint8 EventStatus
  );
#endif

/* ****************************************************************************
 * Dem_Esm_EventAgingCycle
 *****************************************************************************/
/*!
 * \brief         Processes an aging cycle for an event
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     CycleCounter
 *                Current cycle count
 * \param[in]     MemoryIndex
 *                Memory entry index
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventAgingCycle(
  Dem_EventIdType  EventId,
  uint16  CycleCounter,
  Dem_Cfg_MemoryIndexType  MemoryIndex
  );

#if (DEM_CFG_NOTIFY_CLEAR_ALLOWED == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventCleared_Optional
 *****************************************************************************/
/*!
 * \brief         Maybe clears an event from the given origin memory
 *
 * \details       This function clears an event based on the return value of
 *                its 'clear event allowed' callback
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \return        TRUE
 *                The event was cleared
 * \return        FALSE
 *                The event was not cleared
 *
 * \pre           RTE must be started
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventCleared_Optional(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_CFG_NOTIFY_CLEAR_ALLOWED != STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventCleared_Always
 *****************************************************************************/
/*!
 * \brief         Clears an event from the given origin memory
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventCleared_Always(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_FEATURE_NEED_OBD == STD_ON) && (DEM_CFG_SUPPORT_RESTART_DCY_ON_CLEAR_DTC == STD_ON)
/* ****************************************************************************
 * Dem_Esm_PreOnClear_AllDtc
 *****************************************************************************/
/*!
 * \brief         Restarts the DCY before Clear DTC was processed
 *
 * \details       This function is the global handler for all ClearAllDTC events.
 *
 * \param[in]     MemoryId
 *                Unique identifier of the event memory
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PreOnClear_AllDtc(
  uint8  MemoryId
  );
#endif

/* ****************************************************************************
 * Dem_Esm_PostOnClear_AllDtc
 *****************************************************************************/
/*!
 * \brief         Clears global statistics after Clear DTC was processed
 *
 * \details       This function is the global handler for ClearAllDTC events.
 *                It clears all global statistic data which is cleared only
 *                on ClearAllDTC requests.
 *
 * \param[in]     MemoryId
 *                Unique identifier of the event memory
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PostOnClear_AllDtc(
  uint8  MemoryId
  );

#if (DEM_FEATURE_NEED_OBD == STD_ON) || (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
/* ****************************************************************************
 * Dem_Esm_PostOnClear_Always
 *****************************************************************************/
/*!
 * \brief         Clears global OBD statistics after Clear DTC was processed
 *
 * \details       This function is the global handler for all ClearDTC events.
 *                It clears all global statistic data which is cleared with
 *                all clear requests
 *
 * \param[in]     MemoryId
 *                Unique identifier of the event memory
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PostOnClear_Always(
  uint8  MemoryId
  );
#endif

#if (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON)
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
/* ****************************************************************************
 * Dem_Esm_EventDisplaced
 *****************************************************************************/
/*!
 * \brief         Updates the status of a displaced event
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
Dem_Esm_EventDisplaced(
  Dem_EventIdType  EventId
  );
#endif

/* ****************************************************************************
 * Dem_Esm_CycleUpdateAging
 *****************************************************************************/
/*!
 * \brief         Processes aging cycle updates
 *
 * \details       This function processes the aging cycle updates for all
 *                events currently stored in the event memory. This has effect
 *                only on events using the given aging cycle, when their aging
 *                condition is fulfilled for this cycle.
 *
 *                This function expects that the cycle counter has already been
 *                incremented for the cycle.
 *
 * \param[in]     CycleId
 *                Unique Id of the cycle
 * \param[in]     CycleCounter
 *                Current cycle count
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_CycleUpdateAging(
  uint8  CycleId,
  uint16 CycleCounter
  );

/* ****************************************************************************
 * Dem_Esm_CycleUpdateReadiness
 *****************************************************************************/
/*!
 * \brief         Processes operation cycle updates
 *
 * \details       This function processes the operation cycle updates for all
 *                events using that cycle as operation cycle.
 *
 *                Since operation cycles can restart or only stop/start, the
 *                cycle status can be one of DEM_QUEUE_CYCLE_STARTED,
 *                DEM_QUEUE_CYCLE_STOPPED or DEM_QUEUE_CYCLE_RESTARTED (most
 *                other APIs only accept the first two states).
 *
 * \param[in]     CycleId
 *                Unique Id of the cycle
 * \param[in]     CycleStatus
 *                Cycle status changes
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_CycleUpdateReadiness(
  uint8  CycleId,
  uint8  CycleStatus
  );

                                                                    /* Timer */
/* ------------------------------------------------------------------------- */
                                                                    /* Queue */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Queue_PreInit
 *****************************************************************************/
/*!
 * \brief         Initializes the event queue
 *
 * \details       This function initializes all global variables encoding queue
 *                states. Queued elements are qualification of events (FDCTRIP
 *                and PASSED<->FAILED toggles, as well as changes to a cycle
 *                state.
 *
 * \pre           May be called only during pre-initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_PreInit(
  void
  );

/* ****************************************************************************
 * Dem_Queue_Init
 *****************************************************************************/
/*!
 * \brief         Initializes the Dem queue states
 *
 * \details       This function initializes all global variables required to
 *                defer asynchronous requests to be processed on the Dem task
 *                function.
 *
 * \pre           May be called only during initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_Init(
  void
  );

/* ****************************************************************************
 * Dem_Queue_Shutdown
 *****************************************************************************/
/*!
 * \brief         Clears the Dem queue states
 *
 * \details       This function clears all global variables used to defer
 *                asynchronous requests to be processed on the Dem task
 *                function.
 *
 * \pre           May be called only during module shutdown
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_Shutdown(
  void
  );

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 * Dem_Queue_ProcessFilterEventData
 *****************************************************************************/
/*!
 * \brief         Prepares event data for diagnostic output
 *
 * \details       The function creates a copy of an event's stored environemnt
 *                data. The reading Dcm functions access this copy instead of
 *                the live data to guarantee a consistent output.
 *
 * \pre           The Dcm read buffer is currently not in use
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessFilterEventData(
  void
  );
#endif

#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
/* ****************************************************************************
 * Dem_Queue_ProcessClearSingleDtc
 *****************************************************************************/
/*!
 * \brief         Clears a single dtc
 *
 * \details       This function clears a single dtc and manages the related Dcm
 *                API state transitions.
 *
 * \return        TRUE
 *                The event was cleared
 * \return        FALSE
 *                The event was not cleared, clearing was forbidden by the
 *                application
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Queue_ProcessClearSingleDtc(
  void
  );
#endif

/* ****************************************************************************
 ! Dem_Queue_ProcessClearDtc
 *****************************************************************************/
/*!
 * \brief         Processes clear dtc requests
 *
 * \details       This function processes clear dtc requests. Group clear is
 *                optionally distributed across multiple tasks, single clear
 *                is processed immediately.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessClearDtc(
  void
  );

/* ****************************************************************************
 * Dem_Queue_ProcessEvent_Queued
 *****************************************************************************/
/*!
 * \brief         Processes events queued with the QUEUED mechanism
 *
 * \details       This function decodes the sequence of event reports stored
 *                for the given event, and calls the respective event processor
 *                functions, selecting the QUEUED processor variant to also
 *                handle transitions of asynchronous bit.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     QueueStatus
 *                Queued state of the event
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEvent_Queued(
  Dem_EventIdType  EventId,
  uint8 QueueStatus
  );

/* ****************************************************************************
 * Dem_Queue_ProcessEvent_Immediate
 *****************************************************************************/
/*!
 * \brief         Processes events queued with the IMMEDIATE mechanism
 *
 * \details       This function decodes the sequence of event reports and
 *                asynchronous bit transitions stored for the given event, and
 *                calls the respective event processor functions, selecting the
 *                IMMEDIATE processor variant.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     QueueStatus
 *                Queued state of the event
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEvent_Immediate(
  Dem_EventIdType  EventId,
  uint8 QueueStatus
  );

/* ****************************************************************************
 * Dem_Queue_ProcessEvent
 *****************************************************************************/
/*!
 * \brief         Processes the queued actions of an event
 *
 * \details       This function unqueues an event and selects the appropriate
 *                processor for either QUEUED or IMMEDIATE queued events.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEvent(
  Dem_EventIdType  EventId
  );

/* ****************************************************************************
 * Dem_Queue_ProcessSetEventStatus
 *****************************************************************************/
/*!
 * \brief         Processes all queued events
 *
 * \details       This function processes queued event status changes for all
 *                events
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessSetEventStatus(
  void
  );

/* ****************************************************************************
 * Dem_Queue_ProcessCycles
 *****************************************************************************/
/*!
 * \brief         Process all queued operation cycles
 *
 * \details       The function processes cycle management for aging and
 *                operation cycle management (readiness bits etc)
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessCycles(
  void
  );

#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
/* ****************************************************************************
 * Dem_Queue_ProcessEventEnableConditions
 *****************************************************************************/
/*!
 * \brief         Processes changes of enable condition state
 *
 * \details       This function resets or freezes debouncing of an events based
 *                on the changes of the enable condition states since this
 *                function was called last. When the event is re-enabled, this
 *                function also calls the init monitor notifications.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     OldConditionStates
 *                Previous enable condition states
 * \param[in]     NewConditionStates
 *                Updated enable condition states
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEventEnableConditions(
  Dem_EventIdType EventId,
  uint32 OldConditionStates,
  uint32 NewConditionStates
);
#endif

#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
/* ****************************************************************************
 * Dem_Queue_ProcessEnableConditions
 *****************************************************************************/
/*!
 * \brief         Process enable condition changes
 *
 * \details       This function processes changes of the debouncing state for
 *                all events.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEnableConditions(
  void
  );
#endif

/* ****************************************************************************
 * Dem_Queue_MainFunction
 *****************************************************************************/
/*!
 * \brief         Process all queued actions
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_MainFunction(
  void
  );

                                                        /* Data Provisioning */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Data_EntryInit
 *****************************************************************************/
/*!
 * \brief         Initializes an event memory entry
 *
 * \param[in]     MemoryEntry
 *                Pointer to the event memory entry
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_EntryInit(
  Dem_Mem_EntryPtrType  MemoryEntry
  );

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Data_CollectSnapshot
 *****************************************************************************/
/*!
 * \brief         Samples a snapshot for an event
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[out]    DestinationBuffer
 *                Pointer to the buffer to store the data
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_CollectSnapshot(
  Dem_EventIdType EventId,
  Dem_SharedDataPtrType DestinationBuffer
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Data_PrestorageApplySRec
 *****************************************************************************/
/*!
 * \brief         Copies a prestored snapshot for an event
 *
 * \details       This function copies the prestored data only if a prestored
 *                entry has been locked for the event. Otherwise, this function
 *                does not modify the destination buffer.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[out]    DestinationBuffer
 *                Pointer to the buffer to store the data
 *
 * \return        TRUE
 *                Data has been copied
 * \return        FALSE
 *                No data has been copied
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_PrestorageApplySRec(
  Dem_EventIdType  EventId,
  Dem_SharedDataPtrType  DestinationBuffer
  );
#endif

#if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
/* ****************************************************************************
 * Dem_Data_EntryUpdate_UserERecs
 *****************************************************************************/
/*!
 * \brief         Collects the user provided data stored for an event entry.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     MemoryEntry
 *                Pointer to the event memory entry
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_EntryUpdate_UserERecs(
  Dem_EventIdType  EventId,
  Dem_Mem_EntryPtrType  MemoryEntry
  );
#endif

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Data_EntryUpdate_SRecs
 *****************************************************************************/
/*!
 * \brief         Collect all user snapshot records for an event
 *
 * \details       This function will look for every snapshot record of the
 *                event that needs updating due to the due to the status
 *                changes encoded by the trigger flags.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     MemoryEntry
 *                Pointer to the event memory entry
 * \param[in]     UpdateFlags
 *                Trigger flags
 *
 * \return        TRUE
 *                Data was collected
 * \return        FALSE
 *                No data was changed
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_EntryUpdate_SRecs(
  Dem_EventIdType  EventId,
  Dem_Mem_EntryPtrType  MemoryEntry,
  uint8  UpdateFlags
  );
#endif

/* ****************************************************************************
 * Dem_Data_EntryUpdate
 *****************************************************************************/
/*!
 * \brief         Updates all data stored for an event.
 *
 * \details       Depending on configuration of the event data, collect the
 *                data to be updated due to the triggered update event.
 *                This includes statistical data (e.g. occurrence counter) as
 *                well as environment data collected from callback routines.
 *
 *                Statistical data stored separately in the MemoryEntry and
 *                mapped into snapshot and extended records when reading the
 *                data.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     MemoryEntry
 *                Pointer to the event memory entry
 * \param[in]     UpdateFlags
 *                Trigger flags
 *
 * \return        TRUE
 *                Data was collected
 * \return        FALSE
 *                No data was changed
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_EntryUpdate(
  Dem_EventIdType  EventId,
  uint8  UpdateFlags,
  Dem_Cfg_MemoryIndexType  MemoryIndex
  );

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 * Dem_Data_CalculateFDC_CounterBased
 *****************************************************************************/
/*!
 * \brief         Calculates the current fault detection counter of an event.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     DebounceValue
 *                Debounce counter value
 *
 * \return        The FaultDetectionCounter based on DebounceValue
 *
 * \pre           The event must use counter based debouncing
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(sint8, DEM_CODE)
Dem_Data_CalculateFDC_CounterBased(
  Dem_EventIdType  EventId,
  sint16  DebounceValue
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Data_CalculateFDC_TimeBased
 *****************************************************************************/
/*!
 * \brief         Calculates the current fault detection counter of an event.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     DebounceValue
 *                Debounce time value
 * \param[in]     DebounceStatus
 *                Debouncing state
 *
 * \return        The FaultDetectionCounter based on the given time and state
 *
 * \pre           The event must use time based debouncing
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(sint8, DEM_CODE)
Dem_Data_CalculateFDC_TimeBased(
  Dem_EventIdType  EventId,
  sint16  DebounceValue,
  uint8  DebounceStatus
  );
#endif

#if ( (DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON) \
   || ((DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON) && (DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE == STD_ON)) )
/* ****************************************************************************
 * Dem_Data_EventGetFDCMax
 *****************************************************************************/
/*!
 * \brief         Gets the maximum fault detection counter of an event
 *
 * \details       This function retrieves the maximum value of the FDC in
 *                the current operation cylce. In case of external debouncing,
 *                this function returns an estimate based on the event's UDS
 *                status byte.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \return        The maximum FDC this operation cycle
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(sint8, DEM_CODE)
Dem_Data_EventGetFDCMax(
  Dem_EventIdType EventId
  );
#endif

#if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
/* ****************************************************************************
 * Dem_Data_ERecIsStored
 *****************************************************************************/
/*!
 * \brief         Tests whether an extended record is currently stored
 *
 * \param[in]     MemoryEntry
 *                Pointer to the event memory entry
 * \param[in]     ERecStoredIndex
 *                Index of the extended record
 *
 * \return        TRUE
 *                The record is stored
 * \return        FALSE
 *                The record is not stored
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_ERecIsStored(
  Dem_Mem_ConstEntryPtrType  MemoryEntry,
  uint8  ERecStoredIndex
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Data_SRecCount
 *****************************************************************************/
/*!
 * \brief         Counts the number of snapshot records stored in a memory
 *                entry
 *
 * \param[in]     MemoryEntry
 *                Pointer to the event memory entry
 *
 * \result        Number of stored snapshot records
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Data_SRecCount(
  Dem_Mem_ConstEntryPtrType  MemoryEntry
  );
#endif

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Data_SRecIsStored
 *****************************************************************************/
/*!
 * \brief         Tests whether a snapshot record is currently stored
 *
 * \param[in]     MemoryEntry
 *                Pointer to the event memory entry
 * \param[in]     SRecStoredIndex
 *                Index of the snapshot record
 *
 * \return        TRUE
 *                The record is stored
 * \return        FALSE
 *                The record is not stored
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_SRecIsStored(
  Dem_Mem_ConstEntryPtrType  MemoryEntry,
  uint8  SRecStoredIndex
  );
#endif

#if (DEM_CFG_SUPPORT_SRECS == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_OBDII == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_WWHOBD == STD_ON)
/* ****************************************************************************
 * Dem_Data_SkipDid
 *****************************************************************************/
/*!
 * \brief         Skip data elements
 *
 * \details       Moves the read (source) pointer in the copy context to skip
 *                the stored data for the given DID. This function has no
 *                effect if the DID does not have persisted data, e.g. if the
 *                DID is composed of statistical values.
 *
 * \param[in]     CopyDidInfoStruct
 *                CopyDid context
 * \param[in]     DidIndex
 *                Unique handle of the DID
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_SkipDid(
  Dem_Data_CopyDidInfoPtrType CopyDidInfoPtr,
  Dem_Cfg_DidIndexType  DidIndex
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Data_SRecCopyData
 *****************************************************************************/
/*!
 * \brief         Copies the contents of a stored snapshot record
 *
 * \details       This function formats the stored snapshot record according
 *                to the UDS specification and copies the result to the given
 *                buffer.
 *
 * \param[out]    Buffer
 *                Pointer to the output buffer
 * \param[in]     SRecStoredIndex
 *                Relative index of the snapshot record
 *
 * \pre           A memory entry must have been copied to the intermediate
 *                buffer (\see Dem_DcmDisableDTCRecordUpdate)
 * \pre           Existance of the record must be verified before calling this
 *                function (\see Dem_Data_SRecIsStored)
 * \pre           The buffer must be large wnough to hold the formatted UDS
 *                record
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_SRecCopyData(
  Dem_SharedDataPtrType  Buffer,
  uint8  SRecStoredIndex
  );
#endif

#if (DEM_FEATURE_NEED_CYCLE_COUNTERS == STD_ON)
/* ****************************************************************************
 * Dem_Data_EntryOpCycleStart
 *****************************************************************************/
/*!
 * \brief         Latches overflowing operation cycle counters
 *
 * \param[in]     MemoryEntry
 *                Pointer to the event memory entry
 * \param[in]     CycleCount
 *                The new cycle counter
 *
 * \return        TRUE
 *                The memory entry has been modified
 * \return        FALSE
 *                The memory entry has not been modified
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_EntryOpCycleStart(
  Dem_Mem_EntryPtrType  MemoryEntry,
  uint16  CycleCount
  );
#endif

#if (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON) || (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
/* ****************************************************************************
 * Dem_Data_DtcOpCycleUpdate
 *****************************************************************************/
/*!
 * \brief         Counts operation cycle counters, if necessary
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     DtcStatus
 *                DTC status byte
 * \param[in]     CycleStatus
 *                Cycle status changes
 *
 * \pre           The passed event must be a master event
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_DtcOpCycleUpdate(
  Dem_EventIdType  EventId,
  uint8  DtcStatus,
  uint8  CycleStatus
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Data_PrestorageEntryUpdate
 *****************************************************************************/
/*!
 * \brief         Samples all event related data into a prestorage entry
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     PrestoredEntry
 *                Pointer to the prestorage entry
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_PrestorageEntryUpdate(
  Dem_EventIdType  EventId,
  Dem_Mem_PrestoredEntryPtrType  PrestoredEntry
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_AGINGCTR == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyUpwardsAgingCounter
 *****************************************************************************/
/*!
 * \brief         Retrieves the aging counter of the event holding the primary
 *                entry as upward counting data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyUpwardsAgingCounter(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_AGINGCTR_INVERTED == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyDownwardsAgingCounter
 *****************************************************************************/
/*!
 * \brief         Retrieves the aging counter of the event holding the primary
 *                entry as downward counting data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyDownwardsAgingCounter(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_OCCCTR == STD_ON)
/* ****************************************************************************
 * Dem_Data_Copy1ByteOccurrenceCounter
 *****************************************************************************/
/*!
 * \brief         Retrieves the occurrence counter of the event holding the
 *                primary entry as 1 byte data element
 *
 * \details       An occurrence counter that will not fit 1 byte is written as
 *                255.
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_Copy1ByteOccurrenceCounter(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON)
/* ****************************************************************************
 * Dem_Data_Copy2ByteOccurrenceCounter
 *****************************************************************************/
/*!
 * \brief         Retrieves the occurrence counter of the event holding the
 *                primary entry as 2 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_Copy2ByteOccurrenceCounter(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_OVFLIND == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyOverflowIndication
 *****************************************************************************/
/*!
 * \brief         Retrieves the primary memory overflow state as 1 byte data
 *                element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyOverflowIndication(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_SIGNIFICANCE == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyEventSignificance
 *****************************************************************************/
/*!
 * \brief         Retrieves the significance configuration of the event holding
 *                the primary entry as 1 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyEventSignificance(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_PRIORITY == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyEventPriority
 *****************************************************************************/
/*!
 * \brief         Retrieves the priority configuration of the event holding
 *                the primary entry as 1 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyEventPriority(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyMaxFdcSinceLastClear
 *****************************************************************************/
/*!
 * \brief         Retrieves the maximum fault detection counter since last
 *                clear of the event holding the primary entry as 1 byte data
 *                element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyMaxFdcSinceLastClear(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyMaxFdcThisCycle
 *****************************************************************************/
/*!
 * \brief         Retrieves the maximum fault detection counter this cycle
 *                of the event holding the primary entry as 1 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyMaxFdcThisCycle(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyCyclesSinceLastFailed
 *****************************************************************************/
/*!
 * \brief         Retrieves the cycle count since last failed of the event
 *                holding the primary entry as 1 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCyclesSinceLastFailed(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyCyclesSinceFirstFailed
 *****************************************************************************/
/*!
 * \brief         Retrieves the cycle count since first failed of the event
 *                holding the primary entry as 1 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCyclesSinceFirstFailed(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_FAILED_CYCLES == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyFailedCycles
 *****************************************************************************/
/*!
 * \brief         Retrieves the number of cycles tested failed of the event
 *                holding the primary entry as 1 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyFailedCycles(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyConsecutiveFailedCycles
 *****************************************************************************/
/*!
 * \brief         Retrieves the number of consecutive cycles tested failed of
 *                the event holding the primary entry as 1 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyConsecutiveFailedCycles(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyCyclesTestedSinceFirstFailed
 *****************************************************************************/
/*!
 * \brief         Retrieves the number of cycles tested since first failed of
 *                the event holding the primary entry as 1 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCyclesTestedSinceFirstFailed(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_ROOTCAUSE_EVENTID == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyRootCauseEventId
 *****************************************************************************/
/*!
 * \brief         Retrieves the (sub)event that stored the primary entry as 2
 *                byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyRootCauseEventId(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_OBDDTC == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyEventObdDtc
 *****************************************************************************/
/*!
 * \brief         Retrieves the OBD DTC number of the event that stored the
 *                primary entry as 2 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyEventObdDtc(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_OBDDTC_3BYTE == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyEventObdDtc_3Byte
 *****************************************************************************/
/*!
 * \brief         Retrieves the OBD DTC number of the event that stored the
 *                primary entry as 3 byte data element with trailing 0
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyEventObdDtc_3Byte(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_CURRENT_FDC == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyCurrentFdc
 *****************************************************************************/
/*!
 * \brief         Retrieves the current fault detection counter of the event
 *                holding the primary entry as 1 byte data element
 *
 * \param[in]     CopyDidInfoPtr
 *                CopyDid context
 *
 * \return        TRUE
 *                Data was copied
 * \return        FALSE
 *                No data was copied
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCurrentFdc(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  );
#endif

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 * Dem_Nvm_CommitBlock
 *****************************************************************************/
/*!
 * \brief         Processes NvM synchronization
 *
 * \details       This function writes the memory block marked for immediate
 *                synchronization into the NV storage.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_CommitBlock(
  void
  );
#endif

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 % Dem_Nvm_ProcessQueue
 *****************************************************************************/
/*!
 * \brief         Process updates of dirty markers
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_ProcessQueue(
  void
);
#endif

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON) && (DEM_CFG_SUPPORT_NVM_POLLING == STD_ON )
/* ****************************************************************************
 % Dem_Nvm_GetNvMResult
 *****************************************************************************/
/*!
 * \brief         Poll the result of an ongoing write job
 *
 * \pre           -
 * \config        DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON &&
 *                DEM_CFG_SUPPORT_NVM_POLLING == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
  Dem_Nvm_GetNvMResult(
  void
);
#endif

#if (DEM_CFG_USE_NVM == STD_ON)
/* ****************************************************************************
 * Dem_Nvm_Init
 *****************************************************************************/
/*!
 * \brief         Initializes the NvM management
 *
 * \pre           May be called only during module initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_Init(
  void
  );
#endif

#if (DEM_CFG_USE_NVM == STD_ON)
/* ****************************************************************************
 * Dem_Nvm_Shutdown
 *****************************************************************************/
/*!
 * \brief         Updates NvM dirty flags
 *
 * \details       All pending Nv updates are marked as modified block for the
 *                NvM. (NvM_SetRamBlockStatus). The Dem assumes that all such
 *                marked blocks are persisted in Nv using NvM_WriteAll
 *                following the Dem shutdown. This is not in scope of the Dem
 *                module however.
 *                If Dem_Shutdown is ever called without a following
 *                NvM_WriteAll, data will be lost.
 *
 * \brief         Initializes the NvM management
 *
 * \pre           May be called only during module shutdown
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_Shutdown(
  void
  );
#endif

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 * Dem_Nvm_MainFunction
 *****************************************************************************/
/*!
 * \brief         Processes NvM synchronization
 *
 * \details       The function controls NvM commits. Modified blocks are passed
 *                the NvM to write back, and once the write operation finishes
 *                the next modified block is processed.
 *                In case of polling, NvM job results are updated here as well.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_MainFunction(
  void
  );
#endif

                                                            /* DCM Interface */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Dcm_Init
 *****************************************************************************/
/*!
 * \brief         Initializes DCM state variables
 *
 * \pre           May be called only during module initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Dcm_Init(
  void
  );

#if (DEM_CFG_SUPPORT_DCM == STD_ON) || (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
/* ***************************************************************************
 * Dem_Dcm_FindEventFromUdsDtc
 *****************************************************************************/
/*!
 * \brief         Looks up the EventId corresponding to a Dtc number.
 *
 * \details       This function searches for an event using the given UdsDtc
 *                number.  In contrast to \see Dem_Cfg_FindEventFromUdsDtc, the
 *                Dtc number and EventId are cached in case the same Dtc is
 *                requested again - which is rather typical for Dcm access.
 *
 * \param[in]     UdsDtc
 *                The UDS Dtc number
 * \param[in]     MemoryId
 *                The memory Id
 *
 * \return        The EventId the DTC in the requested memory with the given
 *                DTC number. DEM_EVENT_INVALID if no matching event is found.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FindEventFromUdsDtc(
  uint32  UdsDtc,
  uint8  MemoryId,
  uint8  ClientId
  );
#endif

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_CopyDidFromSRec
 *****************************************************************************/
/*!
 * \brief         Extracts a snapshot record, or a single DID from it
 *
 * \details       The stored snapshot data of the event is written to
 *                DestBuffer in no particular format. This means in case of
 *                ReportTotalRecord == TRUE all data is simply concatenated.
 *                The record number 0xff (in this case: most recent snapshot)
 *                is supported only in configurations using calculated record
 *                numbers.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     RecordNumber
 *                Snapshot record number
 * \param[in]     ReportTotalRecord
 *                TRUE:  Return the data of all stored DIDs (unformatted)
 *                FALSE: Return only the data of the DID 'DataId'
 * \param[in]     DataId
 *                Return only the data of this DID. Only evaluated if also
 *                ReportTotalRecord == FALSE.
 * \param[out]    DestBuffer
 *                Pointer to the output buffer
 *
 * \return        E_OK
 *                The requested data was copied to the destination buffer
 * \return        E_NOT_OK
 *                The requested data was not copied due to an error. E.g. when
 *                called with invalid arguments, or the data is concurrently
 *                updated.
 * \return        DEM_E_NODATAAVAILABLE
 *                The data is not currently stored for the requested event.
 * \return        DEM_E_WRONG_RECORDNUMBER
 *                The requested data was not copied due to an undefined
 *                RecordNumber for the given event.
 * \return        DEM_E_WRONG_DIDNUMBER
 *                The requested data was not copied due to an undefined
 *                data indentifier within the requested record (in case
 *                ReportTotalRecord == FALSE)
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Dcm_CopyDidFromSRec(
  Dem_EventIdType  EventId,
  uint8  RecordNumber,
  boolean  ReportTotalRecord,
  uint16  DataId,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer
);
#endif

#if (DEM_CFG_SUPPORT_ERECS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_CopyERecs
 *****************************************************************************/
/*!
 * \brief         Extract an extended data record for an event
 *
 * \details       Read and copy the stored environmental data of an event. The
 *                data is written to DestBuffer in no particular format.
 *                The record numbers 0xfe and 0xff are not supported.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     RecordNumber
 *                Extended record number
 * \param[in]     ReportTotalRecord
 *                TRUE:  Return the data of all stored DIDs (unformatted)
 *                FALSE: Return only the data of the DID 'DataId'
 * \param[in]     DataId
 *                Return only the data of this DID. Only evaluated if also
 *                ReportTotalRecord == FALSE.
 * \param[out]    DestBuffer
 *                Pointer to the output buffer
 *
 * \return        E_OK
 *                The requested data was copied to the destination buffer
 * \return        E_NOT_OK
 *                The requested data was not copied due to an error. E.g. when
 *                called with invalid arguments, or the data is concurrently
 *                updated.
 * \return        DEM_E_NODATAAVAILABLE
 *                The data is not currently stored for the requested event.
 * \return        DEM_E_WRONG_RECORDNUMBER
 *                The requested data was not copied due to an undefined
 *                RecordNumber for the given event.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Dcm_CopyERecs(
  Dem_EventIdType  EventId,
  uint8  RecordNumber,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer
);
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_CopySRec
 *****************************************************************************/
/*!
 * \brief         Validates the request to get the OBD-II FreezeFrame in UDS
 *                Format
 *
 * \details       This function does the necessary validations and eventually
 *                calls Dem_Data_SRecCopyData to copy a snapshot record.
 *                If errors are detected, the appropriate negative response is
 *                returned.
 *                The record number 0xFF is not allowed with this function,
 *                to get all records the caller must iterate through all the
 *                numbers.
 *
 * \param[in]     EventId
 *                Unique handle of the event
 * \param[in]     RecordNumber
 *                Snapshot record number
 * \param[out]    DestBuffer
 *                Pointer to the output buffer
 * \param[in,out] BufSize
 *                In: Available space in the receiving buffer
 *                Out: Number of written bytes.
 *
 * \return        DEM_GET_FFDATABYDTC_OK
 *                Data was found and returned
 * \return        DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER
 *                The requested record is not available for EventId
 * \return        DEM_GET_FFDATABYDTC_WRONG_BUFFERSIZE
 *                The destination buffer is too small
 *
 * \pre           A memory entry has to be locked for Dcm readout
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_ReturnGetFreezeFrameDataByDTCType, DEM_CODE)
Dem_Dcm_CopySRec(
  Dem_EventIdType  EventId,
  uint8  RecordNumber,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  BufSize
);
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && ((DEM_CFG_SUPPORT_SRECS == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_OBDII == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_WWHOBD == STD_ON))
/* ****************************************************************************
 * Dem_Dcm_GetSizeOfSRec
 *****************************************************************************/
/*!
 * \brief         Calculates the total of the event's snapshot records, when
 *                formatted as UDS snapshot record (19 04)
 *
 * \param[in]     EventId
 *                Unique handle of the event
 * \param[in]     RecordNumber
 *                Snapshot record number
 * \param[out]    SizeOfFreezeFrame
 *                Number of bytes.
 *
 * \return        DEM_GETSIZEBYDTC_OK
 *                Data was found and returned
 * \return        DEM_GETSIZEBYDTC_WRONG_RECNUM
 *                The requested record is not available
 *
 * \pre           A memory entry has to be locked for Dcm readout
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_ReturnGetSizeOfDataByDTCType, DEM_CODE)
Dem_Dcm_GetSizeOfSRec(
  Dem_EventIdType  EventId,
  uint8  RecordNumber,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  SizeOfFreezeFrame
);
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_ERECS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_CopyERec
 *****************************************************************************/
/*!
 * \brief         Validates the request to get an extended data record in UDS
 *                format
 *
 * \details       This function does the necessary validations and eventually
 *                calls Dem_Data_SRecCopyData to copy a snapshot record.
 *                If errors are detected, the appropriate negative response is
 *                returned.
 *                The record number 0xFF is not allowed with this function,
 *                to get all records the caller must iterate through all the
 *                numbers.
 *
 * \param[in]     EventId
 *                Unique handle of the event
 * \param[in]     RecordNumber
 *                Extended record number
 * \param[out]    DestBuffer
 *                Pointer to the output buffer
 * \param[in,out] BufSize
 *                In: Available space in the receiving buffer
 *                Out: Number of written bytes.
 *
 * \return        DEM_RECORD_OK
 *                Data was found and returned
 * \return        DEM_RECORD_WRONG_NUMBER
 *                The requested record is not available for EventId
 * \return        DEM_RECORD_WRONG_BUFFERSIZE
 *                The destination buffer is too small
 *
 * \pre           A memory entry has to be locked for Dcm readout
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_ReturnGetExtendedDataRecordByDTCType, DEM_CODE)
Dem_Dcm_CopyERec(
  Dem_EventIdType  EventId,
  uint8  RecordNumber,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  BufSize
);
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_ERECS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_GetSizeOfSRec
 *****************************************************************************/
/*!
 * \brief         Calculates the total of the event's snapshot records, when
 *                formatted as UDS snapshot record (19 04)
 *
 * \param[in]     EventId
 *                Unique handle of the event
 * \param[in]     RecordNumber
 *                Extended record number
 * \param[out]    SizeOfExtendedDataRecord
 *                Number of bytes.
 *
 * \return        DEM_GETSIZEBYDTC_OK
 *                Data was found and returned
 * \return        DEM_GETSIZEBYDTC_WRONG_RECNUM
 *                The requested record is not available
 *
 * \pre           A memory entry has to be locked for Dcm readout
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Dem_ReturnGetSizeOfDataByDTCType, DEM_CODE)
Dem_Dcm_GetSizeOfERec(
  Dem_EventIdType  EventId,
  uint8  RecordNumber,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  SizeOfExtendedDataRecord
);
#endif

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Esm_EventQueueAsync_Queued
 *****************************************************************************/
/*!
 * \brief         Processes queueing of event reports
 *
 * \details       This functions evaluates which results need queuing for
 *                events reported on the QUEUED path, i.e. without evaluating
 *                the current event status byte.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     DebounceInfo
 *                Monitor result after debouncing
 *
 * \return        E_OK
 *                The monitor result was queud
 * \return        E_NOT_OK
 *                The monitor result was discarded.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventQueueAsync_Queued(
  Dem_EventIdType  EventId,
  Dem_ConstDebounceInfoPtrType  DebounceInfo
  );

/* ****************************************************************************
 * Dem_Esm_EventQueueAsync_Immediate
 *****************************************************************************/
/*!
 * \brief         Processes queueing of event reports
 *
 * \details       This functions evaluates which results need queuing for
 *                events reported on the IMMEDIATE path, i.e. it uses the
 *                current event status byte.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     DebounceInfo
 *                Monitor result after debouncing
 *
 * \return        E_OK
 *                The monitor result was queud
 * \return        E_NOT_OK
 *                The monitor result was discarded.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventQueueAsync_Immediate(
  Dem_EventIdType  EventId,
  Dem_ConstDebounceInfoPtrType  DebounceInfo
  );

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Esm_ProcessTimeDebounce
 *****************************************************************************/
/*!
 * \brief         Processes the timer based debouncing of a event
 *
 * \details       Updates the debouncing state and timers of the debounced
 *                event. Any resulting event processing is deferred to the
 *                context of the Dem task.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_ProcessTimeDebounce(
   Dem_EventIdType  EventId
  );
#endif

/* ****************************************************************************
 * Dem_Esm_PreInit
 *****************************************************************************/
/*!
 * \brief         Pre-Initializes the Dem event state handling
 *
 * \pre           May be called only during module pre-initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PreInit(
  void
  );

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Esm_PrestorageInit
 *****************************************************************************/
/*!
 * \brief         Initializes the prestorage handling
 *
 * \pre           May be called only during module initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PrestorageInit(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) && (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
/* ****************************************************************************
 * Dem_Esm_InitEventAvailableNV
 *****************************************************************************/
/*!
 * \brief         Initializes the event availability from NV Ram
 *
 * \pre           May be called only during module initialization
 * \config        DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON &&
 *                DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_InitEventAvailableNV(
  void
  );
#endif

#if (DEM_FEATURE_NEED_EVENTAVAILABLE_DEFAULT == STD_ON)
/* ****************************************************************************
 * Dem_Esm_InitEventInternalStatus
 *****************************************************************************/
/*!
 * \brief         Initializes the internal event status of a given event
 *
 * \pre           May be called only during module initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_InitEventInternalStatus(
  Dem_EventIdType EventId
);
#endif

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 * Dem_Esm_InitGroupInternalStatus
 *****************************************************************************/
/*!
 * \brief         Initializes the internal event status of a given combined
 *                event group
 *
 * \pre           May be called only during module initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_InitGroupInternalStatus(
  Dem_Cfg_CombinedGroupIndexType GroupId
);
#endif

/* ****************************************************************************
 * Dem_Esm_InitEventStatus
 *****************************************************************************/
/*!
 * \brief         Initializes the event status of a given event
 *
 * \pre           May be called only during module initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_InitEventStatus(
  Dem_EventIdType EventId
  );

/* ****************************************************************************
 * Dem_Esm_Init
 *****************************************************************************/
/*!
 * \brief         Initializes the event status processing sub-component
 *
 * \pre           May be called only during module initialization
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_Init(
  void
  );

#if (DEM_CFG_SUPPORT_OPCYCLE_STORAGE != STD_ON) || (DEM_CFG_SUPPORT_OPCYCLE_AUTOMATIC_END == STD_ON)
/* ****************************************************************************
 * Dem_Esm_Shutdown
 *****************************************************************************/
/*!
 * \brief         Finalizes event status processing
 *
 * \details       Depending on configurataion, this function stops all running
 *                cycles, with all consequences this has on event status.
 *
 * \pre           May be called only during module shutdown
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_Shutdown(
  void
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Esm_MainFunction
 *****************************************************************************/
/*!
 * \brief         Processes all deferred operations
 *
 * \details       This function is the worker function of the Dem module.
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_MainFunction(
  void
  );
#endif

#define DEM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/* ********************************************************************************************************************
 *  LOCAL FUNCTION DECLARATIONS
 *********************************************************************************************************************/

#define DEM_START_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                                            /* Notifications */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
/* ****************************************************************************
 * Dem_Cbk_DtcStatusChanged_Internal
 *****************************************************************************/
/*!
 * \brief         Call all configured DTC status notification functions
 *
 * \details       The following callbacks are called here:
 *                - DtcStatusChanged(1...*)
 *                - DcmDtcStatusChanged(1)
 *
 *                Before the callbacks are processed, the passed event status
 *                is masked with the status availability mask
 *
 *                Although the callback processing is technically not possible
 *                reentrantly, the Autosar design forces this behavior. The
 *                resulting inconsistencies are documented in RfC 48668
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     DtcStatusOld
 *                The old DTC status
 * \param[in]     DtcStatusNew
 *                The new DTC status
 *
 * \pre           EventStatusOld must be different from EventStatusNew.
 * \pre           The external only status modifications must have been applied
 *                to the passed status bytes
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Cbk_DtcStatusChanged_Internal(
  Dem_EventIdType              EventId,
  Dem_EventStatusExtendedType  DtcStatusOld,
  Dem_EventStatusExtendedType  DtcStatusNew
  );
#endif

#if (DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON)
/* ****************************************************************************
 * Dem_Cbk_StatusChanged
 *****************************************************************************/
/*!
 * \brief         Call all configured event status notification functions
 *
 * \details       The following callbacks are called here:
 *                - EventStatusChanged(1...*)
 *                - GeneralEventStatusChanged(1)
 *                - FimEventStatusChanged(1)
 *                - DltEventStatusChanged(1)
 *
 *                Although the callback processing is technically not possible
 *                reentrantly, the Autosar design forces this behavior. The
 *                resulting inconsistencies are documented in RfC 48668
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     DtcStatusOld
 *                The old DTC status
 * \param[in]     DtcStatusNew
 *                The new DTC status
 *
 * \pre           EventStatusOld must be different from EventStatusNew.
 * \pre           The external only status modifications must have been applied
 *                to the passed status bytes
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Cbk_StatusChanged(
  Dem_EventIdType              EventId,
  Dem_EventStatusExtendedType  EventStatusOld,
  Dem_EventStatusExtendedType  EventStatusNew
  );
#endif
                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON)
/* ****************************************************************************
 * Dem_Mem_SelectDisplacedIndex
 *****************************************************************************/
/*!
 * \brief         Selects an event to displace in a filled memory
 *
 * \param[in]     MemoryInfo (conditional)
 *                Event memory descriptor
 * \param[in]     DisplacingEventId
 *                Unique handle of the Event to be entered into the memory
 *
 * \return        The memory index of the displaced memory entry if one could
 *                be identified. DEM_MEM_INVALID_MEMORY_INDEX if displacement
 *                was not possible.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(uint8, DEM_CODE)
Dem_Mem_SelectDisplacedIndex(
  DEM_MEM_MEMORYINFO_PARAMDEF_FIRST
  Dem_EventIdType  DisplacingEventId
  );
#endif

/* ****************************************************************************
 * Dem_Mem_MemoryAllocateIndex_Internal
 *****************************************************************************/
/*!
 * \brief         Selects a memory entry for an event
 *
 * \details       This function manages the primary memory storage. If a free
 *                slot is available, it is returned directly. In case no free
 *                slot is available, the configured displacement algorithm is
 *                applied to free a slot.
 *
 * \param[in]     MemoryInfo (conditional)
 *                Event memory descriptor
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \return        The memory index of the displaced memory entry if one could
 *                be identified. DEM_MEM_INVALID_MEMORY_INDEX if displacement
 *                was not possible.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryAllocateIndex_Internal(
  DEM_MEM_MEMORYINFO_PARAMDEF_FIRST
  Dem_EventIdType  EventId
  );

#if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON) && (DEM_FEATURE_NEED_AGING_DELAYED == STD_ON)
/* ****************************************************************************
 * Dem_Mem_MemoryAllocateAging_Internal
 *****************************************************************************/
/*!
 * \brief         Selects a memory entry for an event's aging counter
 *
 * \details       If a free memory alot is available, it is returned directly.
 *                There is no fallback in case of a filled up event memory.
 *
 * \param[in]     MemoryInfo (conditional)
 *                Event memory descriptor
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \return        The memory index of the displaced memory entry if one could
 *                be identified. DEM_MEM_INVALID_MEMORY_INDEX if no free slot
 *                was found.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_Cfg_MemoryIndexType, DEM_CODE)
Dem_Mem_MemoryAllocateAging_Internal(
  DEM_MEM_MEMORYINFO_PARAMDEF_FIRST
  Dem_EventIdType  EventId
  );
#endif

/* ****************************************************************************
 * Dem_Mem_MemoryFreeIndex_Internal
 *****************************************************************************/
/*!
 * \brief         Frees a event memory entry
 *
 * \details       This function returns a slot to the free slot list.
 *
 * \param[in]     MemoryInfo (conditional)
 *                Event memory descriptor
 * \param[in]     MemoryIndex
 *                Memory entry index
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Mem_MemoryFreeIndex_Internal(
  DEM_MEM_MEMORYINFO_PARAMDEF_FIRST
  uint8  MemoryIndex
  );

/* ****************************************************************************
 * Dem_Mem_MemoryFindIndex_Internal
 *****************************************************************************/
/*!
 * \brief         Finds the event memory allocated to an event
 *
 * \param[in]     MemoryInfo (conditional)
 *                Event memory descriptor
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \return        The memory index used by the event if one was found.
 *                Otherwise, DEM_MEM_INVALID_MEMORY_INDEX is returned.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryFindIndex_Internal(
  DEM_MEM_MEMORYINFO_PARAMDEF_FIRST
  Dem_EventIdType  EventId
  );

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 * Dem_Esm_CounterBasedCalculate
 *****************************************************************************/
/*!
 * \brief         Process the counter based debouncing of an event
 *
 * \param[in,out] DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.CounterBased specialisation.
 *
 * \return        TRUE
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_CounterBasedCalculate(
  Dem_DebounceInfoPtrType  DebounceInfo
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 * Dem_Esm_CounterBasedValidate
 *****************************************************************************/
/*!
 * \brief         Validate debouncing result
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.CounterBased specialisation.
 *
 * \return        TRUE
 *                The calculated debouncing result is still valid
 * \return        FALSE
 *                A concurrent modification has invalidated the calculation
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_CounterBasedValidate(
  Dem_DebounceInfoPtrType  DebounceInfo
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 * Dem_Esm_CounterBasedCommit
 *****************************************************************************/
/*!
 * \brief         Commit modified debouncing values to memory
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.CounterBased specialisation.
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_CounterBasedCommit(
  Dem_DebounceInfoPtrType  DebounceInfo
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 * Dem_Esm_CounterBasedFreeze
 *****************************************************************************/
/*!
 * \brief         Pauses counter based de-bouncing for an event (noop)
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.CounterBased specialisation.
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_CounterBasedFreeze(
  Dem_DebounceInfoPtrType  DebounceInfo
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 * Dem_Esm_CounterBasedReset
 *****************************************************************************/
/*!
 * \brief         Resets counter based de-bouncing for an event
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.CounterBased specialisation.
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_CounterBasedReset(
  Dem_DebounceInfoPtrType  DebounceInfo
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Esm_TimeBasedCalculate
 *****************************************************************************/
/*!
 * \brief         Process the time based debouncing of an event
 *
 * \param[in,out] DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.TimeBased specialisation.
 *
 * \return        TRUE
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_TimeBasedCalculate(
  Dem_DebounceInfoPtrType  DebounceInfo
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Esm_TimeBasedValidate
 *****************************************************************************/
/*!
 * \brief         Validate debouncing result
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.TimeBased specialisation.
 *
 * \return        TRUE
 *                The calculated debouncing result is still valid
 * \return        FALSE
 *                A concurrent modification has invalidated the calculation
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_TimeBasedValidate(
  Dem_DebounceInfoPtrType  DebounceInfo
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Esm_TimeBasedCommit
 *****************************************************************************/
/*!
 * \brief         Commit modified debouncing values to memory
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.TimeBased specialisation.
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_TimeBasedCommit(
  Dem_DebounceInfoPtrType  DebounceInfo
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Esm_TimeBasedFreeze
 *****************************************************************************/
/*!
 * \brief         Pauses time based de-bouncing for an event
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.TimeBased specialisation.
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_TimeBasedFreeze(
  Dem_DebounceInfoPtrType  DebounceInfo
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 * Dem_Esm_TimeBasedReset
 *****************************************************************************/
/*!
 * \brief         Resets time based de-bouncing for an event
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses Specific.TimeBased specialisation.
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_TimeBasedReset(
  Dem_DebounceInfoPtrType  DebounceInfo
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
/* ****************************************************************************
 * Dem_Esm_MonitorInternalCalculate
 *****************************************************************************/
/*!
 * \brief         Process monitor internal debouncing
 *
 * \param[in,out] DebounceInfo
 *                The debouncing information.
 *                This function uses no specialisation.
 *
 * \details       Monitor internal debouncing is handled inside the monitor,
 *                this function only validates the arguments.
 *
 * \return        TRUE
 *                The monitor result was valid
 * \return        FALSE
 *                The monitor result was invalid
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_MonitorInternalCalculate(
  Dem_DebounceInfoPtrType  DebounceInfo
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
/* ****************************************************************************
 * Dem_Esm_DebounceNoOpBoolean
 *****************************************************************************/
/*!
 * \brief         Placeholder debounce function, always returns positive result
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses no specialisation.
 *
 * \return        TRUE
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_DebounceNoOpBoolean(
  Dem_DebounceInfoPtrType  DebounceInfo
  );
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
/* ****************************************************************************
 * Dem_Esm_DebounceNoOpVoid
 *****************************************************************************/
/*!
 * \brief         Placeholder debounce function, has no effect
 *
 * \param[in]     DebounceInfo
 *                The debouncing information.
 *                This function uses no specialisation.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_DebounceNoOpVoid(
  Dem_DebounceInfoPtrType  DebounceInfo
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_INVALID == STD_ON)
/* ****************************************************************************
 * Dem_Esm_DebounceInvalidCalculate
 *****************************************************************************/
/*!
 * \brief         Fallback implementation, instead of NULL_PTR
 *
 * \param[in,out] DebounceInfo
 *                The debouncing information.
 *                This function uses no specialisation.
 *
 * \details       This function will always assert.
 *
 * \return        FALSE
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_DebounceInvalidCalculate(
  Dem_DebounceInfoPtrType  DebounceInfo
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_INVALID == STD_ON)
/* ****************************************************************************
 * Dem_Esm_DebounceInvalidBoolean
 *****************************************************************************/
/*!
 * \brief         Fallback implementation, instead of NULL_PTR
 *
 * \param[in,out] DebounceInfo
 *                The debouncing information.
 *                This function uses no specialisation.
 *
 * \details       This function will always assert.
 *
 * \return        FALSE
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_DebounceInvalidBoolean(
  Dem_DebounceInfoPtrType  DebounceInfo
  );
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_INVALID == STD_ON)
/* ****************************************************************************
 * Dem_Esm_DebounceInvalidVoid
 *****************************************************************************/
/*!
 * \brief         Fallback implementation, instead of NULL_PTR
 *
 * \param[in,out] DebounceInfo
 *                The debouncing information.
 *                This function uses no specialisation.
 *
 * \details       This function will always assert.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_DebounceInvalidVoid(
  Dem_DebounceInfoPtrType  DebounceInfo
  );
#endif

/* ****************************************************************************
 * Dem_Esm_EventFailed_Queued
 *****************************************************************************/
/*!
 * \brief         Process the event's queued qualified failed result
 *
 * \details       This function processes a failed result stored on the
 *                event queue, for events using the QUEUED mechanism. The
 *                triggers resulting from the status bit changes are calculated
 *                within this function, based on the current event status.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_Queued(
  Dem_EventIdType  EventId
  );

/* ****************************************************************************
 * Dem_Esm_EventFailed_Immediate
 *****************************************************************************/
/*!
 * \brief         Processes the event's queued qualified failed result
 *
 * \details       This function processes a failed result stored on the
 *                event queue, for events using the IMMEDIATE mechanism. The
 *                triggers are stored on the queue, and need to be passed to
 *                this function, the event status is assumed to have already
 *                changed according to those triggers.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     EventEffects
 *                Trigger flags for the event status
 * \param[in]     DTCEffects
 *                Trigger flags for the DTC status
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_Immediate(
  Dem_EventIdType  EventId,
  uint8  EventEffects,
  uint8  DtcEffects
  );

/* ****************************************************************************
 * Dem_Esm_CycleUpdate
 *****************************************************************************/
/*!
 * \brief         Updates cycle state
 *
 * \param[in]     CycleId
 *                Unique Id of the cycle
 * \param[in]     CycleStatus
 *                Cycle status changes
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_CycleUpdate(
  uint8  CycleId,
  uint8  CycleStatus
  );

#if (DEM_FEATURE_NEED_AGING_CYCLE_DISTANCE == STD_ON)
/* ****************************************************************************
 * Dem_Esm_CycleCountDistance
 *****************************************************************************/
/*!
 * \brief         Calculates the distance between cycle counter values
 *
 * \param[in]     CurrentCounter
 *                Current value of the cycle counter
 * \param[in]     TargetCounter
 *                Target counter value to find the distance to
 *
 * \return        Number of increments until current counter reaches target
 *                counter
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(uint16, DEM_CODE)
Dem_Esm_CycleCountDistance(
  uint16  CurrentCounter,
  uint16  TargetCounter
  );
#endif

/* ****************************************************************************
 * Dem_Esm_EventOpCycle_Internal
 *****************************************************************************/
/*!
 * \brief         Updates an event's state due to operation cycle change
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in,out] ArgPtr
 *                Arguments: CycleStatus - encoding of cycle modification
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventOpCycle_Internal(
  Dem_EventIdType  EventId,
  Dem_Util_ForEachCombinedArgPtrType  ArgPtr
);

/* ****************************************************************************
 * Dem_Esm_EventUpdateAsync_Queued
 *****************************************************************************/
/*!
 * \brief         Processes asynchronous monitor reports
 *
 * \details       This function processes event de-bouncing and queues
 *                qualified test results. This function implements the QUEUED
 *                processing, so the event status byte is not updated within
 *                this function, and the queue states are independent of its
 *                current value.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     EventStatus
 *                The monitor result
 *
 * \return        E_OK
 *                The monitor result was processed
 * \return        E_NOT_OK
 *                The monitor result was discarded.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventUpdateAsync_Queued(
  Dem_EventIdType  EventId,
  Dem_EventStatusType  EventStatus
  );

/* ****************************************************************************
 * Dem_Esm_EventUpdateAsync_Immediate
 *****************************************************************************/
/*!
 * \brief         Processes asynchronous monitor reports
 *
 * \details       This function processes event de-bouncing and queues
 *                qualified test results. This function implements the
 *                IMMEDIATE processing, so the asynchronously updated event
 *                status bits are modified within this function. The queued
 *                state also encodes those transitions.
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in]     EventStatus
 *                The monitor result
 *
 * \return        E_OK
 *                The monitor result was processed
 * \return        E_NOT_OK
 *                The monitor result was discarded.
 *
 * \pre           The Dem must be fully initialized
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventUpdateAsync_Immediate(
  Dem_EventIdType  EventId,
  Dem_EventStatusType  EventStatus
  );

/* ****************************************************************************
 * Dem_Esm_EventReset_Async
 *****************************************************************************/
/*!
 * \brief         Resets the 'TestFailed' bit
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \return        E_OK
 *                The TestFailed bit was reset
 * \return        E_NOT_OK
 *                The TestFailed bit was not modified.
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventReset_Async(
  Dem_EventIdType  EventId
  );

#if (DEM_FEATURE_NEED_AGING_AGE == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventAged_Internal
 *****************************************************************************/
/*!
 * \brief         Updates an event due to an aging cycle update
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in,out] ArgPtr
 *                Arguments: none
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventAged_Internal(
  Dem_EventIdType  EventId,
  Dem_Util_ForEachCombinedArgPtrType  ArgPtr
  );
#endif

/* ****************************************************************************
 * Dem_Esm_EventClearState
 *****************************************************************************/
/*!
 * \brief         Clears an event's local state
 *
 * \details       Do not call this function directly, it is part of
 *                Dem_Esm_EventCleared_Internal
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in,out] ArgPtr
 *                Arguments: none
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventClearState(
  Dem_EventIdType  EventId,
  Dem_Util_ForEachCombinedArgPtrType  ArgPtr
  );

/* ****************************************************************************
 * Dem_Esm_EventCleared_Internal
 *****************************************************************************/
/*!
 * \brief         Clears an event
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventCleared_Internal(
  Dem_EventIdType  EventId
  );

#if (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventDisplaced_Internal
 *****************************************************************************/
/*!
 * \brief         Updates an event's status due to displacement
 *
 * \details       Do not call this function directly, it is part of
 *                Dem_Esm_EventDisplaced
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 * \param[in,out] ArgPtr
 *                Arguments: none
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventDisplaced_Internal(
  Dem_EventIdType  EventId,
  Dem_Util_ForEachCombinedArgPtrType  ArgPtr
  );
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 * Dem_Esm_EventPrestorageClear
 *****************************************************************************/
/*!
 * \brief         Clears the prestorage entry of an event
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \return        E_OK
 *                The data was cleared successfully
 * \return        E_NOT_OK
 *                The data was not cleared, e.g. no data was available
 *
 * \pre           Must be called within critical section 'DiagMonitor'
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventPrestorageClear(
  Dem_EventIdType  EventId
  );
#endif
                                                                    /* Queue */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Queue_ProcessClearDtcGroup
 *****************************************************************************/
/*!
 * \brief         Process UDS clear dtc group requests
 *
 * \param[in]     FirstEventId
 *                Numerically smallest eventid belonging to the range
 * \param[in]     LastEventId
 *                Numerically largest eventid belonging to the range
 *
 * \details       The function processes clearing for the events in range
 *                [FirstEventId, LastEventId] (inclusive interval) that match
 *                the ClearDTC parameters.
 *
 * \pre           The global clear DTC context must have been initialized
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Queue_ProcessClearDtcGroup(
  uint16  FirstEventId,
  uint16  LastEventId
  );

                                                        /* Data Provisioning */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 % Dem_Data_CombinedGroupGetFDC
 *****************************************************************************/
/*!
 * \brief         Calculates the fault detection counter of a combined event
 *
 * \details       This function iterates through all sub-events, and takes the
 *                largest fault detection counter to represent the combined
 *                FDC.
 *                This is not stable against preemptive modification of the
 *                set of FDCs in concerned. This is not prevented as it would
 *                lead to a large runtime within a critical section, without
 *                actually increasing the expected quality of the result.
 *
 *                Explanation: If all sub-events report a fairly stable result
 *                (the FDCs count fairly linearly), the combined FDC is also
 *                reliable if it is colected without critical section.
 *                If the sub-events change their result often and chaotically,
 *                the combined FDC also behaves chaotically, based on report
 *                order and task priorities. Collecting the FDCs within a
 *                critical section will not improve the result.
 *
 * \param[in]     GroupId
 *                Unique identifier of the combined event group
 * \param[out]    FaultDetectionCounter
 *                Pointer to receive the FDC value
 *
 * \return        E_OK
 *                The combined FDC was returned in FaultDetectionCounter
 * \return        E_NOT_OK
 *                The combined FDC could not be determined.
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Data_CombinedGroupGetFDC(
  Dem_Cfg_CombinedGroupIndexType  GroupId,
  P2VAR(sint8, AUTOMATIC, DEM_APPL_DATA)  FaultDetectionCounter
  );
#endif

#if ((DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON) && (DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE == STD_ON))
/* ****************************************************************************
 * Dem_Data_CombinedGroupGetFDCMax
 *****************************************************************************/
/*!
 * \brief         Calculates the maximum fault detection counter this cycle of
 *                a combined event
 *
 * \details       This function iterates through all sub-events, and takes the
 *                largest maximum fault detection counter to represent the
 *                combined maximum FDC.
 *
 * \param[in]     GroupId
 *                Unique identifier of the combined event group
 * \param[out]    FaultDetectionCounter
 *                Pointer to receive the FDC value
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE for different events
 *****************************************************************************/
DEM_LOCAL FUNC(sint8, DEM_CODE)
Dem_Data_CombinedGroupGetFDCMax(
  Dem_Cfg_CombinedGroupIndexType  GroupId
  );
#endif

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 * Dem_Data_CombinedGroupGetStatus
 *****************************************************************************/
/*!
 * \brief         Gets the combined DTC status of a combined event
 *
 * \details       This calculates the logical OR of all subevent status bytes.
 *                Combined event status bytes only change on the main function,
 *                so no critical section is required from the main function.
 *
 * \param[in]     GroupId
 *                Unique identifier of the combined event group
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(uint8, DEM_CODE)
Dem_Data_CombinedGroupGetStatus(
  Dem_Cfg_CombinedGroupIndexType  GroupId
  );
#endif

#if ( (DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_OBDII == STD_ON) ||  (DEM_FEATURE_NEED_FREEZEFRAME_WWHOBD == STD_ON) )
/* ****************************************************************************
 * Dem_Data_CollectDid
 *****************************************************************************/
/*!
 * \brief         Collects the environment data to store for a data identifier
 *
 * \details       Stores all data elements attached to a data identifier object
 *                into the destination buffer.
 *                Note that a data identifier in this context is not only a
 *                UDS DID, but can also be an extended data record or PID.
 *
 * \param[in,out] CollectDidInfoPtr
 *                CollectDid context
 * \param[in]     DidIndex
 *                Unique handle of the DID
 *
 * \pre           -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Data_CollectDid(
  Dem_Data_CollectDidInfoPtrType  CollectDidInfoPtr,
  Dem_Cfg_DidIndexType  DidIndex
  );
#endif

#if (DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_OBDII == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_WWHOBD == STD_ON)
/* ****************************************************************************
 * Dem_Data_CopyDid
 *****************************************************************************/
/*!
 * \brief         Copies DID data into a buffer.
 *
 * \details       Copies all stored data elements attached to a data identifier
 *                object into the destination buffer, filling in internal data
 *                where needed.
 *                Note that a data identifier in this context is not only a
 *                UDS DID, but can also be an extended data record or PID.
 *
 * \param[in,out] CopyDidInfoStruct
 *                CopyDid context
 * \param[in]     DidIndex
 *                Unique handle of the DID
 *
 * \pre           A memory entry has to be locked for Dcm readout
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Data_CopyDid(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr,
  Dem_Cfg_DidIndexType  DidIndex
  );
#endif

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 * Dem_Nvm_SetBlockStateImmediate
 *****************************************************************************/
/*!
 * \brief         Marks a block as 'dirty' and commits it to nvm
 *
 * \details       This function processes the NV block according to BlockState:
 *                DEM_NVM_BLOCKSTATE_IMMEDIATEFLAG - The block is queued for
 *                immediate storage. This can still result in a write request
 *                on shutdown, if the occurrence counter of the block is too
 *                high.
 *                DEM_NVM_BLOCKSTATE_CLEARFLAG - The block was cleared. This
 *                will always queue the block for NV write, and also count the
 *                pending cleared blocks to support the Dcm clear command.
 *                DEM_NVM_BLOCKSTATE_DIRTY - The block is only marked for
 *                WriteAll
 *
 * \param[in]     MemoryIndex
 *                Memory entry index
 * \param[in]     BlockState
 *                State modification of the block
 *
 * \pre            -
 *
 * \context       TASK|ISR2
 * \synchronous   TRUE
 * \reentrant     TRUE for different blocks
 *****************************************************************************/
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Nvm_SetBlockStateImmediate(
  Dem_Cfg_MemoryIndexType  MemoryIndex,
  uint8  BlockState
  );
#endif

                                                            /* DCM Interface */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 * Dem_Dcm_ClearDtc_TestForAllDtc
 *****************************************************************************/
/*!
 * \brief         Test whether a DTC number encodes an 'AllDTC' mask
 *
 * \param[in]     DTC
 *                DTC number
 * \param[in,out] ClearRequest
 *                Clear request evaluation context
 *
 * \return        DEM_CLEAR_OK
 *                The DTC has matched this test.
 * \return        DEM_CLEAR_WRONG_DTC
 *                The DTC has not matched this test.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_TestForAllDtc(
  uint32  DTC,
  P2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest
  );

#if (DEM_CFG_CLEAR_GROUP_DTCS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_ClearDtc_TestForGroupDtc
 *****************************************************************************/
/*!
 * \brief         Test if a DTC number encodes a specific DTC group (not
 *                ALLDTCs)
 *
 * \param[in]     DTC
 *                DTC number
 * \param[in,out] ClearRequest
 *                Clear request evaluation context
 *
 * \return        DEM_CLEAR_OK
 *                The DTC has matched this test.
 * \return        DEM_CLEAR_WRONG_DTC
 *                The DTC has not matched this test.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_TestForGroupDtc(
  uint32  DTC,
  P2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest
  );
#endif

#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_ClearDtc_TestForSingleDtc
 *****************************************************************************/
/*!
 * \brief         Test if a DTC number encodes a specific DTC
 *
 * \param[in]     DTC
 *                DTC number
 * \param[in,out] ClearRequest
 *                Clear request evaluation context
 *
 * \return        DEM_CLEAR_OK
 *                The DTC has matched this test.
 * \return        DEM_CLEAR_WRONG_DTC
 *                The DTC has not matched this test.
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_TestForSingleDtc(
  uint32  DTC,
  P2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest
  );
#endif

/* ****************************************************************************
 * Dem_Dcm_ClearDtc_Internal
 *****************************************************************************/
/*!
 * \brief         Processes a clear request.
 *
 * \param[in]     DTC
 *                The DTC number
 * \param[in]     DTCFormat
 *                The DTC format
 * \param[in]     DTCOrigin
 *                External identifier of the event memory
 *
 * \return        DEM_CLEAR_OK
 *                Clearing is completed, the requested DTC(s) are reset.
 * \return        DEM_CLEAR_WRONG_DTC
 *                The requested DTC is not valid in the context of DTCFormat
 *                and DTCOrigin
 * \return        DEM_CLEAR_WRONG_DTCORIGIN
 *                The requested DTC origin is not available in the context of
 *                DTCFormat
 * \return        DEM_CLEAR_FAILED
 *                The clear operation could not be started
 * \return        DEM_CLEAR_MEMORY_ERROR
 *                The clear operation has completed, but the NV synchronization
 *                has failed
 * \return        DEM_CLEAR_PENDING
 *                The clear operation was started and is currently processed
 * \return        DEM_CLEAR_BUSY
 *                Another clear operation is currently processing
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_Internal(
  uint32  DTC,
  P2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest
  );

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_FilterNumberMemory
 *****************************************************************************/
/*!
 * \brief         Gets the number of filtered events for primary or secondary
 *                memory
 *
 * \return        Number of DTCs matching the filter criteria
 *
 * \pre           A Dcm filter has been set
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(uint16, DEM_CODE)
Dem_Dcm_FilterNumberMemory(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_FilterPrimaryByEvent
 *****************************************************************************/
/*!
 * \brief         Iterates events in primary memory matching the Dcm DTC filter
 *
 * \details       This function iterates all events in order of their event ID.
 *                Events which have been reported before by the chronological
 *                iterator will be ignored.
 *
 * \return        EventId of the next event maching the filter criteria
 *
 * \pre           A Dcm filter has been set
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FilterPrimaryByEvent(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_FEATURE_NEED_SECONDARY == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_FilterSecondaryByEvent
 *****************************************************************************/
/*!
 * \brief         Iterates events in secondary memory matching the Dcm DTC
 *                filter
 *
 * \details       This function iterates all events in order of their event ID.
 *                Events which have been reported before by the chronological
 *                iterator will be ignored.
 *
 * \return        EventId of the next event maching the filter criteria
 *
 * \pre           A Dcm filter has been set
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FilterSecondaryByEvent(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_FilterPrimaryChrono
 *****************************************************************************/
/*!
 * \brief         Iterates events in primary memory matching the Dcm DTC
 *                filter
 *
 * \details       This function iterates all events in order of occurrence.
 *                If all stored events have been checked, this function
 *                replaces the iterator function by the non-chronological
 *                version to also find the remaining events.
 *
 * \return        EventId of the next event maching the filter criteria
 *
 * \pre           A Dcm filter has been set
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FilterPrimaryChrono(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_FEATURE_NEED_SECONDARY == STD_ON) && (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_FilterSecondaryChrono
 *****************************************************************************/
/*!
 * \brief         Iterates events in secondary memory matching the Dcm DTC
 *                filter
 *
 * \details       This function iterates all events in order of occurrence.
 *                If all stored events have been checked, this function
 *                replaces the iterator function by the non-chronological
 *                version to also find the remaining events.
 *
 * \return        EventId of the next event maching the filter criteria
 *
 * \pre           A Dcm filter has been set
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FilterSecondaryChrono(
  void
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_FilterForEventMatch
 *****************************************************************************/
/*!
 * \brief         Checks whether an event matches the filter criteria
 *
 * \param[in]     EventId
 *                Unique handle of the Event
 *
 * \return        E_OK
 *                The event matches the filter criteria
 * \return        E_NOT_OK
 *                The event does not match the filter criteria
 *
 * \pre           A Dcm filter has been set
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     FALSE
 *****************************************************************************/
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Dcm_FilterForEventMatch(
  Dem_EventIdType  EventId
  );
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 * Dem_Dcm_FindEventByDTCAndOrigin
 *****************************************************************************/
/*!
 * \brief         Find the event attached to a given DTC in a specific event
 *                memory, and the memory id of the DTC origin requested
 *
 * \details       If the DTC number is found, and the attached event is mapped
 *                to the correct event memory, this function will set MemoryId
 *                to the corresponding handle.
 *                Otherwise, MemoryId will be set to DEM_CFG_MEMORYID_INVALID.
 *
 * \param[in]     DTC
 *                The DTC number
 * \param[in]     DTCOrigin
 *                The external identifier of the event memory
 * \param[out]    MemoryId
 *                Pointer receiving the internal memory Id
 *
 * \return        The event id of the event attached to DTC, if no such DTC
 *                exists (in the requested event memory) the function returns
 *                DEM_EVENT_INVALID
 *
 * \pre           -
 *
 * \context       TASK
 * \synchronous   TRUE
 * \reentrant     TRUE
 *****************************************************************************/
DEM_LOCAL FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FindEventByDTCAndOrigin(
  uint32 DTC,
  Dem_DTCOriginType  DTCOrigin,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC)  MemoryId
);
#endif

#define DEM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/* ********************************************************************************************************************
 *  Object definitions
 *********************************************************************************************************************/

                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_CONST_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#if (DEM_CFG_ISCONST_DESTINATION != STD_ON)
DEM_LOCAL CONST(Dem_Mem_MemoryInfoType, DEM_CONST) Dem_Mem_PrimaryInfo =
{
  &Dem_Cfg_PrimaryChronology[0],
  &Dem_Mem_PrimaryCurrentCount,
  Dem_Cfg_MemoryPrimaryIndex(),
  Dem_Cfg_GlobalPrimaryFirst(),
  Dem_Cfg_GlobalPrimaryLast(),
  Dem_Cfg_GlobalPrimarySize(),
  DEM_CFG_MEMORYID_PRIMARY
};

# if (DEM_FEATURE_NEED_SECONDARY == STD_ON)
DEM_LOCAL CONST(Dem_Mem_MemoryInfoType, DEM_CONST) Dem_Mem_SecondaryInfo =
{
  &Dem_Cfg_SecondaryChronology[0],
  &Dem_Mem_SecondaryCurrentCount,
  Dem_Cfg_MemorySecondaryIndex(),
  Dem_Cfg_GlobalSecondaryFirst(),
  Dem_Cfg_GlobalSecondaryLast(),
  Dem_Cfg_GlobalSecondarySize(),
  DEM_CFG_MEMORYID_SECONDARY
};
# endif
#endif

#define DEM_STOP_SEC_CONST_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_CONST_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

DEM_LOCAL CONST(Dem_DebounceFunctionTableType, DEM_CONST) Dem_Esm_DebounceFunctionTable[3] =                                     /* PRQA S 3218 */ /* MD_DEM_8.7 */
{
#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
  {
    Dem_Esm_CounterBasedCalculate,
    Dem_Esm_CounterBasedValidate,
    Dem_Esm_CounterBasedCommit,
    Dem_Esm_CounterBasedFreeze,
    Dem_Esm_CounterBasedReset
  },
#else
  {
    Dem_Esm_DebounceInvalidCalculate,
    Dem_Esm_DebounceInvalidBoolean,
    Dem_Esm_DebounceInvalidVoid,
    Dem_Esm_DebounceInvalidVoid,
    Dem_Esm_DebounceInvalidVoid
  },
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
  {
    Dem_Esm_TimeBasedCalculate,
    Dem_Esm_TimeBasedValidate,
    Dem_Esm_TimeBasedCommit,
    Dem_Esm_TimeBasedFreeze,
    Dem_Esm_TimeBasedReset
  },
#else
  {
    Dem_Esm_DebounceInvalidCalculate,
    Dem_Esm_DebounceInvalidBoolean,
    Dem_Esm_DebounceInvalidVoid,
    Dem_Esm_DebounceInvalidVoid,
    Dem_Esm_DebounceInvalidVoid
  },
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
  {
    Dem_Esm_MonitorInternalCalculate,
    Dem_Esm_DebounceNoOpBoolean,
    Dem_Esm_DebounceNoOpVoid,
    Dem_Esm_DebounceNoOpVoid,
    Dem_Esm_DebounceNoOpVoid
  },
#else
  {
    Dem_Esm_DebounceInvalidCalculate,
    Dem_Esm_DebounceInvalidBoolean,
    Dem_Esm_DebounceInvalidVoid,
    Dem_Esm_DebounceInvalidVoid,
    Dem_Esm_DebounceInvalidVoid
  },
#endif
};

#define DEM_STOP_SEC_CONST_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                                            /* DCM Interface */
/* ------------------------------------------------------------------------- */

#define DEM_START_SEC_CONST_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

DEM_LOCAL CONST(uint8, DEM_CONST) Dem_Dcm_MemoryIdMapping[5] =                                                                   /* PRQA S 3218 */ /* MD_DEM_8.7 */
{
  /* 0: Invalid */
  DEM_CFG_MEMORYID_INVALID,
  /* DEM_DTC_ORIGIN_PRIMARY_MEMORY */
  DEM_CFG_MEMORYID_PRIMARY,
  /* DEM_DTC_ORIGIN_MIRROR_MEMORY */
  DEM_CFG_MEMORYID_MIRROR,
  /* DEM_DTC_ORIGIN_PERMANENT_MEMORY */
  DEM_CFG_MEMORYID_PERMANENT,
  /* DEM_DTC_ORIGIN_SECONDARY_MEMORY */
  DEM_CFG_MEMORYID_SECONDARY
};

#define DEM_STOP_SEC_CONST_8BIT
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

#define DEM_START_SEC_CONST_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

DEM_LOCAL CONST(Dem_Dcm_ClearDtc_TestFuncPtrType, DEM_CONST) Dem_Dcm_ClearDtc_TestObd[] =
{
  NULL_PTR
};

DEM_LOCAL CONST(Dem_Dcm_ClearDtc_TestFuncPtrType, DEM_CONST) Dem_Dcm_ClearDtc_TestUds[] =
{
#if (DEM_CFG_CLEAR_ALL_DTCS == STD_ON)
  Dem_Dcm_ClearDtc_TestForAllDtc,
#endif
#if (DEM_CFG_CLEAR_GROUP_DTCS == STD_ON)
  Dem_Dcm_ClearDtc_TestForGroupDtc,
#endif
#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
  Dem_Dcm_ClearDtc_TestForSingleDtc,
#endif
  NULL_PTR
};

DEM_LOCAL CONST(Dem_Dcm_ClearDtc_TestFuncPtrType, DEM_CONST) Dem_Dcm_ClearDtc_TestJ1939[] =
{
  NULL_PTR
};

DEM_LOCAL CONST(Dem_Dcm_ClearDtc_TestFuncPtrType, DEM_CONST) Dem_Dcm_ClearDtc_TestFail[] =                                       /* PRQA S 3218 */ /* MD_DEM_8.7 */
{
  NULL_PTR
};

DEM_LOCAL CONST(Dem_Dcm_ClearDtc_TestPtrType, DEM_CONST) Dem_Dcm_ClearDtc_TestPrimary[3] =                                       /* PRQA S 3218 */ /* MD_DEM_8.7 */
{
  /* DEM_DTC_FORMAT_OBD */
  Dem_Dcm_ClearDtc_TestObd,
  /* DEM_DTC_FORMAT_UDS */
  Dem_Dcm_ClearDtc_TestUds,
  /* DEM_DTC_FORMAT_J1939 */
  Dem_Dcm_ClearDtc_TestJ1939
};

#if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
DEM_LOCAL CONST(Dem_Dcm_ClearDtc_TestPtrType, DEM_CONST) Dem_Dcm_ClearDtc_TestSecondary[3] =                                     /* PRQA S 3218 */ /* MD_DEM_8.7 */
{
  /* DEM_DTC_FORMAT_OBD */
  Dem_Dcm_ClearDtc_TestFail,
  /* DEM_DTC_FORMAT_UDS */
  Dem_Dcm_ClearDtc_TestUds,
  /* DEM_DTC_FORMAT_J1939 */
  Dem_Dcm_ClearDtc_TestFail,
};
#endif

#define DEM_STOP_SEC_CONST_UNSPECIFIED
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/* ********************************************************************************************************************
 *  LOCAL INLINE FUNCTION DEFINITIONS
 *********************************************************************************************************************/

#define DEM_START_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                                                /* Utilities */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_NOTIFY_CLEAR_ALLOWED == STD_ON)
/* ****************************************************************************
 % Dem_Util_CallClearEventAllowed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Util_CallClearEventAllowed(
  Dem_EventIdType  EventId
  )
{
  boolean lClearAllowed;
  Dem_ClearEventAllowedFPtrType lpClearAllowedFunc;

  lClearAllowed = TRUE;
  lpClearAllowedFunc = Dem_Cfg_EventCbkClearAllowed(EventId);
  if (NULL_PTR != lpClearAllowedFunc)
  {
    if (E_OK != (*lpClearAllowedFunc)(&lClearAllowed))
    { /* Make sure a failed call does not influence lDoClear */
      lClearAllowed = TRUE;
    }
  }
  return lClearAllowed;
}
#endif

#if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON)
/* ****************************************************************************
 % Dem_Util_DtcApplyUserControlledWIR
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
#if (DEM_ESM_USER_CONTROLLED_WIR != 0x80U)
# error "Bit definition is no longer working for Dem_Util_DtcApplyUserControlledWIR"
#endif

DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Util_DtcApplyUserControlledWIR(
  uint8 DtcStatus,
  Dem_Cfg_EventInternalStatusType InternalStatus
  )
{
  /* #10 Logical OR a latched WIR bit onto the event status byte */
  return ((uint8)((DtcStatus) | ((InternalStatus) & DEM_ESM_USER_CONTROLLED_WIR)));
}
#endif

#if ( (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON) \
   || (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON) \
   || (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON) \
   || (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON) )
/* ****************************************************************************
 % Dem_Util_DtcApplyCombinedStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Util_DtcApplyCombinedStatus(
  uint8  DtcStatus
  )
{
  uint8 lReturnValue;
  lReturnValue = DtcStatus;
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  if (FALSE != DEM_ESM_TEST_UDS_STATUS_TFSLC(lReturnValue))
  {
    lReturnValue = DEM_ESM_RESET_UDS_STATUS_TNCSLC(lReturnValue);
  }
  if (FALSE != DEM_ESM_TEST_UDS_STATUS_TFTOC(lReturnValue))
  {
    lReturnValue = DEM_ESM_RESET_UDS_STATUS_TNCTOC(lReturnValue);
  }
# endif
  return lReturnValue;
}
#endif

#if ( (DEM_CFG_SUPPORT_DCM == STD_ON) \
   || (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON) \
   || (DEM_FEATURE_NEED_NOTIFY_DATA == STD_ON) \
   )
/* ****************************************************************************
 % Dem_Util_DtcApplyExternalOnlyStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Util_DtcApplyExternalOnlyStatus(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  uint8  DtcStatus
  )
{
  uint8 lReturnValue;
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
# endif

  DEM_IGNORE_UNUSED_ARGUMENT(EventId)                                                                                            /* PRQA S 3112 */ /* MD_DEM_14.2 */

  lReturnValue = DtcStatus;

# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  /* #010 In configurations supporting combined events: If EventId is a combined event*/
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
#  if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) 
#   if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON)
    boolean lWirActive = FALSE;
#   endif
    /* #030 Look through all sub-events */
    Dem_Cfg_CombinedGroupIterType lCombinedIter;

    for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lCombinedIter);                                                                /* PRQA S 3198, 3418 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
         (FALSE != Dem_Cfg_CombinedGroupIterExists(lGroupId, &lCombinedIter));
         Dem_Cfg_CombinedGroupIterNext(lGroupId, &lCombinedIter))
    {
      Dem_EventIdType lSubEventId;

      lSubEventId = Dem_Cfg_CombinedGroupIterGet(lGroupId, &lCombinedIter);
      /* #040 Skip sub-events that are disconnected by postbuild or runtime configuration */
#   if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
      if (FALSE != Dem_Cfg_EventAvailableInVariant(lSubEventId))
#   endif
      {
#   if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
        if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(lSubEventId)))
#   endif
        {
#   if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON)
          /* #060 In configurations using latched WIR: Test if at least one sub-event latches the WIR bit */
          lWirActive = (boolean)(lWirActive || (FALSE != DEM_ESM_TEST_USER_CONTROLLED_WIR(Dem_Mem_EventGetInternalStatus(lSubEventId))));
#   endif
        }
      }
    }
#   if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON)
    /* #080 In configuration using latched WIR: Set the WIR bit of the DTC status if a sub-event latches it */
    if (FALSE != lWirActive)
    {
      lReturnValue = DEM_ESM_SET_UDS_STATUS_WIR(lReturnValue);
    }
#   endif
#  endif
    /* #090 Apply the combined event correction to the DTC status */
    lReturnValue = Dem_Util_DtcApplyCombinedStatus(lReturnValue);
  }
  else
# endif
  { /* #100 If EventId is not a combined event */
# if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON)
    /* #120 In configurations using latched WIR: Set the WIR bit if it was latched for the event */
    lReturnValue = (uint8)(Dem_Util_DtcApplyUserControlledWIR(lReturnValue, Dem_Mem_EventGetInternalStatus(EventId)));
# endif
  }
  return lReturnValue;
}
#endif /* complicated condition */

/* ****************************************************************************
 % Dem_Util_DtcGetInternalStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_EventInternalStatusType, DEM_CODE)
Dem_Util_DtcGetInternalStatus(
  Dem_EventIdType EventId
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    lInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);
  }
  else
#endif
  {
    lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
  }
  return lInternalStatus;
}

/* ****************************************************************************
 % Dem_Util_DtcSetInternalStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Util_DtcSetInternalStatus(
  Dem_EventIdType EventId,
  Dem_Cfg_EventInternalStatusType InternalStatus
  )
{
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, InternalStatus);
  }
  else
#endif
  {
    Dem_Mem_EventSetInternalStatus(EventId, InternalStatus);
  }
}

/* ****************************************************************************
 % Dem_Util_DtcGetStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Util_DtcGetStatus(
  Dem_EventIdType  EventId
  )
{
  uint8 lEventStatus;
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    lEventStatus = Dem_Mem_CombinedGroupGetStatus(lGroupId);
  }
  else
#endif
  {
    lEventStatus = Dem_Mem_EventGetStatus(EventId);
  }
  return lEventStatus;
}

#if ( (DEM_CFG_SUPPORT_DCM == STD_ON) \
  || (DEM_CFG_DATA_CURRENT_FDC == STD_ON) )
/* ****************************************************************************
 % Dem_Util_DtcGetFaultDetectionCounter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Util_DtcGetFaultDetectionCounter(
  Dem_EventIdType  EventId,
  P2VAR(sint8, AUTOMATIC, DEM_APPL_DATA)  FaultDetectionCounter
  )
{
  Std_ReturnType lGetFdcReturnValue;
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    lGetFdcReturnValue = Dem_Data_CombinedGroupGetFDC(lGroupId, FaultDetectionCounter);
  }
  else
# endif
  {
    lGetFdcReturnValue = Dem_GetFaultDetectionCounter(EventId, FaultDetectionCounter);
  }

  return lGetFdcReturnValue;
}
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) || (DEM_CFG_DATA_CURRENT_FDC == STD_ON) */

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 % Dem_Util_CombinedGroupGetEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Util_CombinedGroupGetEvent(
  Dem_Cfg_CombinedGroupIndexType  GroupId                                                                                        /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  Dem_Cfg_CombinedGroupIterType lGroupIter;

  /* In rare cases GroupId is not required */
  DEM_IGNORE_UNUSED_ARGUMENT(GroupId)                                                                                            /* PRQA S 3112 */ /* MD_DEM_14.2 */

  Dem_Cfg_CombinedGroupIterInit(GroupId, &lGroupIter);                                                                           /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
  return Dem_Cfg_CombinedGroupIterGet(GroupId, &lGroupIter);
}
#endif

#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
/* ****************************************************************************
 % Dem_Util_DtcAvailableInVariant
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Util_DtcAvailableInVariant(
  Dem_EventIdType EventId
  )
{
  boolean lReturnValue;
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;

  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    lReturnValue = (boolean)DEM_ESM_TEST_AVAILABLEINVARIANT(Dem_Mem_CombinedGroupGetInternalStatus(lGroupId));
  }
  else
# endif
  {
    lReturnValue = Dem_Cfg_EventAvailableInVariant(EventId);
  }

  return lReturnValue;
}
#endif

/* ****************************************************************************
 % Dem_Util_DtcGetMasterEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Util_DtcGetMasterEvent(
  Dem_EventIdType  EventId
  )
{
  Dem_EventIdType  lMasterEventId;

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;

  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    lMasterEventId = Dem_Util_CombinedGroupGetEvent(lGroupId);
  }
  else
#endif
  {
    lMasterEventId = EventId;
  }

  return lMasterEventId;
}

/* ****************************************************************************
 % Dem_Util_ForEachCombinedEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Util_ForEachCombinedEvent(
  Dem_EventIdType  EventId,
  Dem_Util_ForEachCombinedFuncType  FuncPtr,
  Dem_Util_ForEachCombinedArgPtrType  ArgPtr
  )
{
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;

  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    /* #010 In configurations supporting combined events: If EventId is a combined event */
    uint8 lDtcStatus;
    Dem_Cfg_CombinedGroupIterType lCombinedIter;
    Dem_EventIdType lSubEventId;

    lDtcStatus = 0; /* neutral value */

    /* #020 Return the current combined event status in Common.OldDtcStatus */
    ArgPtr->Common.OldDtcStatus = Dem_Mem_CombinedGroupGetStatus(lGroupId);

    /* #030 Iterate through all sub-events */
    for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lCombinedIter);                                                                /* PRQA S 3198, 3418 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
         (FALSE != Dem_Cfg_CombinedGroupIterExists(lGroupId, &lCombinedIter));
         Dem_Cfg_CombinedGroupIterNext(lGroupId, &lCombinedIter))
    {
      lSubEventId = Dem_Cfg_CombinedGroupIterGet(lGroupId, &lCombinedIter);

      /* #040 Skip sub-events that are disconnected by postbuild or runtime configuration */
# if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
      if (FALSE != Dem_Cfg_EventAvailableInVariant(lSubEventId))
# endif
      {
# if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
        if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(lSubEventId)))
# endif
        {
          /* #050 Call the passed operation function pointer for the current sub-event */
          (*FuncPtr)(lSubEventId, ArgPtr);
          /* #060 Build a new combined event status by ORing the status bits or all sub-events */
          lDtcStatus = (uint8)(lDtcStatus | Dem_Mem_EventGetStatus(lSubEventId));
        }
      }
    }
    Dem_Mem_CombinedGroupSetStatus(lGroupId, lDtcStatus);

    /* #070 Return the new combined event status in Common.NewDtcStatus */
    ArgPtr->Common.NewDtcStatus = lDtcStatus;
  }
  else
#endif
  {
    /* #080 If EventId is not combined event */

    /* #090 Return the current event status in Common.OldDtcStatus */
    ArgPtr->Common.OldDtcStatus = Dem_Mem_EventGetStatus(EventId);
    /* #100 Call the passed operation function pointer for EventId */
    (*FuncPtr)(EventId, ArgPtr);
    /* #110 Return the new event status in Common.NewDtcStatus */
    ArgPtr->Common.NewDtcStatus = Dem_Mem_EventGetStatus(EventId);
  }
}
                                                      /* Queue Setter/Getter */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Queue_GetPendingCycle
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Queue_GetPendingCycle(
  uint8  CycleId
  )
{
  return (boolean)(((Dem_Queue_CycleState & (uint16)(1U << CycleId)) != 0U)
                     ? DEM_QUEUE_CYCLE_STARTED
                     : DEM_QUEUE_CYCLE_STOPPED);
}

/* ****************************************************************************
 % Dem_Queue_SetPendingCycle
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_SetPendingCycle(
  uint8  CycleId,
  uint8  Status
  )
{
  uint16 lMask = (uint16)(1U << CycleId);

  Dem_Queue_CycleFlag = (uint16)(Dem_Queue_CycleFlag | lMask);

  if (DEM_QUEUE_CYCLE_STOPPED == Status)
  { /* #010 DEM_QUEUE_CYCLE_STOPPED - Reset the state bit of the given cycle */
    Dem_Queue_CycleState = (uint16)(Dem_Queue_CycleState & ((uint16)~lMask));
  }
  else
  { /* #020 DEM_QUEUE_CYCLE_STARTED - Set the state bit of the given cycle */
    Dem_Queue_CycleState = (uint16)(Dem_Queue_CycleState | lMask);
  }
}

/* ****************************************************************************
 % Dem_Queue_SetPendingEvent_Enqueue
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Queue_SetPendingEvent_Enqueue(
  Dem_EventIdType  EventId
  )
{
  uint8 lQueueStatus;

  lQueueStatus = Dem_Queue_GetEventStatus(EventId);

  if (DEM_QUEUE_EVENT_NONE == DEM_QUEUE_GET_QUEUESTATE(lQueueStatus))
  { /* Event not queued yet, enter in queue if possible and set pending actions */
#if (DEM_CFG_SUPPORT_EVENT_QUEUE == STD_ON)
    uint8 lQueueWriteIndex = Dem_Queue_EventWriteIndex;

    if ( (Dem_Queue_EventReadIndex != lQueueWriteIndex)                                                                          /* PRQA S 3415 */ /* MD_DEM_12.4_cs */
      || (Dem_Queue_EventCount == 0U) )                                                                                          /* PRQA S 3415 */ /* MD_DEM_12.4_cs */
    {
      Dem_Cfg_EventQueue[lQueueWriteIndex] = EventId;
      Dem_WrappingIncrement(lQueueWriteIndex, Dem_Cfg_GlobalQueueSize())
      Dem_Queue_EventWriteIndex = lQueueWriteIndex;
      lQueueStatus = DEM_QUEUE_SET_QUEUESTATE(lQueueStatus, DEM_QUEUE_EVENT_QUEUED);
    }
    else
#endif
    {
      lQueueStatus = DEM_QUEUE_SET_QUEUESTATE(lQueueStatus, DEM_QUEUE_EVENT_PENDING);
    }
    ++Dem_Queue_EventCount;
  }

  return lQueueStatus;
}

/* ****************************************************************************
 % Dem_Queue_SetPendingEvent_Queued
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Queue_SetPendingEvent_Queued(
  Dem_EventIdType  EventId,
  uint8  MonitorStatus
  )
{
  Std_ReturnType lReturnValue;
  uint8 lQueueStatus;

  lQueueStatus = Dem_Queue_SetPendingEvent_Enqueue(EventId);

  if (MonitorStatus == DEM_EVENT_STATUS_FAILED)
  {
    switch (DEM_QUEUE_GET_QUEUEACTION(lQueueStatus))
    {
    case 0:
      lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 5);
      lReturnValue = E_OK;
      break;
    case 1:
    case 6:
      ++lQueueStatus;
      lReturnValue = E_OK;
      break;
    case 2:
    case 5:
    case 7:
      lReturnValue = E_OK;
      break;
    default:
      lReturnValue = E_NOT_OK;
      break;
    }
  }
  else if (MonitorStatus == DEM_EVENT_STATUS_PASSED)
  {
    switch (DEM_QUEUE_GET_QUEUEACTION(lQueueStatus))
    {
    case 0:
      lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 1);
      lReturnValue = E_OK;
      break;
    case 2:
    case 5:
      ++lQueueStatus;
      lReturnValue = E_OK;
      break;
    case 1:
    case 3:
    case 6:
      lReturnValue = E_OK;
      break;
    default:
      lReturnValue = E_NOT_OK;
      break;
    }
  }
  else
  {
    /* Not a qualified result */
    lReturnValue = E_OK;
  }
  Dem_Queue_SetEventStatus(EventId, lQueueStatus);

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030 */ /* MD_MSR_STCYC */

/* ****************************************************************************
 % Dem_Queue_SetPendingEvent_Immediate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Queue_SetPendingEvent_Immediate(
  Dem_EventIdType  EventId,
  uint8  MonitorResult,
  uint8  EventStatus
  )
{
  Std_ReturnType lReturnValue;
  uint8 lQueueStatus;

  lReturnValue = E_OK;
  lQueueStatus = Dem_Queue_SetPendingEvent_Enqueue(EventId);

  switch (DEM_QUEUE_GET_QUEUEACTION(lQueueStatus))
  {
  case 0:
#if (DEM_CFG_SUPPORT_RETRY_STORAGE == STD_ON)
  case 22:
#endif
    if (MonitorResult == DEM_EVENT_STATUS_FAILED)
    {
      /* #020 With trigger 'TestFailed' enter next state according to the transition table */
      switch (EventStatus & (DEM_UDS_STATUS_TF | DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_TNCTOC))
      {
      case DEM_UDS_STATUS_TNCTOC:
      case DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_TNCTOC:
        lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 1);
        break;

      case DEM_UDS_STATUS_TFTOC:
        lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 7);
        break;

      case DEM_UDS_STATUS_TF:
      case DEM_UDS_STATUS_TF | DEM_UDS_STATUS_TNCTOC:
      case DEM_UDS_STATUS_TF | DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_TNCTOC:
        lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 10);
        break;

      case 0:
        lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 4);
        break;

#if (DEM_CFG_SUPPORT_RETRY_STORAGE == STD_ON)
      case DEM_UDS_STATUS_TF | DEM_UDS_STATUS_TFTOC:
        lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 22);
        break;
#endif

      default:
        break;
      }
    }
    else
    if (MonitorResult == DEM_EVENT_STATUS_PASSED)
    {
      /* #030 With trigger 'TestPassed' enter next state according to the transition table */
      switch (EventStatus & (DEM_UDS_STATUS_TF | DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_TNCTOC))
      {
      case DEM_UDS_STATUS_TF:
      case DEM_UDS_STATUS_TF | DEM_UDS_STATUS_TNCTOC:
      case DEM_UDS_STATUS_TF | DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_TNCTOC:
        lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 13);
        break;

      case DEM_UDS_STATUS_TF | DEM_UDS_STATUS_TFTOC:
        lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 16);
        break;

      case DEM_UDS_STATUS_TNCTOC:
      case DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_TNCTOC:
        lQueueStatus = DEM_QUEUE_SET_QUEUEACTION(lQueueStatus, 19);
        break;

      default:
        break;
      }
    }
    else
    {
      /* No state change on unqualified results */
    }
    break;

  case 1:
  case 4:
  case 7:
  case 10:
  case 14:
  case 17:
  case 20:
    /* #040 In states 1,4,7,10,14,17,20 trigger 'TestPassed' transitions to next state. */
    if (MonitorResult == DEM_EVENT_STATUS_PASSED)
    {
      ++lQueueStatus;
    }
    break;

  case 2:
  case 5:
  case 8:
  case 11:
  case 13:
  case 16:
  case 19:
    /* #050 In states 2,5,8,11,13,16,19 trigger 'TestFailed' transitions to next state,  Do not queue a
            TestFailed result after a qualified passed for events with aging target 0. */
    if (MonitorResult == DEM_EVENT_STATUS_FAILED)
    {
#if (DEM_FEATURE_NEED_AGING_AGE == STD_ON)
# if (DEM_FEATURE_NEED_AGING_IMMEDIATE == STD_ON)
#  if (DEM_CFG_ISCONST_AGINGTARGET != STD_ON)
      if (Dem_Cfg_EventAgingTarget(EventId) == 0)
#  endif
      {
        lReturnValue = E_NOT_OK;
      }
# endif
#  if (DEM_CFG_ISCONST_AGINGTARGET != STD_ON)
      else
# endif
# if (DEM_FEATURE_NEED_AGING_DELAYED == STD_ON)
      {
        ++lQueueStatus;
      }
# endif
#else
      ++lQueueStatus;
#endif
    }
    break;

  case 3:
  case 6:
  case 9:
  case 12:
    /* #060 In states 3,6,9,12 trigger 'TestPassed' results in queue overflow */
    if (MonitorResult == DEM_EVENT_STATUS_PASSED)
    {
      lReturnValue = E_NOT_OK;
    }
    break;

  case 15:
  case 18:
  case 21:
    /* #070 In states 15,18,21 trigger 'TestFailed' results in queue overflow */
    if (MonitorResult == DEM_EVENT_STATUS_FAILED)
    {
      lReturnValue = E_NOT_OK;
    }
    break;

  default:
    lReturnValue = E_NOT_OK;
    break;
  }

  Dem_Queue_SetEventStatus(EventId, lQueueStatus);

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030 */ /* MD_MSR_STCYC */

/* ****************************************************************************
 % Dem_Queue_ResetPendingEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ResetPendingEvent(
  Dem_EventIdType  EventId
  )
{
  uint8 lQueueStatus;

  lQueueStatus = Dem_Queue_GetEventStatus(EventId);

  /* #010 Clear the events queued actions */
  Dem_Queue_SetEventStatus(EventId, (uint8)(lQueueStatus & DEM_QUEUE_EVENT_QUEUED));
}

                                                        /* Data Provisioning */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % update global statistics
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_EventFailed(
  Dem_EventIdType  EventId,
  uint8  Effects
  )
{
  /* #010 If the event is allocated to the primary memory */
  if ( (Dem_Cfg_GlobalPrimaryFirst() <= EventId)
#if (DEM_FEATURE_NEED_SECONDARY == STD_ON)
    /* conditionally excluded due to 'comparison is always true' compiler warning */
    && (Dem_Cfg_GlobalPrimaryLast() >= EventId)
#endif
    )
  {
    /* #020 If the event was confirmed */
    if (0 != (Effects & DEM_CFG_TRIGGER_CONFIRMED))
    {
      /* #030 If the FirstConfirmed event is not yet set, set the new event as FirstConfirmed */
      if ( DEM_EVENT_INVALID == Dem_Mem_GetFirstConfirmedEvent() )
      {
        Dem_Mem_SetFirstConfirmedEvent(EventId);
      }

      /* #040 Update the MostRecentConfirmed event */
      Dem_Mem_SetMostRecentConfmdEvent(EventId);
    }

    /* #050 If the FirstFailed event is not yet set, set the new event as FirstFailed */
    if (DEM_EVENT_INVALID == Dem_Mem_GetFirstFailedEvent())
    {
      Dem_Mem_SetFirstFailedEvent(EventId);
    }
    /* #060 Update the MostRecentFailed event */
    Dem_Mem_SetMostRecentFailedEvent(EventId);
  }
}

                                                            /* Notifications */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
/* ****************************************************************************
 % Dem_Cbk_DtcStatusChanged
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Cbk_DtcStatusChanged(
  Dem_EventIdType  EventId,
  Dem_EventStatusExtendedType  EventStatusOld,
  Dem_EventStatusExtendedType  EventStatusNew
  )
{
  Dem_Cbk_DtcStatusChanged_Internal(
    EventId,
    Dem_Util_DtcApplyExternalOnlyStatus(EventId, EventStatusOld),
    Dem_Util_DtcApplyExternalOnlyStatus(EventId, EventStatusNew)
  );
}
#endif /* (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON) */

#if (DEM_FEATURE_NEED_NOTIFY_DATA == STD_ON)
/* ****************************************************************************
 % Dem_Cbk_EventDataChanged
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Cbk_EventDataChanged(
  Dem_EventIdType  EventId
  )
{
# if (DEM_CFG_NOTIFY_EVENT_DATA == STD_ON)
  /* #010 If an 'event data changed' callback is configured, call it. */
  {
    Dem_EventDataChangedFPtrType lpEventDataChangedFunc;

    lpEventDataChangedFunc = Dem_Cfg_EventCbkData(EventId);

    if (NULL_PTR != lpEventDataChangedFunc)
    {
      (void)(*lpEventDataChangedFunc)();
    }
  }
# endif

# if (DEM_CFG_NOTIFY_GENERAL_DATA == STD_ON)
  /* #020 If a global 'event data changed' callback is configured, call it. */
  (void)Dem_Cfg_GlobalCbkData(EventId);                                                                                         /* PRQA S 3423 */ /* MD_DEM_3423 */
# endif
}
#endif

#if (DEM_CFG_NOTIFY_INIT_MONITOR == STD_ON)
/* ****************************************************************************
 % Dem_Cbk_InitMonitorForEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Cbk_InitMonitorForEvent(
  Dem_EventIdType  EventId,
  Dem_InitMonitorReasonType  InitReason
  )
{
  /* #010 If an 'init monitor for event' callback is configured, call it. */
  Dem_InitMonitorForEventFPtrType lpInitMonitorForEventFunc;

  lpInitMonitorForEventFunc = Dem_Cfg_EventCbkInitMonitor(EventId);

  if (NULL_PTR != lpInitMonitorForEventFunc)
  {
    (void)(*lpInitMonitorForEventFunc)(InitReason);
  }
}
#endif /* DEM_CFG_NOTIFY_INIT_MONITOR */

#if (DEM_CFG_NOTIFY_INIT_FUNC == STD_ON)
/* ****************************************************************************
 % Dem_Cbk_InitMonitorForFunction
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Cbk_InitMonitorForFunction(
  Dem_EventIdType  EventId
  )
{
  Dem_Cfg_EventCbkInitFuncIterType lIter;
  Dem_Cfg_EventCbkInitFuncIterInit(EventId, &lIter);                                                                             /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */

  while (FALSE != Dem_Cfg_EventCbkInitFuncIterExists(EventId, &lIter))
  {
    Dem_InitMonitorForFuncFPtrType lpInitMonitorForFunc;

    lpInitMonitorForFunc = Dem_Cfg_EventCbkInitFuncIterGet(EventId, &lIter);

    (void)(*lpInitMonitorForFunc)();

    Dem_Cfg_EventCbkInitFuncIterNext(EventId, &lIter);
  }
}
#endif /* DEM_CFG_NOTIFY_INIT_FUNC */

                                                        /* Data Provisioning */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Data_EntryInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_EntryInit(
  Dem_Mem_EntryPtrType  MemoryEntry                                                                                              /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_ARGUMENT(MemoryEntry)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */

#if (DEM_FEATURE_NEED_OCC_COUNTER == STD_ON)
  Dem_Mem_EntrySetOccurrenceCount(MemoryEntry, DEM_DATA_OCCURRENCE_INIT);
#endif

  Dem_Mem_EntrySetAgingCount(MemoryEntry, DEM_ESM_CYCLECOUNT_INVALID);
#if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
  MemoryEntry->ExtendedHeader = 0;
#endif
#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
  MemoryEntry->SnapshotHeader = 0;
#endif
#if (DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE == STD_ON)
  Dem_Mem_EntrySetDebounceValueMax(MemoryEntry, 0);
#endif
#if (DEM_CFG_DATA_FAILED_CYCLES == STD_ON)
  Dem_Mem_EntrySetFailedCycleCount(MemoryEntry, 0);
#endif
#if (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
  Dem_Mem_EntrySetConsecutiveFailedCycleCount(MemoryEntry, 0);
#endif
#if (DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON)
  Dem_Mem_EntrySetFirstFailedCycleCount(MemoryEntry, DEM_ESM_CYCLECOUNT_INVALID);
#endif
#if (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON)
  Dem_Mem_EntrySetLastFailedCycleCount(MemoryEntry, DEM_ESM_CYCLECOUNT_INVALID);
#endif
#if (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON)
  Dem_Mem_EntrySetTestedSinceFirstFailedCycleCount(MemoryEntry, 0);
#endif
#if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON) || (DEM_FEATURE_NEED_OBD == STD_ON)
  Dem_Mem_EntrySetState(MemoryEntry, 0);
#endif
}

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 % Dem_Data_CollectSnapshot
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_CollectSnapshot(
  Dem_EventIdType  EventId,
  Dem_SharedDataPtrType  DestinationBuffer
  )
{
  Dem_Data_CollectDidInfoType lCollectDidInfo;
  Dem_Cfg_EventDidIterType lDidIter;

  /* #010 Initialize collection context */
  lCollectDidInfo.EventId = EventId;
  lCollectDidInfo.DestinationBuffer = DestinationBuffer;
  Dem_Cfg_EventDidIterInit(EventId, &lDidIter);                                                                                  /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */

  /* #020 Collect each DID configured for the given event */
  while (FALSE != Dem_Cfg_EventDidIterExists(EventId, &lDidIter))
  {
    Dem_Cfg_DidIndexType lDidIndex;

    lDidIndex = Dem_Cfg_EventDidIterGet(EventId, &lDidIter);
    Dem_Cfg_EventDidIterNext(EventId, &lDidIter);

    Dem_Data_CollectDid(&lCollectDidInfo, lDidIndex);
  }
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Data_PrestorageApplySRec
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_PrestorageApplySRec(
  Dem_EventIdType  EventId,
  Dem_SharedDataPtrType  DestinationBuffer
  )
{
  boolean lReturnValue;

  if (DEM_MEM_INVALID_PRESTORAGE_INDEX != Dem_Esm_PrestorageLockedIndex)
  {
    Dem_Mem_PrestoredEntryPtrType lPrestoredEntry;
    lPrestoredEntry = Dem_Mem_PrestorageGetEntry(Dem_Esm_PrestorageLockedIndex);

    Dem_MemCpy(DestinationBuffer,                                                                                                /* PRQA S 0310, 0602 */ /* MD_DEM_11.4_cpy, MD_DEM_20.2 */
               &lPrestoredEntry->SnapshotData[0],
               Dem_Cfg_EventSRecRawSize(EventId));

    lReturnValue = TRUE;
  }
  else
  {
    lReturnValue = FALSE;
  }
  return lReturnValue;
}
#endif

#if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
/* ****************************************************************************
 % Dem_Data_EntryUpdate_UserERecs
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_EntryUpdate_UserERecs(
  Dem_EventIdType  EventId,
  Dem_Mem_EntryPtrType  MemoryEntry
  )
{
  boolean lReturnValue;
  uint8 lValidMask;
  uint8 lBufferIndex;
  Dem_Cfg_EventERecIterType lIterator;
  Dem_Data_CollectDidInfoType lCollectDidInfo;

  lReturnValue = FALSE;
  lValidMask = 0x01U;

  /* #010 Initialize collection context */
  lCollectDidInfo.EventId = EventId;

  Dem_Cfg_EventERecIterInit(EventId, &lIterator);                                                                                /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
  lBufferIndex = 0;

  /* #020 For each configured extended data record */
  while (FALSE != Dem_Cfg_EventERecIterExists(EventId, &lIterator))
  {
    Dem_Cfg_ERecIndexType lERecIndex;
    lERecIndex = Dem_Cfg_EventERecIterGet(EventId, &lIterator);
    Dem_Cfg_EventERecIterNext(EventId, &lIterator);

    /* #030 If the record is of type 'USER' */
    if (DEM_CFG_EREC_TYPE_USER == Dem_Cfg_ERecType(lERecIndex))
    {
      /* #040 Collect the record data, if the record is configured for updating or is not yet stored. */
      if ( (FALSE != Dem_Cfg_ERecUpdate(lERecIndex))
        || (0 == (lValidMask & MemoryEntry->ExtendedHeader)) )
      {
        MemoryEntry->ExtendedHeader = (uint8)(MemoryEntry->ExtendedHeader | lValidMask);
        lCollectDidInfo.DestinationBuffer = &MemoryEntry->ExtendedData[lBufferIndex][0];
        Dem_Data_CollectDid(&lCollectDidInfo, Dem_Cfg_ERecDid(lERecIndex));
# if (DEM_FEATURE_NEED_NOTIFY_DATA == STD_ON)
        lReturnValue = TRUE;
# endif
      }
      /* #050 Move to the next extended record buffer */
      ++lBufferIndex;
      Dem_LROT1_Byte(lValidMask)
    }
  }

  return lReturnValue;
}
#endif

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 % Dem_Data_EntryUpdate_SRecs
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_EntryUpdate_SRecs(
  Dem_EventIdType  EventId,
  Dem_Mem_EntryPtrType  MemoryEntry,
  uint8  UpdateFlags
  )
{
  boolean lReturnValue;
# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
  uint8 lValidMask;
  uint8 lLastStoredBufferIndex;
# endif
  uint8 lBufferIndex;
  Dem_Cfg_EventSRecIterType lIterator;

# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
  lValidMask = 0x01U;
  lLastStoredBufferIndex = 0xffU; /* Invalid */
# endif
  lReturnValue = FALSE;
  lBufferIndex = 0;
  Dem_Cfg_EventSRecIterInit(EventId, &lIterator);                                                                                /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */

  /* #010 Iterate all snapshot records that need an update: */
  while (FALSE != Dem_Cfg_EventSRecIterExists(EventId, &lIterator))
  {
    Dem_Cfg_SRecIndexType lSRecId;

    lSRecId = Dem_Cfg_EventSRecIterGet(EventId, &lIterator);
    Dem_Cfg_EventSRecIterNext(EventId, &lIterator);

    /* #020 If an update is needed: Updates are required when the configured trigger matches,
     *      and the record is either not stored or configured for updates */
    if ( (
# if (DEM_FEATURE_NEED_SREC_OEMTRIGGER == STD_ON)
           (Dem_Data_OemSRecTrigger(EventId, MemoryEntry, lSRecId, UpdateFlags)) ||
# endif
           (Dem_Cfg_SRecTrigger(lSRecId) == (UpdateFlags & Dem_Cfg_SRecTrigger(lSRecId))) )
# if (DEM_FEATURE_NEED_SRECS_FROZEN == STD_ON)
      && (
#  if (DEM_CFG_ISCONST_SREC_UPDATE != STD_ON)
           (FALSE != Dem_Cfg_SRecUpdate(lSRecId))
        ||
#  endif
#  if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
           (FALSE == (lValidMask & MemoryEntry->SnapshotHeader))
#  endif
#  if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
           (lBufferIndex == MemoryEntry->SnapshotHeader)
#  endif
         )
# endif
      )
    {
      /* #030 Update the list of stored records */
# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
      MemoryEntry->SnapshotHeader = (uint8)(MemoryEntry->SnapshotHeader | lValidMask);
# endif
# if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
      if (lBufferIndex == MemoryEntry->SnapshotHeader)
      { /* Only increment if a new snapshot is added, updates keep the current ID */
        MemoryEntry->SnapshotHeader = (uint8)(MemoryEntry->SnapshotHeader + 1);
      }
# endif

# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
      /* #040 For configured snapshot numbers, if the snapshot is already collected copy its data */
      if (lLastStoredBufferIndex != 0xffU)
      {
        Dem_MemCpy((Dem_NvDataPtrType)(&MemoryEntry->SnapshotData[lBufferIndex][0]),                                             /* PRQA S 0310, 0602 */ /* MD_DEM_11.4_cpy, MD_DEM_20.2 */
                    (Dem_NvDataPtrType)(&MemoryEntry->SnapshotData[lLastStoredBufferIndex][0]),
                    Dem_Cfg_EventSRecRawSize(EventId));
      }
      else
# endif
      {
# if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
        /* #050 If 'prestore freezeframe' is enabled and data is prestored, copy the prestored data */
        if (FALSE == Dem_Data_PrestorageApplySRec(EventId, &MemoryEntry->SnapshotData[lBufferIndex][0]))
# endif
        {
          /* #060 Otherwise, collect new samples from the application. */
          Dem_Data_CollectSnapshot(EventId, &MemoryEntry->SnapshotData[lBufferIndex][0]);
# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
          lLastStoredBufferIndex = lBufferIndex;
# endif
        }
# if (DEM_FEATURE_NEED_NOTIFY_DATA == STD_ON)
        lReturnValue = TRUE;
# endif
      }
      /* #070 For calculated snapshot records, processing is completed */
# if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
      break;
# endif
    }
    /* #080 Move to the next snapshot record buffer */
    ++lBufferIndex;
# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
    Dem_LROT1_Byte(lValidMask)
# endif
  }

  return lReturnValue;
}
#endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) */

/* ****************************************************************************
 % Dem_Data_EntryUpdate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_EntryUpdate(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  uint8  UpdateFlags,
  Dem_Cfg_MemoryIndexType  MemoryIndex
  )
{
  boolean lReturnValue;

  lReturnValue = FALSE;

  /* #010 If a memory entry exists for the event */
  if (DEM_MEM_INVALID_MEMORY_INDEX != MemoryIndex)
  {
    Dem_Mem_EntryPtrType lEntry;

    lEntry = Dem_Mem_MemoryGetEntry(MemoryIndex);                                                                                /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */

    /* #020 Start a memory update transaction */
    Dem_Mem_MemoryUpdateStart(MemoryIndex);

    /* #030 On a TestFailed trigger */
    if (0 != (UpdateFlags & DEM_CFG_TRIGGER_TESTFAILED))
    {
#if (DEM_FEATURE_NEED_OCC_COUNTER == STD_ON)
      /* #050 If occurrence counters are configured */
      {
        Dem_Data_OccurrenceCounterType lOccurrenceCount;

        lOccurrenceCount = Dem_Mem_EntryGetOccurrenceCount(lEntry);
        /* #060 If the event is confirmed, or occurrence counters are configured to count independent of confirmation */
# if (DEM_CFG_PROCESS_OCCTR_CONFIRMED == STD_ON)
        if (FALSE != DEM_ESM_TEST_UDS_STATUS_CDTC(Dem_Util_DtcGetStatus(EventId))) /* Event had confirmed earlier */
# endif
        {
          /* #070 Increment the occurrence counter, latching at 255 */
          if (lOccurrenceCount < DEM_DATA_OCCURRENCE_MAX)
          {
            lOccurrenceCount = (Dem_Data_OccurrenceCounterType)(lOccurrenceCount + 1);
            Dem_Mem_EntrySetOccurrenceCount(lEntry, lOccurrenceCount);
          }
        }
      }
#endif
      {
        /* #080 In non-VCC configurations reset the aging counter */
        Dem_Mem_EntrySetAgingCount(lEntry, DEM_ESM_CYCLECOUNT_INVALID);
      }
      /* #100 If the 'cycles since first failed' statistic is configured */
#if (DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON)
      /* #110 If a first cycle is not yet stored, store the current cycle as first cycle */
      if (DEM_ESM_CYCLECOUNT_INVALID == Dem_Mem_EntryGetFirstFailedCycleCount(lEntry))
      {
        Dem_Mem_EntrySetFirstFailedCycleCount(lEntry, Dem_Mem_GetCycleCounter(Dem_Cfg_EventOperationCycle(EventId)));
      }
#endif
#if (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON)
      /* #120 If the 'cycles since last failed' statistic is configured, store the current cycle as last cycle */
      Dem_Mem_EntrySetLastFailedCycleCount(lEntry, Dem_Mem_GetCycleCounter(Dem_Cfg_EventOperationCycle(EventId)));
#endif
      /* #130 If the 'maximum FaultDetectionCounter since last clear' statistic is configured */
#if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
      {
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
        /* #140 For combined events, store 0x7F */
        if (DEM_CFG_COMBINED_GROUP_INVALID != Dem_Cfg_EventCombinedGroup(EventId))
        {
          Dem_Mem_EntrySetDebounceValueMax(lEntry, (uint16)0x7Fu);
        }
        else
# endif
        {
# if ((DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) && (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON))
          /* #150 For normal event using time based de-bouncing, store 0 */
          if (DEM_CFG_DEBOUNCETYPE_TIMER == Dem_Cfg_EventDebounceType(EventId))
# endif
          {
# if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
            Dem_Mem_EntrySetDebounceValueMax(lEntry, 0);
# endif
          }
# if ((DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) && (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON))
          /* #160 For normal events using counter based de-bouncing, store the event's maximum de-bounce value */
          else
# endif
          {
# if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
            Dem_Mem_EntrySetDebounceValueMax(lEntry, Dem_Cfg_EventFailedTarget(EventId));
# endif
          }
        }
      }
#endif

#if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
      /* #170 In non-VCC configurations, store user-defined extended data records */
# if (DEM_FEATURE_NEED_NOTIFY_DATA == STD_ON)
      lReturnValue = (boolean)((Dem_Data_EntryUpdate_UserERecs(EventId, lEntry)) || lReturnValue);
# else
      (void)Dem_Data_EntryUpdate_UserERecs(EventId, lEntry);
# endif
#endif
    } /* TEST PASSED->FAILED */

#if ( (DEM_CFG_DATA_FAILED_CYCLES == STD_ON) \
   || (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON) )
    /* #180 On a TestFailedThisCycle trigger */
    if (0 != (UpdateFlags & DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE))
    {
      /* #190 If the 'number of failed cycles' statistic is configured */
# if (DEM_CFG_DATA_FAILED_CYCLES == STD_ON)
      {
        uint8 lCycleCount;

        /* #200 Increment the 'failed cycles' counter, latching at 255 */
        lCycleCount = Dem_Mem_EntryGetFailedCycleCount(lEntry);
        if (lCycleCount < 0xffU)
        {
          lCycleCount = (uint8)(lCycleCount + 1);
          Dem_Mem_EntrySetFailedCycleCount(lEntry, lCycleCount);
        }
      }
# endif
      /* #210 If the 'number of consecutive failed cycles' statistic is configured */
# if (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
      {
        uint8 lCycleCount;

        lCycleCount = Dem_Mem_EntryGetConsecutiveFailedCycleCount(lEntry);
        if (lCycleCount < 0xffU)
        {
          lCycleCount = (uint8)(lCycleCount + 1);
          Dem_Mem_EntrySetConsecutiveFailedCycleCount(lEntry, lCycleCount);
        }
      }
# endif
    }
#endif

    /* #290 Store snapshot records, in case of calculated snapshot record numbers only on a TestFailed trigger. */
#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
# if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
    if (0 != (UpdateFlags & DEM_CFG_TRIGGER_TESTFAILED))
# endif
    {
# if (DEM_FEATURE_NEED_NOTIFY_DATA == STD_ON)
      lReturnValue = (boolean)((Dem_Data_EntryUpdate_SRecs(EventId, lEntry, UpdateFlags)) || lReturnValue);
# else
      (void)Dem_Data_EntryUpdate_SRecs(EventId, lEntry, UpdateFlags);
# endif
    }
#endif /* #if (DEM_CFG_SUPPORT_SRECS == STD_ON) */

    /* #320 Close the memory update transaction */
    Dem_Mem_MemoryUpdateFinish(MemoryIndex);
  } /* if (DEM_MEM_INVALID_MEMORY_INDEX != MemoryIndex) */

  /* In rare cases this function does nothing */
  DEM_IGNORE_UNUSED_ARGUMENT(EventId)                                                                                            /* PRQA S 3112 */ /* MD_DEM_14.2 */

  /* #330 Return TRUE if any of the above actions did call a collection function */
  return lReturnValue;
}                                                                                                                                /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 % Dem_Data_CalculateFDC_CounterBased
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(sint8, DEM_CODE)
Dem_Data_CalculateFDC_CounterBased(
  Dem_EventIdType  EventId,
  sint16  DebounceValue
  )
{
  sint8 lReturnedFdc;

  /* #010 If the debounce counter is 0, the FDC is 0 */
  if (DebounceValue == 0)
  {
    lReturnedFdc = 0;
  }
  else
  {
    sint16 lFailedTarget = Dem_Cfg_EventFailedTarget(EventId);
    sint16 lPassedTarget = Dem_Cfg_EventPassedTarget(EventId);

    /* #020 If the debounce counter has reached the Failed threshold, the FDC is 127 */
    if (lFailedTarget == DebounceValue)
    {
      lReturnedFdc = 127;
    }
    /* #030 If the debounce counter has reached the Passed threshold, the FDC is -128 */
    else if (lPassedTarget == DebounceValue)
    {
      lReturnedFdc = -128;
    }
    else
    { /* current debounce counter value is somewhere in range of passed threshold and failed threshold but not 0 */
      if (DebounceValue > 0)
      {
        /* #040 Map a debounce counter > 0 linearly into range [1;126] */
        lReturnedFdc = (sint8)(((sint32)DebounceValue * 127) / lFailedTarget);
        /* result has to be greater than 0 */
        if (lReturnedFdc == 0)
        {
          lReturnedFdc = 1;
        }
      }
      else
      {
        /* #050 Map a debounce counter < 0 linearly into range [-127;-1] */
        lReturnedFdc = (sint8)(((sint32)DebounceValue * -128)  / lPassedTarget);
        /* result has to be smaller than 0 */
        if (lReturnedFdc == 0)
        {
          lReturnedFdc = -1;
        }
      }
    }
  }

  return lReturnedFdc;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Data_CalculateFDC_TimeBased
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(sint8, DEM_CODE)
Dem_Data_CalculateFDC_TimeBased(
  Dem_EventIdType  EventId,
  sint16  DebounceValue,
  uint8  DebounceStatus
  )
{
  sint8 lReturnedFdc;

  switch (DebounceStatus)
  {
  /* #010 If the debounce timer is neutral, the FDC is 0 */
  case DEM_ESM_DEBOUNCE_STATUS_NONE:
    lReturnedFdc = 0;
    break;
  /* #020 If the debounce timer has completed the Failed time, the FDC is 127 */
  case DEM_ESM_DEBOUNCE_DONE_FAILED:
    lReturnedFdc = 127;
    break;
  /* #030 If the debounce timer has completed the Passed time, the FDC is -128 */
  case DEM_ESM_DEBOUNCE_DONE_PASSED:
    lReturnedFdc = -128;
    break;
  /* #040 If the debounce timer has started counting towards the Failed time, map the elapsed time into range [1;126] */
  case DEM_ESM_DEBOUNCE_COUNT_FAILED:
  case DEM_ESM_DEBOUNCE_FREEZE_FAILED:
  case DEM_ESM_DEBOUNCE_COUNT_FAILED_FDC:
  case DEM_ESM_DEBOUNCE_FREEZE_FAILED_FDC:
    {
      sint16 lQualifyTarget;
      lQualifyTarget = Dem_Cfg_EventFailedTime(EventId);
      lReturnedFdc = (sint8)((sint32)((sint32)(lQualifyTarget - DebounceValue) * 127) / lQualifyTarget);

      /* Already counting, assert an FDC of at least 1 */
      if (lReturnedFdc == 0)
      {
        lReturnedFdc = 1;
      }
    }
    break;
  case DEM_ESM_DEBOUNCE_RESET_FAILED:
    lReturnedFdc = 1;
    break;

  /* #050 If the debounce timer has started counting towards the Passed time, map the elapsed time into range [-127;-1] */
  case DEM_ESM_DEBOUNCE_COUNT_PASSED:
  case DEM_ESM_DEBOUNCE_FREEZE_PASSED:
    {
      sint16 lQualifyTarget;
      lQualifyTarget = Dem_Cfg_EventPassedTime(EventId);
      lReturnedFdc = (sint8)((sint32)((sint32)(lQualifyTarget - DebounceValue) * -128) / lQualifyTarget);

      /* Already counting, assert an FDC of at most -1 */
      if (lReturnedFdc == 0)
      {
        lReturnedFdc = -1;
      }
    }
    break;
  case DEM_ESM_DEBOUNCE_RESET_PASSED:
    lReturnedFdc = -1;
    break;

  default:
    Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_INCONSISTENT_STATE)
    lReturnedFdc = 0;
    break;
  }

  return lReturnedFdc;
}
#endif /* (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) */

#if ( (DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON) \
   || ((DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON) && (DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE == STD_ON)) )
/* ****************************************************************************
 % Dem_Data_EventGetFDCMax
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(sint8, DEM_CODE)
Dem_Data_EventGetFDCMax(
  Dem_EventIdType  EventId
  )
{
  sint8 lFaultDetectionCounter;

  /* Optimization: Don't call the calculation methods if we know the event has already failed this cycle */
  if (FALSE != DEM_ESM_TEST_UDS_STATUS_TFTOC(Dem_Mem_EventGetStatus(EventId)))
  {
    lFaultDetectionCounter = 127U;
  }
  else
  {
    switch (Dem_Cfg_EventDebounceType(EventId))
    {
    /* #010 For events using counter or time-based events, calculate the maximum FDC based on the stored
     *        maximum debounce value. */
#  if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
    case DEM_CFG_DEBOUNCETYPE_COUNTER:
      lFaultDetectionCounter = Dem_Data_CalculateFDC_CounterBased(EventId,
                                                                    Dem_Mem_EventGetDebounceValueMax(EventId));
      break;
#  endif  /* (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON) */
#  if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
    case DEM_CFG_DEBOUNCETYPE_TIMER:
      if (Dem_Mem_EventGetDebounceValueMax(EventId) != Dem_Cfg_EventFailedTime(EventId))
      {
        lFaultDetectionCounter = Dem_Data_CalculateFDC_TimeBased(EventId,
                                                                 Dem_Mem_EventGetDebounceValueMax(EventId),
                                                                 DEM_ESM_DEBOUNCE_COUNT_FAILED);
      }
      else
      { /* Delay Max FDC until the timer has ticked once. */
        lFaultDetectionCounter = 0;
      }
      break;
#  endif /* (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) */
    /* - #020 For events using monitor-internal debouncing, return 127 if there was a qualified failed result
     *        this cycle. Otherwise return 0. */
#  if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
    case DEM_CFG_DEBOUNCETYPE_EXTERNAL:
      lFaultDetectionCounter = 0U;
      break;
#  endif
    default:
      /* unreachable MISRA case */
      lFaultDetectionCounter = 0;
      break;
    }
  }
  return lFaultDetectionCounter;
}
#endif

#if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
/* ****************************************************************************
 % Dem_Data_ERecIsStored
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_ERecIsStored(
  Dem_Mem_ConstEntryPtrType  MemoryEntry,
  uint8  ERecStoredIndex
  )
{
  uint8 lMask;
  lMask = ((uint8)(1u << ERecStoredIndex));

  return (boolean)((0 != (MemoryEntry->ExtendedHeader & lMask))?(TRUE):(FALSE));
}
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 % Dem_Data_SRecCount
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Data_SRecCount(
  Dem_Mem_ConstEntryPtrType  MemoryEntry
  )
{
# if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
  /* #010 If calculated records are used, the snapshot header corresponds to the snapshot count */
  return MemoryEntry->SnapshotHeader;
# endif
# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
  /* #020 If configured records are used, count the number of bits set in the snapshot header */
  uint8 lReturnValue = 0;
  uint8 lSnapshotHeader = MemoryEntry->SnapshotHeader;
  while (0 != lSnapshotHeader)
  {
    lReturnValue = (uint8)(lReturnValue + (lSnapshotHeader & 0x01U));
    lSnapshotHeader = (uint8)(lSnapshotHeader >> 0x01U);
  }
  return lReturnValue;
# endif
}
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON) */

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 % Dem_Data_SRecIsStored
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_SRecIsStored(
  Dem_Mem_ConstEntryPtrType  MemoryEntry,
  uint8  SRecStoredIndex
  )
{
# if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
  /* #010 If calculated records are used, the snapshot is stored if its number is lesser than the snapshot count */
  return (boolean)((MemoryEntry->SnapshotHeader > SRecStoredIndex)?(TRUE):(FALSE));
# endif
# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
  /* #020 If configured records are used, test if the corresponding bit is set in the snapshot header */
  uint8 lMask;
  lMask = ((uint8)(1u << SRecStoredIndex));

  return (boolean)((0 != (MemoryEntry->SnapshotHeader & lMask))?(TRUE):(FALSE));
# endif
}
#endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) */

#if (DEM_CFG_SUPPORT_SRECS == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_OBDII == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_WWHOBD == STD_ON)
/* ****************************************************************************
 % Dem_Data_SkipDid
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_SkipDid(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr,
  Dem_Cfg_DidIndexType  DidIndex
  )
{
  Dem_Cfg_DidDataIterType lDataIter;

  /* #010 Iterate all data elements in the DID */
  Dem_Cfg_DidDataIterInit(DidIndex, &lDataIter);                                                                                 /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
  while (FALSE != Dem_Cfg_DidDataIterExists(DidIndex, &lDataIter))
  {
    Dem_Cfg_DataIndexType lDataIndex;

    lDataIndex = Dem_Cfg_DidDataIterGet(DidIndex, &lDataIter);
    Dem_Cfg_DidDataIterNext(DidIndex, &lDataIter);

    /* #020 If the data element uses NV buffer (type ROOTCAUSE_EVENT and CALLBACK) */
    switch (Dem_Cfg_DataCallbackType(lDataIndex))
    {
# if (DEM_CFG_DATA_ROOTCAUSE_EVENTID == STD_ON)
      /* ROOTCAUSE_EVENTID: stored in environmental data array */
    case DEM_CFG_DATA_FROM_ROOTCAUSE_EVENTID:
# endif
    case DEM_CFG_DATA_FROM_CBK_STORED:
    case DEM_CFG_DATA_FROM_CBK_STORED_WITH_EVENTID:
      Dem_Internal_AssertReturnVoid(CopyDidInfoPtr->SourceBuffer != NULL_PTR, DEM_E_INCONSISTENT_STATE)
      /* #030 Move the source buffer by the size of the data element */
      CopyDidInfoPtr->SourceBuffer = &CopyDidInfoPtr->SourceBuffer[Dem_Cfg_DataSize(lDataIndex)];
      break;

    default:
      break;
    }
  }
}
#endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_OBDII == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 % Dem_Data_SRecCopyData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_SRecCopyData(
  Dem_SharedDataPtrType  Buffer,
  uint8  SRecStoredIndex
  )
{
  uint16 lDidCount;
  Dem_Cfg_EventDidIterType lDidIter;
  Dem_Data_CopyDidInfoType lCopyDidInfo;

  Dem_Cfg_EventDidIterInit(Dem_Cfg_ReadoutBuffer.EventId, &lDidIter);                                                            /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */

  /* #010 Initialize a CopyDid Context. Reserve one byte at the start for the DID count. */
  lCopyDidInfo.DestinationBuffer = &Buffer[1]; /* first element is reserved for number of DIDs */
  lCopyDidInfo.SourceBuffer      = (Dem_ConstSharedDataPtrType)&Dem_Cfg_ReadoutBuffer.SnapshotData[SRecStoredIndex][0];
  lCopyDidInfo.Entry             = &Dem_Cfg_ReadoutBuffer;
  lCopyDidInfo.EventId           = Dem_Cfg_ReadoutBuffer.EventId;

  /* Initialize number of DIDs */
  lDidCount = 0;

  /* #020 Iterate through all DIDs of the Snapshot record */
  while (FALSE != Dem_Cfg_EventDidIterExists(Dem_Cfg_ReadoutBuffer.EventId, &lDidIter))
  {
    Dem_Cfg_DidIndexType lDidIndex;
    lDidIndex = Dem_Cfg_EventDidIterGet(Dem_Cfg_ReadoutBuffer.EventId, &lDidIter);
    Dem_Cfg_EventDidIterNext(Dem_Cfg_ReadoutBuffer.EventId, &lDidIter);

    /* #030 Count the DIDs */
    ++lDidCount;
    /* #040 Store the DID number into the destination buffer */
    lCopyDidInfo.DestinationBuffer[0] = Dem_GetHiByte(Dem_Cfg_DidNumber(lDidIndex));
    lCopyDidInfo.DestinationBuffer[1] = Dem_GetLoByte(Dem_Cfg_DidNumber(lDidIndex));
    lCopyDidInfo.DestinationBuffer    = &lCopyDidInfo.DestinationBuffer[2];

    /* #060 Copy the DID data into the destination buffer */
    (void)Dem_Data_CopyDid(&lCopyDidInfo, lDidIndex);
  }

  /* #070 Store the number of DIDs to the first byte of the destination buffer.
   *      Set the DID count to 0 in case of more than 255 DIDs. */
  if (lDidCount > 255)
  {
    Buffer[0] = 0;
  }
  else
  {
    Buffer[0] = Dem_GetLoByte(lDidCount);
  }
}
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON) */

#if (DEM_FEATURE_NEED_CYCLE_COUNTERS == STD_ON)
/* ****************************************************************************
 % Dem_Data_EntryOpCycleStart
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_EntryOpCycleStart(
  Dem_Mem_EntryPtrType  MemoryEntry,
  uint16  CycleCount
  )
{
  boolean lReturnValue;
  lReturnValue = FALSE;

# if (DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON)
  if ( (DEM_ESM_CYCLECOUNT_MAX > Dem_Mem_EntryGetFirstFailedCycleCount(MemoryEntry))                                             /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    && (Dem_Esm_CycleCountDistance(Dem_Mem_EntryGetFirstFailedCycleCount(MemoryEntry), CycleCount) >= 0xffU) )
  {
    Dem_Mem_EntrySetFirstFailedCycleCount(MemoryEntry, DEM_ESM_CYCLECOUNT_LATCHED);
    lReturnValue = TRUE;
  }
# endif
# if (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON)
  if ( (DEM_ESM_CYCLECOUNT_MAX > Dem_Mem_EntryGetLastFailedCycleCount(MemoryEntry))                                              /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
    && (Dem_Esm_CycleCountDistance(Dem_Mem_EntryGetLastFailedCycleCount(MemoryEntry), CycleCount) >= 0xffU) )
  {
    Dem_Mem_EntrySetLastFailedCycleCount(MemoryEntry, DEM_ESM_CYCLECOUNT_LATCHED);
    lReturnValue = TRUE;
  }
# endif
  return lReturnValue;
}
#endif /* (DEM_FEATURE_NEED_ENTRY_CYCLE_COUNTERS == STD_ON) */

#if (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON) || (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
/* ****************************************************************************
 % Dem_Data_DtcOpCycleUpdate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_DtcOpCycleUpdate(
  Dem_EventIdType  EventId,
  uint8  DtcStatus,
  uint8  CycleStatus
  )
{
  /* #010 If the operation cycle was stopped, the DTC has completed a test this cycle and the event has
   *      a memory entry */
  if ( (0 != (CycleStatus & DEM_QUEUE_CYCLE_STOPPED))
    && (FALSE == DEM_ESM_TEST_UDS_STATUS_TNCTOC(DtcStatus))
    && (DEM_ESM_STORED_STATUS_NONE != DEM_ESM_GET_STORED_STATUS(Dem_Util_DtcGetInternalStatus(EventId))) )
  {
    DEM_MEM_MEMORYINFO_PARAM_VARDEF
    Dem_Mem_EntryPtrType lEntry;
    Dem_Cfg_MemoryIndexType lMemoryIndex;

    DEM_MEM_MEMORYINFO_PARAM_INIT(Dem_Cfg_EventDestination(EventId))

    lMemoryIndex = Dem_Mem_MemoryFindIndex(EventId);
    lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);                                                                               /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */

    /* #030 In configurations supporting the 'consecutive failed cycles' statistic */
# if (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
    /* #040 If the current cycle was not tested failed, reset the 'consecutive failed cycles' */
    if (FALSE == DEM_ESM_TEST_UDS_STATUS_TFTOC(DtcStatus))
    {
      Dem_Mem_EntrySetConsecutiveFailedCycleCount(lEntry, 0);
    }
# endif
    /* #050 In configurations supporting the 'cycles since first failed' statistic */
# if (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON)
    /* #060 If the event has failed before (only in configurations that store at FDC thresholds) */
#  if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
    if (FALSE != DEM_ESM_TEST_UDS_STATUS_TFSLC(DtcStatus))
#  endif
    {
      /* #070 Increment the 'cycles since first failed' value, latching at 255 */
      if (Dem_Mem_EntryGetTestedSinceFirstFailedCycleCount(lEntry) < 255)
      {
        Dem_Mem_EntrySetTestedSinceFirstFailedCycleCount(lEntry, (uint8)(Dem_Mem_EntryGetTestedSinceFirstFailedCycleCount(lEntry) + 1));
      }
    }
# endif
  }
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Data_PrestorageEntryUpdate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Data_PrestorageEntryUpdate(
  Dem_EventIdType  EventId,
  Dem_Mem_PrestoredEntryPtrType  PrestoredEntry                                                                                  /* PRQA S 3673 */ /* MD_DEM_16.7_False */
  )
{
# if (DEM_CFG_SUPPORT_SRECS == STD_ON)
  /* #010 Sample a UDS snapshot into the prestorage buffer */
  Dem_Data_CollectSnapshot(EventId, &PrestoredEntry->SnapshotData[0]);
# endif

}
#endif

                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Mem_Init_RestoreMemory
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_Init_RestoreMemory(
  DEM_MEM_MEMORYINFO_PARAMDEF_ONLY
  )
{ /* No reinitialization - restore primary stack */
  Dem_Cfg_MemoryIndexType lMemoryIndex;

  Dem_Mem_MemorySetCurrentSize(0);

  /* #010 Iterate through all memory entries. The iteration order must be identical to Dem_Mem_MemoryEntryFind. */
  for (lMemoryIndex = Dem_Mem_MemoryIndex_Begin(); lMemoryIndex < Dem_Mem_MemoryIndex_End(); ++lMemoryIndex)
  {
    CONST(Dem_Mem_EntryPtrType, AUTOMATIC) lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);                                        /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
    Dem_EventIdType lEventId;

    lEventId = Dem_Mem_EntryGetEventId(lEntry);
    if (lEventId != DEM_EVENT_INVALID)
    {
      uint32 lTimestamp;
      uint8 lSortedIndex;
      Dem_Cfg_EventInternalStatusType lInternalStatus;

      /* #020 If combined events are configured */
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
      if (Dem_Util_DtcGetMasterEvent(lEventId) != lEventId)
      {
        /* #030 If the memory entry is not allocated to the master event. */

        /* #040 Manually clear the memory entry and report to the DET. Skip to the next block. */
        Dem_Mem_EntrySetEventId(lEntry, DEM_EVENT_INVALID);
        Dem_Mem_EntrySetTimestamp(lEntry, 0U);
        Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTYCLEAREDIMMEDIATE);

        /* DET: This inconsistency requires a configuration change without clearing the NV contents */
        Dem_Det_ReportError(DEM_INIT_APIID, DEM_E_INCONSISTENT_STATE)
        continue;                                                                                                                /* PRQA S 0770 */ /* MD_DEM_14.5 */                                                                                                              /* PRQA S 0770 */ /* MD_DEM_14.5 */
      }
#endif

      lInternalStatus = Dem_Util_DtcGetInternalStatus(lEventId);
      lTimestamp = Dem_Mem_EntryGetTimestamp(lEntry);

      /* #050 If the memory entry is allocated to an event that already has a memory entry */
      if (DEM_ESM_STORED_STATUS_NONE != DEM_ESM_GET_STORED_STATUS(lInternalStatus))
      { /* Runtime error, no DET. This can happen due to NV errors */
        uint8 lOtherIndex;

        /* Dem_Mem_MemoryFindIndex will always succeed since we are processing a duplicate */
        lOtherIndex = Dem_Mem_MemoryFindIndex(lEventId);

        if (Dem_Mem_EntryGetTimestamp(Dem_Mem_MemoryGetEntry(lOtherIndex)) < lTimestamp)                                         /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
        { /* #060 If the other memory entry is older, clear the other memory entry. */
          Dem_Mem_MemoryFreeIndex(lOtherIndex);
          Dem_Mem_MemorySetBlockState(lOtherIndex, DEM_NVM_BLOCKSTATE_DIRTYCLEAREDIMMEDIATE);
        }
        else
        { /* #070 Otherwise manually clear the current memory entry and proceed with the next block. */
          Dem_Mem_EntrySetEventId(lEntry, DEM_EVENT_INVALID);
          Dem_Mem_EntrySetTimestamp(lEntry, 0U);
          Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTYCLEAREDIMMEDIATE);
          continue;                                                                                                              /* PRQA S 0770 */ /* MD_DEM_14.5 */
        }
      }

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
      if (DEM_CFG_COMBINED_GROUP_INVALID == Dem_Cfg_EventCombinedGroup(lEventId))
#endif
      {
        uint8 lEventStatus;
        lEventStatus = Dem_Mem_EventGetStatus(lEventId);

#if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
        /* #140 If aging keeps memory entries intact and the memory entry is aged */
        if (DEM_ESM_CYCLECOUNT_EVENT_AGED == Dem_Mem_EntryGetAgingCount(lEntry))
        {
          /* #150 Unless storage happens at ConfirmedDTC, make sure TF and WIR are not set */
# if (DEM_CFG_STORAGE_AT_CONFIRMED != STD_ON)
          lEventStatus = DEM_ESM_RESET_UDS_STATUS_TF(lEventStatus);
          lEventStatus = DEM_ESM_RESET_UDS_STATUS_WIR(lEventStatus);
# endif
        }
        else
#endif
        /* #160 Otherwise, if storage happens at a FDC threshold */
        {
#if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
# if (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
          /* #170 If there are consecutive failed cycles > 0 */
          if (Dem_Mem_EntryGetConsecutiveFailedCycleCount(lEntry) > 0)
          {
            /* #180 Make sure PDTC and TFSLC are set */
            lEventStatus = DEM_ESM_SET_UDS_STATUS_TFSLC(lEventStatus);
            lEventStatus = DEM_ESM_SET_UDS_STATUS_PDTC(lEventStatus);
          }
          if (Dem_Mem_EntryGetConsecutiveFailedCycleCount(lEntry) > Dem_Cfg_EventTripTarget(lEventId))
          {
            /* #190 If the consecutive failed cycles exceed the trip target, make sure CDTC is set */
            lEventStatus = DEM_ESM_SET_UDS_STATUS_CDTC(lEventStatus);
          }
# elif ((DEM_CFG_DATA_OCCCTR == STD_ON) || (DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON))
          if (Dem_Mem_EntryGetOccurrenceCount(lEntry) > 0)
          {
            /* #200 If there is an occurrence counter > 0 make sure TFSLC is set */
            lEventStatus = DEM_ESM_SET_UDS_STATUS_TFSLC(lEventStatus);
          }
# endif
          /* #210 Otherwise, if storage happens at confirmed */
#elif (DEM_CFG_STORAGE_AT_CONFIRMED == STD_ON)
          /* #220 Make sure CDTC and TFSLC are set */
          lEventStatus = DEM_ESM_SET_UDS_STATUS_TFSLC(lEventStatus);
          lEventStatus = DEM_ESM_SET_UDS_STATUS_CDTC(lEventStatus);
# if (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
          if (Dem_Mem_EntryGetConsecutiveFailedCycleCount(lEntry) > 0)
          {
            /* #230 If there are consecutive failed cycles > 0 make sure PDTC is set */
            lEventStatus = DEM_ESM_SET_UDS_STATUS_PDTC(lEventStatus);
          }
# endif
#else
          /* #240 For all other storage triggers */
          /* #250 Make sure TFSCL is set */
          lEventStatus = DEM_ESM_SET_UDS_STATUS_TFSLC(lEventStatus);
# if (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
          /* #260 If there are consecutive failed cycles > 0 */
          if (Dem_Mem_EntryGetConsecutiveFailedCycleCount(lEntry) > 0)
          { /* #270 Make sure PDTC is set */
            lEventStatus = DEM_ESM_SET_UDS_STATUS_PDTC(lEventStatus);
          }
          if (Dem_Mem_EntryGetConsecutiveFailedCycleCount(lEntry) > Dem_Cfg_EventTripTarget(lEventId))
          { /* #280 If the consecutive failed cycles exceed the trip target, make sure CDTC is set */
            lEventStatus = DEM_ESM_SET_UDS_STATUS_CDTC(lEventStatus);
          }
# else
          /* #290 Without consecutive failed cycles, make sure events with trip target == 0 have set CDTD */
#  if ((DEM_FEATURE_NEED_TRIPPING == STD_ON) && (DEM_CFG_ISCONST_TRIPTARGET != STD_ON))
          if (0 == Dem_Cfg_EventTripTarget(lEventId))
#  endif
          {
            lEventStatus = DEM_ESM_SET_UDS_STATUS_CDTC(lEventStatus);
          }
# endif
#endif
        }
        Dem_Mem_EventSetStatus(lEventId, lEventStatus);
      }

      /* #310 If the memory entry is currently aging, mark the event as AGING */
      if ( (DEM_ESM_CYCLECOUNT_MAX >= Dem_Mem_EntryGetAgingCount(lEntry))
        || (DEM_ESM_CYCLECOUNT_LATCHED == Dem_Mem_EntryGetAgingCount(lEntry)) )
      {
        lInternalStatus = DEM_ESM_SET_STORED_STATUS(lInternalStatus, DEM_ESM_STORED_STATUS_AGING);
      }
      else
#if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
      /* #320 If aging keeps memory entries intact and the entry is aged, mark the event as AGED */
      if (DEM_ESM_CYCLECOUNT_EVENT_AGED == Dem_Mem_EntryGetAgingCount(lEntry))
      {
        lInternalStatus = DEM_ESM_SET_STORED_STATUS(lInternalStatus, DEM_ESM_STORED_STATUS_AGED);
      }
      else
#endif
      /* #330 Otherwise mark the event as ACTIVE */
      {
        lInternalStatus = DEM_ESM_SET_STORED_STATUS(lInternalStatus, DEM_ESM_STORED_STATUS_ACTIVE);
      }

      Dem_Util_DtcSetInternalStatus(lEventId, lInternalStatus);

      /* #340 Synchronize the global timestamp with the timestamp stored in the memory entry */
      if (lTimestamp > Dem_Mem_CurrentTimestamp)
      {
        Dem_Mem_CurrentTimestamp = lTimestamp;
      }

      /* #350 Sort the memory entry into the chronological list */
      lSortedIndex = Dem_Mem_MemoryGetCurrentSize();
      while ( (lSortedIndex > 0)
           && (Dem_Mem_EntryGetTimestamp(Dem_Mem_MemoryGetEntry(Dem_Mem_MemoryGetChronology(lSortedIndex-1))) > lTimestamp) )    /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
      {
        Dem_Mem_MemorySetChronology(lSortedIndex, Dem_Mem_MemoryGetChronology(lSortedIndex-1));
        --lSortedIndex;
      }

      Dem_Mem_MemorySetChronology(lSortedIndex, lMemoryIndex);

      /* #360 Update the number of occupied memory entries */
      Dem_Mem_MemorySetCurrentSize((uint8)(Dem_Mem_MemoryGetCurrentSize() + 1));
    }
  }
  /* #370 Update the global timestamp */
  ++Dem_Mem_CurrentTimestamp;
}                                                                                                                                /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_Mem_GetCycleStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Mem_GetCycleStatus(
  uint8  CycleId
  )
{
  return (uint8)(((Dem_Mem_CurrentCycleState & (uint16)(1U << (CycleId))) != 0)
    ? DEM_QUEUE_CYCLE_STARTED
    : DEM_QUEUE_CYCLE_STOPPED);
}

/* ****************************************************************************
 % Dem_Mem_SetCycleStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetCycleStatus(
  uint8  CycleId,
  uint8  Status
  )
{
  uint16 lMask;

  lMask = (uint16)(1U << CycleId);
  if (DEM_QUEUE_CYCLE_STOPPED == Status)
  {
    lMask = (uint16)~lMask;
    Dem_Mem_CurrentCycleState = (uint16)(Dem_Mem_CurrentCycleState & lMask);
  }
  else
  {
    Dem_Mem_CurrentCycleState = (uint16)(Dem_Mem_CurrentCycleState | lMask);
  }
}

#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
/* ****************************************************************************
 % Dem_Mem_GetOverflow
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Mem_GetOverflow(
  uint8  MemoryId
  )
{
  boolean lReturnValue;

  if ((Dem_Mem_GetMemoryOverflow() & (1U << MemoryId)) != 0)
  {
    lReturnValue = TRUE;
  }
  else
  {
    lReturnValue = FALSE;
  }

  return lReturnValue;
}
#endif

#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SetOverflow
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_SetOverflow(
  uint8  MemoryId
  )
{
  uint8 lOldOverflow;
  uint8 lNewOverflow;

  lOldOverflow = Dem_Mem_GetMemoryOverflow();
  lNewOverflow = (uint8)(lOldOverflow | ((uint8)(1U << MemoryId)));
  if (lOldOverflow != lNewOverflow)
  {
    Dem_Mem_SetMemoryOverflow(lNewOverflow);
  }
}
#endif

#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
/* ****************************************************************************
 % Dem_Mem_ResetOverflow
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_ResetOverflow(
  uint8  MemoryId
  )
{
  uint8 lOldOverflow;
  uint8 lNewOverflow;

  lOldOverflow = Dem_Mem_GetMemoryOverflow();
  lNewOverflow = (uint8)(lOldOverflow & ((uint8)~((uint8)(1U << MemoryId))));
  if (lOldOverflow != lNewOverflow)
  {
    Dem_Mem_SetMemoryOverflow(lNewOverflow);
  }
}
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
/* ****************************************************************************
 % Dem_Mem_CopyDataDebounceNv
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_CopyDataDebounceNv(
  void
  )
{
  Dem_EventIdType lEventId;
  Dem_EventIdType lDebounceNvIndex;

  lDebounceNvIndex = Dem_Cfg_GlobalDebounceStorageEventCount();
  lEventId = Dem_Cfg_GlobalEventCount();

  Dem_Internal_AssertReturnVoid(lEventId >= lDebounceNvIndex, DEM_E_PARAM_CONFIG)

  while (lDebounceNvIndex != 0U)
  {
    Dem_Internal_AssertReturnVoid(lEventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE)

    --lEventId;

    if (FALSE != Dem_Cfg_EventSupportDebounceNv(lEventId))
    {
      --lDebounceNvIndex;
      Dem_Cfg_DebounceData[lDebounceNvIndex] = Dem_Mem_EventGetDebounceValue(lEventId);
    }
  }
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Mem_PrestorageInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_PrestorageInit(
  void
  )
{
  Dem_Cfg_PrestorageIndexType lPrestorageIndex;
  for (lPrestorageIndex = 0; lPrestorageIndex < Dem_Cfg_GlobalPrestorageSize(); ++lPrestorageIndex)
  { /* Chain the blocks */
    Dem_Mem_PrestoredEntrySetNext(Dem_Mem_PrestorageGetEntry(lPrestorageIndex), lPrestorageIndex + 1);
  }
  /* Last block points to end, head points to first block */
  Dem_Mem_PrestoredEntrySetNext(Dem_Mem_PrestorageGetEntry(Dem_Cfg_GlobalPrestorageSize() - 1), DEM_MEM_INVALID_PRESTORAGE_INDEX);
  Dem_Mem_PrestorageHeadIndex = 0;

  Dem_MemSet(Dem_Cfg_PrestorageIndex, DEM_MEM_INVALID_PRESTORAGE_INDEX, Dem_Cfg_GlobalPrestorageEventCount()*sizeof(Dem_Cfg_PrestorageIndexType));  /* PRQA S 0312, 0602, 3109 */ /* MD_DEM_11.5, MD_DEM_20.2, MD_MSR_14.3 */
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Mem_PrestorageFindEntry
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_PrestorageIndexType, DEM_CODE)
Dem_Mem_PrestorageFindEntry(
  Dem_EventIdType  EventId
  )
{
  Dem_Internal_AssertReturnValue(DEM_MEM_INVALID_PRESTORAGE_REF != Dem_Cfg_EventPrestorageIndex(EventId), DEM_E_PARAM_DATA, DEM_MEM_INVALID_PRESTORAGE_INDEX)
  return Dem_Mem_PrestorageGetRef(EventId);
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Mem_PrestorageAllocateEntry
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_Cfg_PrestorageIndexType, DEM_CODE)
Dem_Mem_PrestorageAllocateEntry(
  Dem_EventIdType  EventId
  )
{
  Dem_Cfg_PrestorageIndexType lPrestorageIndex;
  Dem_Internal_AssertReturnValue(DEM_MEM_INVALID_PRESTORAGE_INDEX == Dem_Mem_PrestorageFindEntry(EventId), DEM_E_PARAM_DATA, DEM_MEM_INVALID_PRESTORAGE_INDEX)

  /* #010 If a free entry exists */
  lPrestorageIndex = Dem_Mem_PrestorageHeadIndex;
  if (DEM_MEM_INVALID_PRESTORAGE_INDEX != lPrestorageIndex)
  { /* #020 Unlink it from the free list */
    Dem_Mem_PrestorageHeadIndex = Dem_Mem_PrestoredEntryGetNext(Dem_Mem_PrestorageGetEntry(lPrestorageIndex));
    /* #030 Update the prestorage lookup table */
    Dem_Mem_PrestorageSetRef(
      EventId,
      lPrestorageIndex
    );
    /* #040 Initialize the entry */
    Dem_Mem_PrestoredEntrySetEventId(Dem_Mem_PrestorageGetEntry(lPrestorageIndex), EventId);
  }

  return lPrestorageIndex;
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Mem_PrestorageFreeEntry
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_PrestorageFreeEntry(
  Dem_Cfg_PrestorageIndexType  PrestorageIndex
  )
{
  Dem_Internal_AssertReturnVoid(DEM_MEM_INVALID_PRESTORAGE_INDEX != PrestorageIndex, DEM_E_PARAM_DATA)

  /* #010 Update the prestorage lookup table */
  Dem_Mem_PrestorageSetRef(
    Dem_Mem_PrestoredEntryGetEventId(Dem_Mem_PrestorageGetEntry(PrestorageIndex)),
    DEM_MEM_INVALID_PRESTORAGE_INDEX
  );

  /* #020 Add the entry to the front of the free list */
  Dem_Mem_PrestoredEntrySetNext(Dem_Mem_PrestorageGetEntry(PrestorageIndex), Dem_Mem_PrestorageHeadIndex);
  Dem_Mem_PrestorageHeadIndex = PrestorageIndex;
}
#endif

/* ****************************************************************************
 % Dem_Mem_MemoryUpdateIndex_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_MemoryUpdateIndex_Internal(
  DEM_MEM_MEMORYINFO_PARAMDEF_FIRST
  uint8  MemoryIndex
  )
{
  uint8 lChronoIterator;
  uint8 lTempIndex;

  /* #010 Store the global timestamp to the entry, and update it */
  Dem_Mem_EntrySetTimestamp(Dem_Mem_MemoryGetEntry(MemoryIndex), Dem_Mem_CurrentTimestamp);                                      /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
  ++Dem_Mem_CurrentTimestamp;

  /* #020 Sort the chronologic list */
  /* move downwards the chronology moving all entries, until the updated element is overwritten */
  lChronoIterator = (uint8)(Dem_Mem_MemoryGetCurrentSize() - 1);
  lTempIndex = Dem_Mem_MemoryGetChronology(lChronoIterator);
  /* since we are guaranteed to find this entry somewhere, no need to check for chronoIter >= 0 */
  while (lTempIndex != MemoryIndex)
  {
    uint8 lSwap;

    lSwap = lTempIndex;
    --lChronoIterator;
    lTempIndex = Dem_Mem_MemoryGetChronology(lChronoIterator);
    Dem_Mem_MemorySetChronology(lChronoIterator, lSwap);
  }

  Dem_Mem_MemorySetChronology((uint8)(Dem_Mem_MemoryGetCurrentSize() - 1), MemoryIndex);
}

/* ****************************************************************************
 % Dem_Mem_PreInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_PreInit(
  void
  )
{
  Dem_MemSet((Dem_DataPtrType)Dem_Cfg_EventInternalStatus,                                                                       /* PRQA S 0310, 0312, 0602, 3109 */ /* MD_DEM_11.4_cpy, MD_DEM_11.5, MD_DEM_20.2, MD_MSR_14.3 */
             DEM_ESM_STORED_STATUS_NONE,
             Dem_Cfg_GlobalEventCount()*sizeof(Dem_Cfg_EventInternalStatusType));
}

/* ****************************************************************************
 % Dem_Mem_Init
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Mem_Init(
  void
  )
{
  uint8 lResetStoredData;
  Dem_EventIdType lEventId;
#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
  Dem_EventIdType lDebounceNvIndex = 0;
#endif

  for (lEventId = 0; lEventId < Dem_Cfg_GlobalEventCount(); ++lEventId)
  { /* Only reset stored status, since debouncing can have changed since pre-initalization */
    Dem_Mem_EventSetInternalStatus(lEventId,
      DEM_ESM_SET_STORED_STATUS(Dem_Mem_EventGetInternalStatus(lEventId), DEM_ESM_STORED_STATUS_NONE));

#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
    /* #030 If NV storage of debounce values is configured, and the event uses that feature */
    /* Its safe to do it here since supporting events are not allowed to report before Dem_Init() */
    if (FALSE != Dem_Cfg_EventSupportDebounceNv(lEventId))
    {
      Dem_Internal_AssertReturnVoid(lDebounceNvIndex < Dem_Cfg_GlobalDebounceStorageEventCount(), DEM_E_INCONSISTENT_STATE)

      if ( /* Unqualified debounce state is ok */
           ( (Dem_Cfg_EventFailedTarget(lEventId) > Dem_Cfg_DebounceData[lDebounceNvIndex])
          && (Dem_Cfg_EventPassedTarget(lEventId) < Dem_Cfg_DebounceData[lDebounceNvIndex]) )
           /* If debouncing counter has reached qualified threshold, the event status must match */
        || ( (Dem_Cfg_EventFailedTarget(lEventId) == Dem_Cfg_DebounceData[lDebounceNvIndex])
          && (FALSE != DEM_ESM_TEST_UDS_STATUS_TF(Dem_Mem_EventGetStatus(lEventId))) )
        || ( (Dem_Cfg_EventPassedTarget(lEventId) == Dem_Cfg_DebounceData[lDebounceNvIndex])
          && (FALSE == DEM_ESM_TEST_UDS_STATUS_TF(Dem_Mem_EventGetStatus(lEventId))) ) )
      {
        /* #50 Validate the NV debounce value. Discard out of range values, and restore a valid value into working RAM */
        /* implausible data e.g. due to debouncing thresholds changed by calibration */
        Dem_Mem_EventSetDebounceValue(lEventId, Dem_Cfg_DebounceData[lDebounceNvIndex]);
      }
      ++lDebounceNvIndex;
    }
#endif
  }

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  {
    Dem_Cfg_CombinedGroupIndexType lGroupId;
    for (lGroupId = 0; lGroupId < Dem_Cfg_GlobalCombinedGroupCount(); ++lGroupId)
    {
      Dem_Cfg_EventInternalStatusType lInternalStatus;
      /* #070 Initialize the combination group internal status */
      lInternalStatus = DEM_ESM_STORED_STATUS_NONE;

      /* #080 For all combination groups, test if at least one sub-events is available by configuration. */
# if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
      { /* Initialization in PreInit and Init can have different settings for
           event availability, so repeat the calculation for combined DTCs */
        Dem_Cfg_CombinedGroupIterType lSubEventIter;
        for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lSubEventIter);                                                            /* PRQA S 3418 */ /* MD_DEM_12.10 */
             (FALSE != Dem_Cfg_CombinedGroupIterExists(lGroupId, &lSubEventIter));
             Dem_Cfg_CombinedGroupIterNext(lGroupId, &lSubEventIter))
        {
          if (FALSE != Dem_Cfg_EventAvailableInVariant(Dem_Cfg_CombinedGroupIterGet(lGroupId, &lSubEventIter)))
          { /* #090 If so, set the availability in the combination status. */
            lInternalStatus = DEM_ESM_SET_AVAILABLEINVARIANT(lInternalStatus);
            break;
          }
        }
      }
# endif
      Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, lInternalStatus);
    }
  }
#endif
  /* #100 Initialize transactional update commit numbers */
  Dem_MemSet(Dem_Cfg_MemoryCommitNumber, DEM_MEM_INIT_COMMIT_NUMBER, Dem_Cfg_GlobalNvBlockCount()*sizeof(uint8));                /* PRQA S 0312, 0602, 3109 */ /* MD_DEM_11.5, MD_DEM_20.2, MD_MSR_14.3 */

  lResetStoredData = (uint8)( (Dem_Cfg_AdminData.ImplementationVersion != DIAG_ASR4DEM_VERSION)
                           || (Dem_Cfg_AdminData.ConfigurationId != Dem_Cfg_GlobalConfigurationId()) );

  if (lResetStoredData != FALSE)
  {
    /* #110 If the NV data is not compatible to the configuration */
    /* #120 Re-initialize all NV data content and reset the global time stamp */
    Dem_Cfg_MemoryIndexType lMemoryIndex;
    Dem_Cfg_MemoryIndexType lMemoryIndexEnd;

    Dem_MemSet(Dem_Cfg_MemoryStatus, DEM_NVM_BLOCKSTATE_DIRTY, Dem_Cfg_GlobalNvBlockCount()*sizeof(uint8));                      /* PRQA S 0602, 3109 */ /* MD_DEM_20.2, MD_MSR_14.3 */

    (void)Dem_NvM_InitAdminData();
    (void)Dem_NvM_InitStatusData();
#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
    (void)Dem_NvM_InitDebounceData();
#endif

    Dem_Mem_CurrentTimestamp = 1U;
    Dem_Mem_PrimaryCurrentCount = 0U;

#if (DEM_FEATURE_NEED_SECONDARY == STD_ON)
    Dem_Mem_SecondaryCurrentCount = 0U;
#endif
    lMemoryIndexEnd = Dem_Mem_MemoryIndexAll_End();
    for (lMemoryIndex = Dem_Mem_MemoryIndexAll_Begin(); lMemoryIndex < lMemoryIndexEnd; ++lMemoryIndex)
    {
      Dem_Mem_EntryPtrType lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);                                                        /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
      Dem_MemCpy((Dem_NvDataPtrType)lEntry,                                                                                      /* PRQA S 0310, 0311, 0602 */ /* MD_DEM_11.4_cpy, MD_DEM_11.5, MD_DEM_20.2 */
                 (Dem_ConstDataPtrType)(&Dem_MemoryEntryInit),                                                                   /* PRQA S 0311 */ /* MD_DEM_11.5 */
                 sizeof(*lEntry));
      Dem_Mem_MemoryUpdateInit(lMemoryIndex);
    }
  }
  /* #130 Otherwise */
  else
  {
    Dem_Mem_CurrentTimestamp = 0U;

    /* #140 Rebuild the event memory control data from NV data contents */
#if (DEM_CFG_ISCONST_DESTINATION == STD_ON)
    Dem_Mem_Init_RestoreMemory();
#else
    Dem_Mem_Init_RestoreMemory(&Dem_Mem_PrimaryInfo);
# if (DEM_FEATURE_NEED_SECONDARY == STD_ON)
    Dem_Mem_Init_RestoreMemory(&Dem_Mem_SecondaryInfo);
# endif
#endif

#if (DEM_CFG_SUPPORT_OPCYCLE_STORAGE == STD_ON)
    /* #160 If operation cycle states are stored in NV, restore them */
    Dem_Mem_CurrentCycleState = Dem_Cfg_AdminData.CycleState;
#endif
  }
#if (DEM_CFG_SUPPORT_INDICATORS == STD_ON)
  {
    /* #190 If indicators are configured, initialize all indicator state counters */
    uint8 lIndicatorId;
    for (lIndicatorId = 0; lIndicatorId < Dem_Cfg_GlobalIndicatorCount(); ++lIndicatorId)
    {
      {
        Dem_Cfg_IndicatorContinuous[lIndicatorId][DEM_J1939_NODE_ID] = 0;
        Dem_Cfg_IndicatorBlinking[lIndicatorId][DEM_J1939_NODE_ID] = 0;
      }
    }
  }
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  /* #200 If prestore freeze frame is enabled, initialize freeze frame prestorage */
  Dem_Mem_PrestorageInit();
#endif
}                                                                                                                                /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MST_STCYC, MD_MSR_STCAL */

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Esm_DebounceInfoInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_DebounceInfoInit(
  Dem_EventIdType EventId,
  P2VAR(Dem_DebounceInfoType, AUTOMATIC, AUTOMATIC) DebounceInfo
  )
{
  DebounceInfo->Common.EventId = EventId;
  DebounceInfo->Common.FunctionTable = &Dem_Esm_DebounceFunctionTable[Dem_Cfg_EventDebounceType(EventId)];
}

/* ****************************************************************************
 % Dem_Esm_AddCycleCount
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint16, DEM_CODE)
Dem_Esm_AddCycleCount(
  uint16  CurrentCounter,
  uint8  DeltaValue
  )
{
  uint16 lTargetCycle;

  lTargetCycle = (uint16)(CurrentCounter + DeltaValue);

  if (lTargetCycle > DEM_ESM_CYCLECOUNT_MAX)
  { /* Overflow needs to wrap around at DEM_ESM_CYCLECOUNT_MAX */
    lTargetCycle = (uint16)(lTargetCycle - DEM_ESM_CYCLECOUNT_MAX);
  }

  return lTargetCycle;
}

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Esm_PrestorageDiscard
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PrestorageDiscard(
  void
  )
{
  if (DEM_MEM_INVALID_PRESTORAGE_INDEX != Dem_Esm_PrestorageLockedIndex)
  {
    Dem_Mem_PrestoredEntrySetState(Dem_Mem_PrestorageGetEntry(Dem_Esm_PrestorageLockedIndex), DEM_ESM_PRESTORED_STATUS_DISCARDED);
  }
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventPrestorageLock
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventPrestorageLock(
  Dem_EventIdType  EventId
  )
{
  Dem_Cfg_PrestorageIndexType lPrestorageIndex;

  if (DEM_MEM_INVALID_PRESTORAGE_REF != Dem_Cfg_EventPrestorageIndex(EventId))
  {
    lPrestorageIndex = Dem_Mem_PrestorageFindEntry(EventId);
    if (DEM_MEM_INVALID_PRESTORAGE_INDEX != lPrestorageIndex)
    {
      Dem_Mem_PrestoredEntryPtrType lPrestoredEntry;
      lPrestoredEntry = Dem_Mem_PrestorageGetEntry(lPrestorageIndex);
      if (DEM_ESM_PRESTORED_STATUS_READY == Dem_Mem_PrestoredEntryGetState(lPrestoredEntry))
      {
        Dem_Mem_PrestoredEntrySetState(lPrestoredEntry, DEM_ESM_PRESTORED_STATUS_LOCKED);
        Dem_Mem_PrestorageSetRef(EventId, DEM_MEM_INVALID_PRESTORAGE_INDEX);
        Dem_Esm_PrestorageLockedIndex = lPrestorageIndex;
      }
    }
  }
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventPrestorageRelease
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventPrestorageRelease(
  void
  )
{
  if (DEM_MEM_INVALID_PRESTORAGE_INDEX != Dem_Esm_PrestorageLockedIndex)
  {
    Dem_Mem_PrestoredEntryPtrType lPrestoredEntry;
    Dem_EventIdType lEventId;

    lPrestoredEntry = Dem_Mem_PrestorageGetEntry(Dem_Esm_PrestorageLockedIndex);
    lEventId = lPrestoredEntry->EventId;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */

    if (DEM_ESM_PRESTORED_STATUS_LOCKED == Dem_Mem_PrestoredEntryGetState(lPrestoredEntry))
    { /* Entry unused, return it to the event */
      Dem_Cfg_PrestorageIndexType lPrestorageIndex;
      lPrestorageIndex = Dem_Mem_PrestorageFindEntry(lEventId);
      if (DEM_MEM_INVALID_PRESTORAGE_INDEX != lPrestorageIndex)
      { /* Event has created a new prestored slot since locking the old, so free the locked entry */
        Dem_Mem_PrestoredEntrySetState(lPrestoredEntry, DEM_ESM_PRESTORED_STATUS_FREE);
        Dem_Mem_PrestorageFreeEntry(Dem_Esm_PrestorageLockedIndex);
        /* FreeEntry removes the prestored block from the event, repair the link */
        Dem_Mem_PrestorageSetRef(lEventId, lPrestorageIndex);
      }
      else
      { /* Return the unused prestorage entry to the event*/
        Dem_Mem_PrestoredEntrySetState(lPrestoredEntry, DEM_ESM_PRESTORED_STATUS_READY);
        Dem_Mem_PrestorageSetRef(lEventId, Dem_Esm_PrestorageLockedIndex);
      }
    }
    else
    {
      Dem_Mem_PrestoredEntrySetState(lPrestoredEntry, DEM_ESM_PRESTORED_STATUS_FREE);
      Dem_Mem_PrestorageFreeEntry(Dem_Esm_PrestorageLockedIndex);
    }

    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* >>>> -------------------------------- Leave Critical Section: DiagMonitor */

    Dem_Esm_PrestorageLockedIndex = DEM_MEM_INVALID_PRESTORAGE_INDEX;
  }
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventPrestorageUpdate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventPrestorageUpdate(
  Dem_EventIdType  EventId
  )
{
  Std_ReturnType lReturnValue;
  Dem_Cfg_PrestorageIndexType lPrestorageIndex;
  Dem_Mem_PrestoredEntryPtrType lPrestoredEntry;

  lPrestoredEntry = NULL_PTR;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lPrestorageIndex = Dem_Mem_PrestorageFindEntry(EventId);
  if (DEM_MEM_INVALID_PRESTORAGE_INDEX != lPrestorageIndex)
  { /* there already is an entry allocated to this event */
    lPrestoredEntry = Dem_Mem_PrestorageGetEntry(lPrestorageIndex);
    Dem_Mem_PrestoredEntrySetState(lPrestoredEntry, DEM_ESM_PRESTORED_STATUS_UPDATING);
  }
  else
  { /* try to find a free entry for this event */
    lPrestorageIndex = Dem_Mem_PrestorageAllocateEntry(EventId);
    if (DEM_MEM_INVALID_PRESTORAGE_INDEX != lPrestorageIndex)
    {
      lPrestoredEntry = Dem_Mem_PrestorageGetEntry(lPrestorageIndex);
      Dem_Mem_PrestoredEntrySetState(lPrestoredEntry, DEM_ESM_PRESTORED_STATUS_UPDATING);
    }
  }

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* >>>> -------------------------------- Leave Critical Section: DiagMonitor */

  if (NULL_PTR != lPrestoredEntry)
  {
    Dem_Data_PrestorageEntryUpdate(EventId, lPrestoredEntry);
    Dem_Mem_PrestoredEntrySetState(lPrestoredEntry, DEM_ESM_PRESTORED_STATUS_READY);
    lReturnValue = E_OK;
  }
  else
  {
    lReturnValue = E_NOT_OK;
  }

  return lReturnValue;
}
#endif

/* ****************************************************************************
 % Dem_Esm_EventCreateMemory
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Esm_EventCreateMemory(
  Dem_EventIdType  EventId
  )
{
  DEM_MEM_MEMORYINFO_PARAM_VARDEF
  Dem_Cfg_MemoryIndexType lMemoryIndex;

  DEM_MEM_MEMORYINFO_PARAM_INIT(Dem_Cfg_EventDestination(EventId))
  lMemoryIndex = Dem_Mem_MemoryAllocateIndex(EventId);
  if (lMemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX)
  { /* Created new entry */
    Dem_Cfg_EventInternalStatusType lInternalStatus;
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
    Dem_Cfg_CombinedGroupIndexType lGroupId;

    lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
    if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
    {
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
      Dem_EnterCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
      lInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);
      lInternalStatus = DEM_ESM_SET_STORED_STATUS(lInternalStatus, DEM_ESM_STORED_STATUS_ACTIVE);
      Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, lInternalStatus);
      Dem_LeaveCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* >>>> -------------------------------- Leave Critical Section: DiagMonitor */
    }
    else
#endif
    {
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
      Dem_EnterCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
      lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
      lInternalStatus = DEM_ESM_SET_STORED_STATUS(lInternalStatus, DEM_ESM_STORED_STATUS_ACTIVE);
      Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);
      Dem_LeaveCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* >>>> -------------------------------- Leave Critical Section: DiagMonitor */
    }

#if (DEM_CFG_ISCONST_NVM_IMMEDIATE != STD_ON)
    if (FALSE != Dem_Cfg_EventSupportImmediateNv(EventId))
#endif
    {
#if (DEM_FEATURE_NEED_DIRTYIMMEDIATE == STD_ON)
      Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTYIMMEDIATE);
#endif
    }
#if (DEM_CFG_ISCONST_NVM_IMMEDIATE != STD_ON)
    else
#endif
    {
#if (DEM_FEATURE_NEED_DIRTY == STD_ON)
      Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
#endif
    }
  }
  else
  {
    lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;
  }
  return lMemoryIndex;
}

/* ****************************************************************************
 % Dem_Esm_EventUpdateMemory
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Esm_EventUpdateMemory(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  boolean  Occurrence
  )
{
  DEM_MEM_MEMORYINFO_PARAM_VARDEF
  Dem_Cfg_MemoryIndexType lMemoryIndex;

  DEM_IGNORE_UNUSED_ARGUMENT(EventId)                                                                                            /* PRQA S 3112 */ /* MD_DEM_14.2 */
  DEM_MEM_MEMORYINFO_PARAM_INIT(Dem_Cfg_EventDestination(EventId))

  /* #010 Get the events memory entry */
  lMemoryIndex = Dem_Mem_MemoryFindIndex(EventId);

#if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
  /* #030 If event aging does keeps event data and the entry is already aged */
  if (DEM_ESM_CYCLECOUNT_EVENT_AGED == Dem_Mem_EntryGetAgingCount(Dem_Mem_MemoryGetEntry(lMemoryIndex)))                         /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
  {
    /* #040 Initialize the memory entry */
    Dem_Data_EntryInit(Dem_Mem_MemoryGetEntry(lMemoryIndex));                                                                    /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
    /* #050 If the maximum FDC since last clear statistic is enabled */
# if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
#  if ((DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) && (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON))
    if (DEM_CFG_DEBOUNCETYPE_TIMER == Dem_Cfg_EventDebounceType(EventId))
#  endif
    {
      /* #060 For time based events, set the max FDC SLC to the events failed time */
#  if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
      Dem_Mem_EntrySetDebounceValueMax(Dem_Mem_MemoryGetEntry(lMemoryIndex), Dem_Cfg_EventFailedTime(EventId));                  /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
#  endif
    }
#  if ((DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) && (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON))
    else
#  endif
    {
      /* #070 For counter based events, set the max FDC SLC to 0 */
#  if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
      Dem_Mem_EntrySetDebounceValueMax(Dem_Mem_MemoryGetEntry(lMemoryIndex), 0);                                                 /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
#  endif
    }
# endif
  }
#endif
  /* #080 If the update was an occurrence */
  if (FALSE != Occurrence)
  {
    /* #090 Update the chronology */
    Dem_Mem_MemoryUpdateIndex(lMemoryIndex);

#if (DEM_CFG_ISCONST_NVM_IMMEDIATE != STD_ON)
    if (FALSE != Dem_Cfg_EventSupportImmediateNv(EventId))
#endif
    {
      /* #100 If the event is configured for immediate NV updates, set the entries NV state to immediate update */
#if (DEM_FEATURE_NEED_DIRTYIMMEDIATE == STD_ON)
      Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTYIMMEDIATE);
#endif
    }
#if (DEM_CFG_ISCONST_NVM_IMMEDIATE != STD_ON)
    else
#endif
    {
      /* #110 Otherwise set the entries NV state to 'DIRTY' */
#if (DEM_FEATURE_NEED_DIRTY == STD_ON)
      Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
#endif
    }
  }

  return lMemoryIndex;
}

#if (DEM_FEATURE_NEED_USER_INDICATORS == STD_ON)
/* ****************************************************************************
 % Dem_Esm_UserIndicatorEnable
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_UserIndicatorEnable(
  Dem_EventIdType  EventId
  )
{
  Dem_Cfg_EventIndicatorIterType lIndicatorIter;

  /* #010 For every indicator attached to the event */
  for (Dem_Cfg_EventIndicatorIterInit(EventId, &lIndicatorIter);                                                                 /* PRQA S 3198, 3418 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
       FALSE != Dem_Cfg_EventIndicatorIterExists(EventId, &lIndicatorIter);
       Dem_Cfg_EventIndicatorIterNext(EventId, &lIndicatorIter))
  {
    Dem_Cfg_IndicatorIndexType lIndicatorIndex;
    lIndicatorIndex = Dem_Cfg_EventIndicatorIterGet(EventId, &lIndicatorIter);

    {
      /* #030 Increment the (node specific) indicator counter for continuous or blinking, according to configuration */
# if (DEM_CFG_ISCONST_USERINDICATORSTATE != STD_ON)
      if (0 != (DEM_INDICATOR_CONTINUOUS & Dem_Cfg_IndicatorStatus(lIndicatorIndex)))
# endif
# if (DEM_FEATURE_NEED_USER_INDICATOR_CONTINUOUS == STD_ON)
      {
        Dem_Cfg_IndicatorContinuous[Dem_Cfg_IndicatorId(lIndicatorIndex)][DEM_J1939_NODE_ID] =
          (uint16)(Dem_Cfg_IndicatorContinuous[Dem_Cfg_IndicatorId(lIndicatorIndex)][DEM_J1939_NODE_ID] + 1);
      }
# endif
# if (DEM_CFG_ISCONST_USERINDICATORSTATE != STD_ON)
      if (0 != (DEM_INDICATOR_BLINKING & Dem_Cfg_IndicatorStatus(lIndicatorIndex)))
# endif
# if (DEM_FEATURE_NEED_USER_INDICATOR_BLINKING == STD_ON)
      {
        Dem_Cfg_IndicatorBlinking[Dem_Cfg_IndicatorId(lIndicatorIndex)][DEM_J1939_NODE_ID] =
          (uint16)(Dem_Cfg_IndicatorBlinking[Dem_Cfg_IndicatorId(lIndicatorIndex)][DEM_J1939_NODE_ID] + 1);
      }
# endif
    }
  }
}
#endif /* (DEM_FEATURE_NEED_USER_INDICATORS == STD_ON) */

#if (DEM_FEATURE_NEED_USER_INDICATORS == STD_ON)
/* ****************************************************************************
 % Dem_Esm_UserIndicatorDisable
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_UserIndicatorDisable(
  Dem_EventIdType  EventId
  )
{
  Dem_Cfg_EventIndicatorIterType lIndicatorIter;

  for (Dem_Cfg_EventIndicatorIterInit(EventId, &lIndicatorIter);                                                                 /* PRQA S 3198, 3418 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
       FALSE != Dem_Cfg_EventIndicatorIterExists(EventId, &lIndicatorIter);
       Dem_Cfg_EventIndicatorIterNext(EventId, &lIndicatorIter))
  {
    Dem_Cfg_IndicatorIndexType lIndicatorIndex;

    lIndicatorIndex = Dem_Cfg_EventIndicatorIterGet(EventId, &lIndicatorIter);

    {
# if (DEM_CFG_ISCONST_USERINDICATORSTATE != STD_ON)
      if (0 != (DEM_INDICATOR_CONTINUOUS & Dem_Cfg_IndicatorStatus(lIndicatorIndex)))
# endif
# if (DEM_FEATURE_NEED_USER_INDICATOR_CONTINUOUS == STD_ON)
      {
        Dem_Cfg_IndicatorContinuous[Dem_Cfg_IndicatorId(lIndicatorIndex)][DEM_J1939_NODE_ID] =
          (uint16)(Dem_Cfg_IndicatorContinuous[Dem_Cfg_IndicatorId(lIndicatorIndex)][DEM_J1939_NODE_ID] - 1);
      }
# endif
# if (DEM_CFG_ISCONST_USERINDICATORSTATE != STD_ON)
      if (0 != (DEM_INDICATOR_BLINKING & Dem_Cfg_IndicatorStatus(lIndicatorIndex)))
# endif
# if (DEM_FEATURE_NEED_USER_INDICATOR_BLINKING == STD_ON)
      {
        Dem_Cfg_IndicatorBlinking[Dem_Cfg_IndicatorId(lIndicatorIndex)][DEM_J1939_NODE_ID] =
          (uint16)(Dem_Cfg_IndicatorBlinking[Dem_Cfg_IndicatorId(lIndicatorIndex)][DEM_J1939_NODE_ID] - 1);
      }
# endif
    }
  }
}
#endif /* DEM_FEATURE_NEED_USER_INDICATORS */

#if (DEM_FEATURE_NEED_TESTSUPPRESSION == STD_ON)
/* ****************************************************************************
 % Dem_Esm_TestDtcSuppressed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_TestDtcSuppressed(
  Dem_EventIdType  EventId
  )
{
  boolean lReturnValue;
# if (DEM_FEATURE_NEED_SUPPRESSION == STD_ON) || (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
  Dem_Cfg_EventInternalStatusType lInternalStatus;

  lInternalStatus = Dem_Util_DtcGetInternalStatus(EventId);
#endif

  if (
# if (DEM_FEATURE_NEED_SUPPRESSION == STD_ON)
      ((lInternalStatus & (DEM_ESM_SUPPRESSED_DTC | DEM_ESM_SUPPRESSED_EVENT)) != 0)                                             /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
# endif
# if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
#  if (DEM_FEATURE_NEED_SUPPRESSION == STD_ON)
    ||
#  endif
      (FALSE == Dem_Util_DtcAvailableInVariant(EventId))
# endif
# if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
#  if (DEM_FEATURE_NEED_SUPPRESSION == STD_ON) || (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
    ||
#  endif
      ( ((lInternalStatus & DEM_ESM_DISCONNECTED_EVENT) != 0)
      && (DEM_ESM_STORED_STATUS_NONE == DEM_ESM_GET_STORED_STATUS(lInternalStatus)) )
# endif
    )
  {
    lReturnValue = TRUE;
  }
  else
  {
    lReturnValue = FALSE;
  }

  return lReturnValue;
}
#endif /* (DEM_FEATURE_NEED_TESTSUPPRESSION == STD_ON) */

#if (DEM_FEATURE_NEED_LATCHTESTFAILED == STD_ON)
/* ****************************************************************************
 % Dem_Esm_TestLatchedTestFailed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_TestLatchedTestFailed(
  Dem_EventIdType EventId
)
{
  boolean lReturnValue;

  if ( (FALSE == Dem_Cfg_EventLatchTestFailed(EventId))
    || (0 == ((DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_CDTC) & (Dem_Mem_EventGetStatus(EventId))))
     )
  {
    lReturnValue = FALSE;
  }
  else
  {
    lReturnValue = TRUE;
  }
  return lReturnValue;
}
#endif

#if (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
/* ****************************************************************************
 % Dem_Esm_TestEventHealed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_TestEventHealed(
  Dem_EventIdType EventId,                                                                                                       /* PRQA S 3206 */ /* MD_DEM_3206 */
  uint8 EventStatus                                                                                                              /* PRQA S 3206 */ /* MD_DEM_3206 */
)
{
  boolean lReturnValue;

  DEM_IGNORE_UNUSED_ARGUMENT(EventId)                                                                                            /* PRQA S 3112 */ /* MD_DEM_14.2 */
  DEM_IGNORE_UNUSED_ARGUMENT(EventStatus)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */

# if (DEM_CFG_AGING_AFTER_HEALING_ALL_DTC == STD_ON)
#  if (DEM_CFG_ISCONST_HEALINGTARGET != STD_ON)
  if (Dem_Cfg_EventHealingTarget(EventId) == 0)
#  endif
  {
#  if (DEM_FEATURE_NEED_IMMEDIATEHEAL == STD_ON)
    lReturnValue = ( (DEM_ESM_TEST_UDS_STATUS_TF(EventStatus) == FALSE)
                  && (DEM_ESM_TEST_UDS_STATUS_TNCTOC(EventStatus) == FALSE) );
#  endif
  }
#  if (DEM_CFG_ISCONST_HEALINGTARGET != STD_ON)
  else /* Dem_Cfg_EventHealingTarget(EventId) > 0 */
#  endif
  {
#  if (DEM_FEATURE_NEED_SINGLEHEAL == STD_ON)
    lReturnValue = (DEM_ESM_TEST_UDS_STATUS_PDTC(EventStatus) == FALSE);
#  elif (DEM_FEATURE_NEED_MULTIHEAL == STD_ON)
    lReturnValue = ( (Dem_Mem_EventGetTripCount(EventId) == 0)
             && (DEM_ESM_TEST_UDS_STATUS_PDTC(EventStatus) == FALSE) );
#  endif
  }
# else
  lReturnValue = (boolean)(DEM_ESM_TEST_UDS_STATUS_WIR(EventStatus) == FALSE);
# endif

  return lReturnValue;
}
#endif /* (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON) */

#if (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON) \
   && ((DEM_FEATURE_NEED_HEALING == STD_ON) \
     && ((DEM_CFG_AGING_START_TESTS_TFTOC == STD_OFF) || (DEM_CFG_AGING_AT_PASSED_00_TARGET_ONLY == STD_ON)) \
     || (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON))
/* ****************************************************************************
 % Dem_Esm_TestDtcHealed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_TestDtcHealed(
Dem_EventIdType EventId
)
{
  boolean lReturnValue;
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
# endif

# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (lGroupId != DEM_CFG_COMBINED_GROUP_INVALID)
  {
    Dem_Cfg_CombinedGroupIterType lGroupIter;
    for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lGroupIter);                                                                   /* PRQA S 3198, 3418 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
         Dem_Cfg_CombinedGroupIterExists(lGroupId, &lGroupIter) != FALSE;
         Dem_Cfg_CombinedGroupIterNext(lGroupId, &lGroupIter))
    {
      Dem_EventIdType lSubEvent;
      lSubEvent = Dem_Cfg_CombinedGroupIterGet(lGroupId, &lGroupIter);
      if (Dem_Esm_TestEventHealed(lSubEvent, Dem_Mem_EventGetStatus(lSubEvent)) == FALSE)
      {
        break;
      }
    }
    lReturnValue = !(Dem_Cfg_CombinedGroupIterExists(lGroupId, &lGroupIter));
  }
  else
# endif
  {
    lReturnValue = Dem_Esm_TestEventHealed(EventId, Dem_Mem_EventGetStatus(EventId));
  }

  return lReturnValue;
}
#endif /* (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON) */

/* ****************************************************************************
 % Dem_Esm_EventResetDebounceState
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventResetDebounceState(
  Dem_EventIdType  EventId,
  Dem_DebounceResetStatusType  Status
  )
{
  Dem_DebounceInfoType lDebounceInfo;
  Dem_Esm_DebounceInfoInit(EventId, &lDebounceInfo);

  if (Status == DEM_DEBOUNCE_STATUS_RESET)
  {
    lDebounceInfo.Common.FunctionTable->Reset(&lDebounceInfo);
  }
  else
  {
    lDebounceInfo.Common.FunctionTable->Freeze(&lDebounceInfo);
  }
}

#if (DEM_FEATURE_NEED_DEBOUNCE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventResetDebounceValues
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventResetDebounceValues(
  Dem_EventIdType  EventId
  )
{
  /* #010 Reset the events debouncing state */
  Dem_Mem_EventSetDebounceValue(EventId, 0);

# if (DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE == STD_ON)
#  if ((DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) && (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON))
  if (DEM_CFG_DEBOUNCETYPE_TIMER == Dem_Cfg_EventDebounceType(EventId))
#  endif
  {
#  if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
    /* #030 If the event use time based debouncing, set the max debounce value to the failed time */
    Dem_Mem_EventSetDebounceValueMax(EventId, Dem_Cfg_EventFailedTime(EventId));
#  endif
  }
#  if ((DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) && (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON))
  else
#  endif
  {
#  if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
    /* #040 If the event use counter based debouncing, set the max debounce value to 0 */
    Dem_Mem_EventSetDebounceValueMax(EventId, 0);
#  endif
  }
# endif
}
#endif /* (DEM_FEATURE_NEED_DEBOUNCE == STD_ON) */

#if (DEM_FEATURE_NEED_EVENTAVAILABLE_DEFAULT == STD_ON) || (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventSetDisconnectedBit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventSetDisconnectedBit(
  Dem_EventIdType EventId,
  boolean IsDisconnected
)
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;
  lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);

  if (IsDisconnected == TRUE)
  {
    lInternalStatus = DEM_ESM_SET_EVENT_DISCONNECTED(lInternalStatus);
    Dem_Mem_EventSetStatus(EventId, 0x00);
  }
  else
  {
    lInternalStatus = DEM_ESM_RESET_EVENT_DISCONNECTED(lInternalStatus);
  }

  Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);
}
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventMayDisconnect
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventMayDisconnect(
  Dem_EventIdType EventId
)
{
  boolean lReturnValue;
  uint8 lEventStatus;
  Dem_Cfg_EventInternalStatusType lInternalStatus;

  lEventStatus = Dem_Mem_EventGetStatus(EventId);
  lInternalStatus = Dem_Util_DtcGetInternalStatus(EventId);

  if ( (DEM_ESM_TEST_UDS_STATUS_TF(lEventStatus) == FALSE)
    && (DEM_ESM_TEST_UDS_STATUS_WIR(lEventStatus) == FALSE)
    && (DEM_ESM_TEST_UDS_STATUS_CDTC(lEventStatus) == FALSE)
     )
  {
    if (DEM_ESM_STORED_STATUS_NONE == DEM_ESM_GET_STORED_STATUS(lInternalStatus))
    {
      lReturnValue = TRUE;
    }
    else
    {
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
      Dem_Cfg_CombinedGroupIndexType lGroupId;

      lReturnValue = FALSE;
      lGroupId = Dem_Cfg_EventCombinedGroup(EventId);

      /* If a combined event has a stored DTC, only allow disabling a subevent 
         if at least one other event is enabled */
      if (lGroupId != DEM_CFG_COMBINED_GROUP_INVALID)
      {
        Dem_Cfg_CombinedGroupIterType lCombinedIter;

        for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lCombinedIter);                                                            /* PRQA S 3198, 3418 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
            (FALSE != Dem_Cfg_CombinedGroupIterExists(lGroupId, &lCombinedIter));
            Dem_Cfg_CombinedGroupIterNext(lGroupId, &lCombinedIter))
        {
          Dem_EventIdType lSubEventId;
          lSubEventId = Dem_Cfg_CombinedGroupIterGet(lGroupId, &lCombinedIter);
          if ( (lSubEventId != EventId) 
            && (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(lSubEventId))) )
          {
            lReturnValue = TRUE;
            break;
          }
        }
      }
      else
# endif
      {
        lReturnValue = FALSE;
      }
    }
  }
  else
  {
    lReturnValue = FALSE;
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) && (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventDisconnect_Combined
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventDisconnect_Combined(
  Dem_EventIdType  EventId
  )
{
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  Dem_Cfg_EventInternalStatusType lInternalStatus;
  Dem_Cfg_EventInternalStatusType lGroupInternalStatus;

  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
  lGroupInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);

  /* #030 Set the internal event status to disconnected */
  lInternalStatus = DEM_ESM_SET_EVENT_DISCONNECTED(lInternalStatus);

  /* #040 Remove all pending actions */
# if (DEM_CFG_SUPPORT_DEBOUNCE_TIME == STD_ON)
  lInternalStatus = DEM_ESM_SET_DEBOUNCE_STATUS(lInternalStatus, DEM_ESM_DEBOUNCE_STATUS_NONE);
# endif
# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  lInternalStatus = DEM_ESM_RESET_FDC_TRIP(lInternalStatus);
# endif
# if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
  lInternalStatus = DEM_ESM_RESET_FDC_MAX(lInternalStatus);
# endif

  Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);
  /* #050 Remove the event from the queue */
  Dem_Queue_ResetPendingEvent(EventId);
  /* #060 Set the event status to 0x00 */
  Dem_Mem_EventSetStatus(EventId, 0x00U);

# if (DEM_FEATURE_NEED_DEBOUNCE == STD_ON)
  /*  #070 Reset the events debouncing state */
  Dem_Esm_EventResetDebounceValues(EventId);
# endif
  /* #080 If the combination group is not fully disconnected */
  if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(lGroupInternalStatus))
  { /* If all Events belonging to a DTC are disconnected, that DTC is disconnected as well */
    /* If all connected events are suppressed or disconnected, the DTC is suppressed as well */
    uint8 lCombinedGroupStatus;
    boolean lDoDisconnect;
# if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
    boolean lDoSuppress;
# endif
    Dem_Cfg_CombinedGroupIterType lCombinedIter;

    lCombinedGroupStatus = 0x00;
    lDoDisconnect = TRUE;
# if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
    lDoSuppress = TRUE;
# endif

    for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lCombinedIter);                                                                /* PRQA S 3198, 3418 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
         (FALSE != Dem_Cfg_CombinedGroupIterExists(lGroupId, &lCombinedIter));
         Dem_Cfg_CombinedGroupIterNext(lGroupId, &lCombinedIter))
    {
      Dem_EventIdType lSubEventId;
      lSubEventId = Dem_Cfg_CombinedGroupIterGet(lGroupId, &lCombinedIter);
# if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
      if (FALSE != Dem_Cfg_EventAvailableInVariant(lSubEventId))
# endif
      {
        /* #090 If all events are disconnected now, the combined group is set to disconnected */
        lDoDisconnect = (boolean)(lDoDisconnect && (FALSE != DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(lSubEventId))));
# if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
        /* #100 (If suppression is supported) If all events are either disconnected or suppressed, the combined group
         *      is suppressed */
        lDoSuppress = (boolean)(lDoSuppress && ( (FALSE != DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(lSubEventId)))
                                              || (FALSE != DEM_ESM_TEST_EVENT_SUPPRESSED(Dem_Mem_EventGetInternalStatus(lSubEventId))) ) );
# endif
        /* #110 Calculate the combined event status - logical 'or' of all connected event status bytes */
        lCombinedGroupStatus = (uint8)(lCombinedGroupStatus | Dem_Mem_EventGetStatus(lSubEventId));
      }
    }
    if (FALSE != lDoDisconnect)
    {
      /* #090 If all events are disconnected now, the combined group is set to disconnected */
      lGroupInternalStatus = DEM_ESM_SET_EVENT_DISCONNECTED(lGroupInternalStatus);
    }
# if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
    if (FALSE != lDoSuppress)
    {
      /* #100 (If suppression is supported) If all events are either disconnected or suppressed, the combined group
       *      is suppressed */
      lGroupInternalStatus = DEM_ESM_SET_EVENT_SUPPRESSED(lGroupInternalStatus);
    }
# endif
    Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, lGroupInternalStatus);
    Dem_Mem_CombinedGroupSetStatus(lGroupId, lCombinedGroupStatus);
  }
# if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  if (DEM_MEM_INVALID_PRESTORAGE_REF != Dem_Cfg_EventPrestorageIndex(EventId))
  { /* #120 Clear a present prestored freeze frame */
    (void)Dem_Esm_EventPrestorageClear(EventId);
  }
# endif
}
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventDisconnect_Normal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventDisconnect_Normal(
  Dem_EventIdType  EventId
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;

  /* #030 Set the internal event status to disconnected */
  lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
  lInternalStatus = DEM_ESM_SET_EVENT_DISCONNECTED(lInternalStatus);

  /* #040 Remove all pending actions */
# if (DEM_CFG_SUPPORT_DEBOUNCE_TIME == STD_ON)
  lInternalStatus = DEM_ESM_SET_DEBOUNCE_STATUS(lInternalStatus, DEM_ESM_DEBOUNCE_STATUS_NONE);
# endif
# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  lInternalStatus = DEM_ESM_RESET_FDC_TRIP(lInternalStatus);
# endif
# if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
  lInternalStatus = DEM_ESM_RESET_FDC_MAX(lInternalStatus);
# endif
  Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);
  /* #050 Remove the event from the queue */
  Dem_Queue_ResetPendingEvent(EventId);
  /* #060 Set the event status to 0x00 */
  Dem_Mem_EventSetStatus(EventId, 0x00U);
  /* #070 Reset the events debouncing state */
# if (DEM_FEATURE_NEED_DEBOUNCE == STD_ON)
  Dem_Esm_EventResetDebounceValues(EventId);
# endif
# if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  if (DEM_MEM_INVALID_PRESTORAGE_REF != Dem_Cfg_EventPrestorageIndex(EventId))
  { 
    /* #080 Clear a present prestored freeze frame */
    (void)Dem_Esm_EventPrestorageClear(EventId);
  }
# endif

}
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventDisconnect
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventDisconnect(
  Dem_EventIdType  EventId
  )
{
  Std_ReturnType lReturnValue;

  if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(EventId)))
  {
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */

    if (Dem_Esm_EventMayDisconnect(EventId) == TRUE)
    {
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
      if (DEM_CFG_COMBINED_GROUP_INVALID != Dem_Cfg_EventCombinedGroup(EventId))
      {
        /* In case of event combination, disconnect the sub-event */
        Dem_Esm_EventDisconnect_Combined(EventId);
      }
      else
# endif
      {
        /* Otherwise disconnect the event dircetly */
        Dem_Esm_EventDisconnect_Normal(EventId);
      }

# if (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
      {
        uint8 lNvAvailableMask;
        lNvAvailableMask = Dem_Mem_EventGetAvailableMask(EventId / 8u);
        lNvAvailableMask = (uint8)(lNvAvailableMask | DEM_BIT(EventId % 8u));
        Dem_Mem_EventSetAvailableMask(EventId / 8u, lNvAvailableMask);
        Dem_Mem_EventAvailableSetBlockState(DEM_NVM_BLOCKSTATE_DIRTY);
      }
# endif
      lReturnValue = E_OK;
    }
    else
    {
      lReturnValue = E_NOT_OK;
    }

    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
#if (DEM_CFG_NOTIFY_FIM == STD_ON)
    if (lReturnValue == E_OK)
    {
      (void)FiM_DemTriggerOnEventStatus(EventId, 0x50, 0x00);
    }
#endif
  }
  else
  { /* Already disconnected */
    lReturnValue = E_OK;
  }
  return lReturnValue;
}
#endif /* (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) */

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) && (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventReconnect_Combined
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventReconnect_Combined(
  Dem_EventIdType  EventId
  )
{
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  Dem_Cfg_EventInternalStatusType lGroupInternalStatus;

  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lGroupInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);

  /* #020 Set the event internal status to connected */
  Dem_Mem_EventSetInternalStatus(EventId, DEM_ESM_RESET_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(EventId)));
  /* #030 Set the event status to 0x50 */
  Dem_Mem_EventSetStatus(EventId, 0x50U);

  /* #040 If the combination group was disconnected or suppressed */
  if ( (FALSE != DEM_ESM_TEST_EVENT_DISCONNECTED(lGroupInternalStatus))
#  if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
    || (FALSE != DEM_ESM_TEST_EVENT_SUPPRESSED(lGroupInternalStatus))
#  endif
    )
  {
    uint8 lCombinedGroupStatus;
#  if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
    boolean lDoSuppress;
#  endif
    Dem_Cfg_CombinedGroupIterType lCombinedIter;

    lCombinedGroupStatus = 0x00;
#  if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
    lDoSuppress = TRUE;
#  endif

    /* Reconnecting an event can cause a suppressed DTC to become un-suppressed */
    for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lCombinedIter);                                                                /* PRQA S 3198, 3418 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
         (FALSE != Dem_Cfg_CombinedGroupIterExists(lGroupId, &lCombinedIter));
         Dem_Cfg_CombinedGroupIterNext(lGroupId, &lCombinedIter))
    {
      Dem_EventIdType lSubEventId;
      lSubEventId = Dem_Cfg_CombinedGroupIterGet(lGroupId, &lCombinedIter);
#  if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
      if (FALSE != Dem_Cfg_EventAvailableInVariant(lSubEventId))
#  endif
      {
#  if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
        /* #050 (If suppression is supported) If all sub-events are either disconnected or suppressed, the combined
         *      group is still suppressed */
        lDoSuppress = (boolean)(lDoSuppress && ( (FALSE != DEM_ESM_TEST_EVENT_SUPPRESSED(Dem_Mem_EventGetInternalStatus(lSubEventId)))
                                              || (FALSE != DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(lSubEventId)))));
#  endif
        /* #060 Calculate the combined event status - logical 'or' of all connected event status bytes (includes self) */
        lCombinedGroupStatus = (uint8)(lCombinedGroupStatus | Dem_Mem_EventGetStatus(lSubEventId));
      }
    }

    /* #070 Since at least one sub-events is connected now, set the combined group to connected */
    lGroupInternalStatus = DEM_ESM_RESET_EVENT_DISCONNECTED(lGroupInternalStatus);

#  if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
    if (FALSE == lDoSuppress)
    {
      /* #050 (If suppression is supported) If all sub-events are either disconnected or suppressed, the combined
       *      group is still suppressed */
      lGroupInternalStatus = DEM_ESM_RESET_EVENT_SUPPRESSED(lGroupInternalStatus);
    }
#  endif
    Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, lGroupInternalStatus);
    /* #060 Calculate the combined event status - logical 'or' of all connected event status bytes (includes self) */
    Dem_Mem_CombinedGroupSetStatus(lGroupId, lCombinedGroupStatus);
  }

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
}
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventReconnect_Normal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventReconnect_Normal(
  Dem_EventIdType  EventId
  )
{
  /* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
  Dem_Mem_EventSetInternalStatus(EventId, DEM_ESM_RESET_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(EventId)));
  Dem_Mem_EventSetStatus(EventId, 0x50U);

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
  /* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
}
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventReconnect
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventReconnect(
  Dem_EventIdType  EventId
  )
{
  if (FALSE != DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(EventId)))
  {
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
    if (DEM_CFG_COMBINED_GROUP_INVALID != Dem_Cfg_EventCombinedGroup(EventId))
    {
      Dem_Esm_EventReconnect_Combined(EventId);
    }
    else
# endif
    {
      Dem_Esm_EventReconnect_Normal(EventId);
    }
# if (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
    {
      uint8 lNvAvailableMask;
      lNvAvailableMask = Dem_Mem_EventGetAvailableMask(EventId / 8u);
      lNvAvailableMask = (uint8)(lNvAvailableMask & DEM_BIT_MASK(EventId % 8u, DEM_1BYTE));
      Dem_Mem_EventSetAvailableMask(EventId / 8u, lNvAvailableMask);
      Dem_Mem_EventAvailableSetBlockState(DEM_NVM_BLOCKSTATE_DIRTY);
    }
# endif

#if (DEM_CFG_NOTIFY_FIM == STD_ON)
    (void)FiM_DemTriggerOnEventStatus(EventId, 0x00, 0x50);
#endif
  }
}
#endif /* (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) */

#if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventSetSuppression
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventSetSuppression(
  Dem_EventIdType  EventId
  )
{
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
# endif

# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    Dem_Cfg_EventInternalStatusType lGroupInternalStatus;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */

    lGroupInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);
    /* #030 Set the event suppressed */
    Dem_Mem_EventSetInternalStatus(EventId, DEM_ESM_SET_EVENT_SUPPRESSED(Dem_Mem_EventGetInternalStatus(EventId)));

    if (FALSE == DEM_ESM_TEST_EVENT_SUPPRESSED(lGroupInternalStatus))
    {
      /* #040 If all available sub-events of the combined group are suppressed or disabled,
       *      the combined group is suppressed */
      boolean lDoSuppress;
      Dem_Cfg_CombinedGroupIterType lCombinedIter;

      lDoSuppress = TRUE;
      Dem_Cfg_CombinedGroupIterInit(lGroupId, &lCombinedIter);                                                                   /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
      while ( (FALSE != Dem_Cfg_CombinedGroupIterExists(lGroupId, &lCombinedIter))
            && (FALSE != lDoSuppress) )
      {
        Dem_EventIdType lSubEventId;

        lSubEventId = Dem_Cfg_CombinedGroupIterGet(lGroupId, &lCombinedIter);
# if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
        if (FALSE != Dem_Cfg_EventAvailableInVariant(lSubEventId))
# endif
        {
# if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
          if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(lSubEventId)))
# endif
          {
            lDoSuppress = (boolean)DEM_ESM_TEST_EVENT_SUPPRESSED(Dem_Mem_EventGetInternalStatus(lSubEventId));
          }
        }
        Dem_Cfg_CombinedGroupIterNext(lGroupId, &lCombinedIter);
      }
      if (FALSE != lDoSuppress)
      {
        /* #040 If all available sub-events of the combined group are suppressed or disabled,
         *      the combined group is suppressed */
        Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, DEM_ESM_SET_EVENT_SUPPRESSED(lGroupInternalStatus));
      }
    }

    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
  }
  else
# endif
  {
    Dem_Cfg_EventInternalStatusType lInternalStatus;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* #070 Set the event suppressed */
    lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
    Dem_Mem_EventSetInternalStatus(EventId, DEM_ESM_SET_EVENT_SUPPRESSED(lInternalStatus));

    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
  }
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_FEATURE_NEED_SUPPRESSION == STD_ON) */

#if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventResetSuppression
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventResetSuppression(
  Dem_EventIdType  EventId
  )
{
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;

  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    Dem_Cfg_EventInternalStatusType lGroupInternalStatus;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lGroupInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);
    Dem_Mem_EventSetInternalStatus(EventId, DEM_ESM_RESET_EVENT_SUPPRESSED(Dem_Mem_EventGetInternalStatus(EventId)));
    if (FALSE != DEM_ESM_TEST_EVENT_SUPPRESSED(lGroupInternalStatus))
    { /* if at least one event of a combined dtc is active, the dtc is not suppressed */
      /* Unavailable event cannot be set unsuppressed, they are rejected by the API.
         So the assumption is that this event is available, so is the DTC */
      Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, DEM_ESM_RESET_EVENT_SUPPRESSED(lGroupInternalStatus));
    }
    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
  }
  else
# endif
  {
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    Dem_Mem_EventSetInternalStatus(EventId, DEM_ESM_RESET_EVENT_SUPPRESSED(Dem_Mem_EventGetInternalStatus(EventId)));

    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
  }
}
#endif /* (DEM_FEATURE_NEED_SUPPRESSION == STD_ON) */

#if (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventSetDtcSuppression
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventSetDtcSuppression(
  Dem_EventIdType  EventId
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;

  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);

    Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, DEM_ESM_SET_DTC_SUPPRESSED(lInternalStatus));

    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
  }
  else
# endif
  {
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);

    Dem_Mem_EventSetInternalStatus(EventId, DEM_ESM_SET_DTC_SUPPRESSED(lInternalStatus));

    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
  }
}
#endif /* (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON) */

#if (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventResetDtcSuppression
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventResetDtcSuppression(
  Dem_EventIdType  EventId
  )
{
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    Dem_Cfg_EventInternalStatusType lInternalStatus;
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);
    Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, DEM_ESM_RESET_DTC_SUPPRESSED(lInternalStatus));
    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
  }
  else
# endif
  {
    Dem_Cfg_EventInternalStatusType lInternalStatus;
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
    Dem_Mem_EventSetInternalStatus(EventId, DEM_ESM_RESET_DTC_SUPPRESSED(lInternalStatus));
    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
  }
}
#endif /* (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON) */
/* ****************************************************************************
 % Dem_Esm_EventAged
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventAged(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  Dem_Cfg_MemoryIndexType  MemoryIndex
  )
{
#if (DEM_FEATURE_NEED_AGING_AGE != STD_ON)
  DEM_IGNORE_UNUSED_ARGUMENT(EventId)                                                                                            /* PRQA S 3112 */ /* MD_DEM_14.2 */
#endif
#if (DEM_CFG_PROCESS_CDTC_ALL_DTC != STD_ON) && (DEM_FEATURE_NEED_AGING_IMMEDIATE != STD_ON)
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_MEM_INVALID_MEMORY_INDEX == MemoryIndex)
  {
    Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_INCONSISTENT_STATE)
  }
  else
# endif
#endif
  {
#if (DEM_CFG_ISCONST_SUPPORTAGING != STD_ON)
    if (FALSE != Dem_Cfg_EventSupportAging(EventId))
#endif
    {
#if (DEM_FEATURE_NEED_AGING_AGE == STD_ON)
      Dem_Util_ForEachCombinedArgType lArgs;

      /* #030 Process aging for each sub-event status */
      Dem_Util_ForEachCombinedEvent(EventId, Dem_Esm_EventAged_Internal, &lArgs);

# if (DEM_CFG_PROCESS_CDTC_ALL_DTC == STD_ON) || (DEM_FEATURE_NEED_AGING_IMMEDIATE == STD_ON)
      if (DEM_MEM_INVALID_MEMORY_INDEX != MemoryIndex)
# endif
      {
        DEM_MEM_MEMORYINFO_PARAM_VARDEF
        DEM_MEM_MEMORYINFO_PARAM_INIT(Dem_Cfg_EventDestination(EventId))

# if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
        Dem_Mem_EntrySetAgingCount(Dem_Mem_MemoryGetEntry(MemoryIndex), DEM_ESM_CYCLECOUNT_EVENT_AGED);                          /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_MSR_3305 */
# else
        Dem_Mem_MemoryFreeIndex(MemoryIndex);
# endif
        Dem_Mem_MemorySetBlockState(MemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);

# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
        /* #090 For combined events, synchronize the combined internal stored status */
        {
          Dem_Cfg_CombinedGroupIndexType lGroupId;
          lGroupId = Dem_Cfg_EventCombinedGroup(EventId);

          if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
          {
            Dem_Cfg_EventInternalStatusType lGroupInternalStatus;
            lGroupInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);

            Dem_Mem_CombinedGroupSetStatus(lGroupId, lArgs.Common.NewDtcStatus);
#  if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
            lGroupInternalStatus = DEM_ESM_SET_STORED_STATUS(lGroupInternalStatus, DEM_ESM_STORED_STATUS_AGED);
#  else
            lGroupInternalStatus = DEM_ESM_SET_STORED_STATUS(lGroupInternalStatus, DEM_ESM_STORED_STATUS_NONE);
#  endif
            Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, lGroupInternalStatus);
          }
        }
# endif

# if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
        /* #100 If configured, notify the DTC status change */
        Dem_Cbk_DtcStatusChanged(EventId, lArgs.Common.OldDtcStatus, lArgs.Common.NewDtcStatus);
# endif
      }
#endif /* (DEM_FEATURE_NEED_AGING_AGE == STD_ON) */
    }
#if (DEM_CFG_ISCONST_SUPPORTAGING != STD_ON)
    else
#endif
    {
#if (DEM_FEATURE_NEED_AGING_LATCH == STD_ON)
# if (DEM_CFG_PROCESS_CDTC_ALL_DTC == STD_ON) && (DEM_FEATURE_NEED_AGING_IMMEDIATE == STD_ON)
      if (DEM_MEM_INVALID_MEMORY_INDEX != MemoryIndex)
# endif
      {
        /* #120 Latch the aging counter and set the memory entries NV status to DIRTY */
        Dem_Mem_EntrySetAgingCount(Dem_Mem_MemoryGetEntry(MemoryIndex), DEM_ESM_CYCLECOUNT_LATCHED);                             /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
        Dem_Mem_MemorySetBlockState(MemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
      }
#endif /* (DEM_FEATURE_NEED_AGING_LATCH == STD_ON) */
    }
  }
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

#if (DEM_FEATURE_NEED_AGING_IMMEDIATE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventAgingStartZeroTarget
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventAgingStartZeroTarget(
  Dem_EventIdType  EventId
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;

  lInternalStatus = Dem_Util_DtcGetInternalStatus(EventId);
  if (DEM_ESM_STORED_STATUS_AGING > DEM_ESM_GET_STORED_STATUS(lInternalStatus))
  { /* <=> DEM_ESM_STORED_STATUS_NONE || DEM_ESM_STORED_STATUS_ACTIVE */
    Dem_Cfg_MemoryIndexType  lMemoryIndex;
    DEM_MEM_MEMORYINFO_PARAM_VARDEF

    lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;
    DEM_MEM_MEMORYINFO_PARAM_INIT(Dem_Cfg_EventDestination(EventId))

    if (DEM_ESM_STORED_STATUS_ACTIVE == DEM_ESM_GET_STORED_STATUS(lInternalStatus))
    {
      lMemoryIndex = Dem_Mem_MemoryFindIndex(EventId);
    }

# if (DEM_CFG_ISCONST_SUPPORTAGING != STD_ON)
    if (FALSE != Dem_Cfg_EventSupportAging(EventId))
# endif
    {
      /* #060 If the event ages immediately, clear its trip counter and process the event aging. */
# if (DEM_FEATURE_NEED_MULTITRIP == STD_ON)
      if (FALSE != DEM_ESM_TEST_UDS_STATUS_PDTC(Dem_Mem_EventGetStatus(EventId)))
      { /* PDTC == TRUE -> TripCounter */
        Dem_Mem_EventSetTripCount(EventId, 0);
      }
# endif
      Dem_Esm_EventAged(EventId, lMemoryIndex);
    }
  }
}
#endif /* (DEM_FEATURE_NEED_AGING_IMMEDIATE == STD_ON) */

#if (DEM_FEATURE_NEED_AGING_DELAYED == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventAgingStartMultiTarget
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventAgingStartMultiTarget(
  Dem_EventIdType  EventId
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;

  lInternalStatus = Dem_Util_DtcGetInternalStatus(EventId);
  if (DEM_ESM_STORED_STATUS_AGING > DEM_ESM_GET_STORED_STATUS(lInternalStatus))
  { /* <=> DEM_ESM_STORED_STATUS_NONE || DEM_ESM_STORED_STATUS_ACTIVE */
    Dem_Cfg_MemoryIndexType  lMemoryIndex;
    DEM_MEM_MEMORYINFO_PARAM_VARDEF

    lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;
    DEM_MEM_MEMORYINFO_PARAM_INIT(Dem_Cfg_EventDestination(EventId))

#if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
    if (DEM_ESM_STORED_STATUS_NONE == DEM_ESM_GET_STORED_STATUS(lInternalStatus))
    {
      /* #050 In configurations with CDTC independent of event storage, try to allocate an aging counter if the event
       *      has none. Events that age immediately do not need an aging counter. */
      if (FALSE != DEM_ESM_TEST_UDS_STATUS_CDTC(Dem_Util_DtcGetStatus(EventId)))
      {
        lMemoryIndex = Dem_Mem_MemoryAllocateAging(EventId);
      }
    }
    else
#endif
    if (DEM_ESM_STORED_STATUS_ACTIVE == DEM_ESM_GET_STORED_STATUS(lInternalStatus))
    {
      lMemoryIndex = Dem_Mem_MemoryFindIndex(EventId);
    }
    else
    { /* MISRA */ }

    if (DEM_MEM_INVALID_MEMORY_INDEX != lMemoryIndex)
    { /* Start Aging */
      uint16 lAgingCounter;

# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
      if (DEM_ESM_CYCLECOUNT_INVALID != Dem_Mem_EntryGetAgingCount(Dem_Mem_MemoryGetEntry(lMemoryIndex)))                        /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
      {
        Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_INCONSISTENT_STATE)
      }
# endif
      /* #080 Initialize the aging target of the memory entry */
      lAgingCounter = Dem_Mem_GetCycleCounter(Dem_Cfg_EventAgingCycle(EventId));
      lAgingCounter = Dem_Esm_AddCycleCount(lAgingCounter, Dem_Cfg_EventAgingTarget(EventId));
      Dem_Mem_EntrySetAgingCount(Dem_Mem_MemoryGetEntry(lMemoryIndex), lAgingCounter);                                           /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */

      Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
      Dem_EnterCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
      lInternalStatus = Dem_Util_DtcGetInternalStatus(EventId);
      /* #100 In critical section 'DiagMonitor', set the events stored state to 'AGING' */
      lInternalStatus = DEM_ESM_SET_STORED_STATUS(lInternalStatus, DEM_ESM_STORED_STATUS_AGING);
      Dem_Util_DtcSetInternalStatus(EventId, lInternalStatus);
      Dem_LeaveCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* >>>> -------------------------------- Leave Critical Section: DiagMonitor */
    }
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */
#endif /* (DEM_FEATURE_NEED_AGING_DELAYED == STD_ON) */

#if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON) || (DEM_CFG_STORAGE_AT_FDC == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventFdcTrip
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFdcTrip(
  Dem_EventIdType  EventId,
  boolean FirstThisCycle
  )
{
  DEM_MEM_MEMORYINFO_PARAM_VARDEF
  Dem_Cfg_MemoryIndexType lMemoryIndex;

  DEM_MEM_MEMORYINFO_PARAM_INIT(Dem_Cfg_EventDestination(EventId))
  lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;

  if (DEM_ESM_STORED_STATUS_NONE != DEM_ESM_GET_STORED_STATUS(Dem_Util_DtcGetInternalStatus(EventId)))
  {
    lMemoryIndex = Dem_Mem_MemoryFindIndex(EventId);
  }
# if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
  else
  { /* #010 If FdcTrip is the storage trigger and the event is not yet stored, try to allocate a memory entry */
    lMemoryIndex = Dem_Esm_EventCreateMemory(EventId);
  }
# endif

  if (DEM_MEM_INVALID_MEMORY_INDEX != lMemoryIndex)
  {
    boolean lDataModified;

    /* #020 If the event is stored, update the event data with FDC respectively FDC & FirstThisCycle */
    lDataModified = Dem_Data_EntryUpdate(EventId,
                                         (uint8)((FALSE != FirstThisCycle)?DEM_CFG_TRIGGER_FDC_FIRST_IN_CYCLE:DEM_CFG_TRIGGER_FDC),
                                         lMemoryIndex);

    if (FALSE != lDataModified)
    {
# if (DEM_CFG_ISCONST_NVM_IMMEDIATE != STD_ON)
      if (FALSE != Dem_Cfg_EventSupportImmediateNv(EventId))
# endif
      {
# if (DEM_FEATURE_NEED_DIRTYIMMEDIATE == STD_ON)
        Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTYIMMEDIATE);
# endif
      }
# if (DEM_CFG_ISCONST_NVM_IMMEDIATE != STD_ON)
      else
# endif
      {
# if (DEM_FEATURE_NEED_DIRTY == STD_ON)
        Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
# endif
      }

# if (DEM_FEATURE_NEED_NOTIFY_DATA == STD_ON)
      Dem_Cbk_EventDataChanged(EventId);
# endif
    }
  }

# if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  Dem_Esm_PrestorageDiscard();
# endif
}
#endif

#if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventFdcMax
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFdcMax(
  Dem_EventIdType  EventId
  )
{
  if (DEM_ESM_STORED_STATUS_NONE != DEM_ESM_GET_STORED_STATUS(Dem_Util_DtcGetInternalStatus(EventId)))
  { /* Already stored - Find, *but don't update* the memory entry */
    DEM_MEM_MEMORYINFO_PARAM_VARDEF
    Dem_Cfg_MemoryIndexType lMemoryIndex;

    DEM_MEM_MEMORYINFO_PARAM_INIT(Dem_Cfg_EventDestination(EventId))
    lMemoryIndex = Dem_Mem_MemoryFindIndex(EventId);

# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
    if (DEM_MEM_INVALID_MEMORY_INDEX == lMemoryIndex)
    {
      Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_INCONSISTENT_STATE)
    }
    else
# endif
    {
      Dem_Mem_EntryPtrType lEntry;

      lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);                                                                             /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
      if (DEM_CFG_COMBINED_GROUP_INVALID != Dem_Cfg_EventCombinedGroup(EventId))
      {
        sint8 lOldFdc;
        sint8 lNewFdc;

        lOldFdc = (sint8)Dem_Mem_EntryGetDebounceValueMax(lEntry);
        lNewFdc = Dem_Data_CombinedGroupGetFDCMax(Dem_Cfg_EventCombinedGroup(EventId));
        /* #030 Synchronize the current max FDC with the stored FDC max value */
        if (lOldFdc < lNewFdc)
        {
          Dem_Mem_EntrySetDebounceValueMax(lEntry, lNewFdc);
          Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
        }
      }
      else
# endif
      {
# if ((DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) && (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON))
        if (DEM_CFG_DEBOUNCETYPE_TIMER == Dem_Cfg_EventDebounceType(EventId))
# endif
        {
# if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
          /* #050 For time based debouncing, store the smaller debounce timer value in the memory entry */
          if (Dem_Mem_EntryGetDebounceValueMax(lEntry) > Dem_Mem_EventGetDebounceValueMax(EventId))
          {
            Dem_Mem_EntrySetDebounceValueMax(lEntry, Dem_Mem_EventGetDebounceValueMax(EventId));
            Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
          }
# endif
        }
# if ((DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) && (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON))
        else
# endif
        {
# if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
          /* #060 For counter based debouncing, store the larger debounce counter value in the memory entry */
          if (Dem_Mem_EntryGetDebounceValueMax(lEntry) < Dem_Mem_EventGetDebounceValueMax(EventId))
          {
            Dem_Mem_EntrySetDebounceValueMax(lEntry, Dem_Mem_EventGetDebounceValueMax(EventId));
            Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
          }
# endif
        }
      }
    }
    /*
      No data changed callbacks for modified internal data
    */
  }
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON) */

#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
/* ****************************************************************************
 % Dem_Esm_ProcessFdc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_ProcessFdc(
  Dem_EventIdType  EventId
  )
{
  Dem_Cfg_EventInternalStatusType lOldEventInternalStatus;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
  {
    Dem_Cfg_EventInternalStatusType lNewEventInternalStatus;

    lOldEventInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
    lNewEventInternalStatus = lOldEventInternalStatus;
    lNewEventInternalStatus = DEM_ESM_RESET_FDC_TRIP(lNewEventInternalStatus);
# if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
    lNewEventInternalStatus = DEM_ESM_RESET_FDC_MAX(lNewEventInternalStatus);
# endif
# if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON)
    if (FALSE != DEM_ESM_TEST_FDC_TRIP(lOldEventInternalStatus))
    {
      lNewEventInternalStatus = DEM_ESM_SET_FDC_TOC(lNewEventInternalStatus);
    }
# endif

    Dem_Mem_EventSetInternalStatus(EventId, lNewEventInternalStatus);
  }
  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */

# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  /* no events without a DTC attached, disabled storage conditions, dtc/event suppressed... */
  if ( (DEM_CFG_DTC_UDS_INVALID != Dem_Cfg_EventUdsDtc(EventId))                                                                 /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
#  if (DEM_CFG_SUPPORT_STORAGE_CONDITIONS == STD_ON)
        /* Don't store with disabled storage conditions */
    && ((Dem_StorageConditionStates & Dem_Cfg_EventStorageConditions(EventId)) == Dem_Cfg_EventStorageConditions(EventId))
#  endif
    )
  {
#  if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON) || (DEM_CFG_STORAGE_AT_FDC == STD_ON)
    if (FALSE != DEM_ESM_TEST_FDC_TRIP(lOldEventInternalStatus))
    {
#   if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON)
      /* Pass 'TRUE' if the old bit is false, so the status change did happen just now */
      Dem_Esm_EventFdcTrip(EventId, (boolean)(FALSE == (DEM_ESM_TEST_FDC_TOC(lOldEventInternalStatus))));
#   else
      Dem_Esm_EventFdcTrip(EventId, FALSE);
#   endif
    }
#  endif
#  if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
    if (FALSE != DEM_ESM_TEST_FDC_MAX(lOldEventInternalStatus))
    {
      Dem_Esm_EventFdcMax(EventId);
    }
#  endif
  }
}
# endif
#endif

#if (DEM_FEATURE_NEED_HEALING == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventPassed_ProcessHealing
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventPassed_ProcessHealing(
  P2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext
  )
{
# if (DEM_CFG_ISCONST_HEALINGTARGET != STD_ON)
  if (0 == Dem_Cfg_EventHealingTarget(EventContext->EventId))
# endif
# if (DEM_FEATURE_NEED_IMMEDIATEHEAL == STD_ON)
  {
    /* Remove WarningIndicatorReq bit with the first 'TestPassed' result */
#  if (DEM_FEATURE_NEED_MULTIHEAL == STD_ON) && (DEM_CFG_AGING_AFTER_HEALING_ALL_DTC == STD_ON)
    Dem_Mem_EventSetTripCount(EventContext->EventId, 0);
#  endif

#  if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
    if (FALSE != DEM_ESM_TEST_UDS_STATUS_WIR(EventContext->OldEventStatus))
    {

#  if (DEM_FEATURE_NEED_MULTIHEAL == STD_ON) && (DEM_CFG_AGING_AFTER_HEALING_ALL_DTC == STD_OFF)
      Dem_Mem_EventSetTripCount(EventContext->EventId, 0);
#  endif

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
      Dem_EnterCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */

      EventContext->OldEventStatus = Dem_Mem_EventGetStatus(EventContext->EventId);
      EventContext->NewEventStatus = DEM_ESM_RESET_UDS_STATUS_WIR(EventContext->OldEventStatus);

      Dem_Mem_EventSetStatus(EventContext->EventId, EventContext->NewEventStatus);

      {
#   if (DEM_FEATURE_NEED_USER_INDICATORS == STD_ON)
        Dem_Esm_UserIndicatorDisable(EventContext->EventId);
#   endif
      }

      Dem_LeaveCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */

      DEM_NVM_CHECK_DIRTY_STATUS(EventContext->OldEventStatus, EventContext->NewEventStatus)

#   if (DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON) || (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
      if (EventContext->OldEventStatus != EventContext->NewEventStatus)
      {
#    if (DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON)
        Dem_Cbk_StatusChanged(EventContext->EventId, EventContext->OldEventStatus, EventContext->NewEventStatus);
#    endif
#    if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
#     if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
        if (DEM_CFG_COMBINED_GROUP_INVALID == EventContext->GroupId)
#     endif
        {
          Dem_Cbk_DtcStatusChanged(EventContext->EventId, EventContext->OldEventStatus, EventContext->NewEventStatus);
        }
#    endif
      }
#   endif
    }
#  endif /* (DEM_FEATURE_NEED_INDICATORS == STD_ON) */
  }

#  if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  if (DEM_CFG_COMBINED_GROUP_INVALID != EventContext->GroupId)
  {
    EventContext->NewDtcStatus = Dem_Data_CombinedGroupGetStatus(EventContext->GroupId);
    Dem_Mem_CombinedGroupSetStatus(EventContext->GroupId, EventContext->NewDtcStatus);
#   if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
    Dem_Cbk_DtcStatusChanged(EventContext->EventId, EventContext->OldDtcStatus, EventContext->NewDtcStatus);
#   endif
  }
#  endif
# endif /* (DEM_FEATURE_NEED_IMMEDIATEHEAL == STD_ON) */
}                                                                                                                                /* PRQA S 6010, 6030, 6050, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */
#endif

/* ****************************************************************************
 % Dem_Esm_EventPassed_Queued
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventPassed_Queued(
  Dem_EventIdType  EventId
  )
{
#if (DEM_FEATURE_NEED_LATCHTESTFAILED == STD_ON)
  if (FALSE == Dem_Esm_TestLatchedTestFailed(EventId))
#endif
  {
    uint8 lOldEventStatus;
    uint8 lNewEventStatus;
    uint8 lEventEffects;

    lOldEventStatus = Dem_Mem_EventGetStatus(EventId);
    lNewEventStatus = lOldEventStatus;
    lEventEffects = DEM_CFG_TRIGGER_NONE;

    lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TF(lNewEventStatus);
    lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCSLC(lNewEventStatus);
    lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCTOC(lNewEventStatus);

    Dem_Mem_EventSetStatus(EventId, lNewEventStatus);
    DEM_NVM_CHECK_DIRTY_STATUS(lOldEventStatus, lNewEventStatus)

    /* #020 Derive the triggers for the event from the changes of the status bits */
    if (FALSE != DEM_ESM_TEST_UDS_STATUS_TF(lOldEventStatus))
    {
      lEventEffects = (uint8)(lEventEffects | DEM_CFG_TRIGGER_TESTPASSED);
    }
    if (FALSE != DEM_ESM_TEST_UDS_STATUS_TNCTOC(lOldEventStatus))
    {
      lEventEffects = (uint8)(lEventEffects | DEM_CFG_TRIGGER_FIRSTTHISCYCLE);
    }

    if (lOldEventStatus != lNewEventStatus)
    {
#if (DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON)
      Dem_Cbk_StatusChanged(EventId, lOldEventStatus, lNewEventStatus);
#endif
#if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
      if (DEM_CFG_COMBINED_GROUP_INVALID == Dem_Cfg_EventCombinedGroup(EventId))
# endif
      {
        Dem_Cbk_DtcStatusChanged(EventId, lOldEventStatus, lNewEventStatus);
      }
#endif

      Dem_Esm_EventPassed_Immediate(EventId, lEventEffects);
    }
  }
}

/* ****************************************************************************
 % Dem_Esm_EventPassed_Immediate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventPassed_Immediate(
  Dem_EventIdType  EventId,
  uint8 Effects
  )
{
  Dem_Esm_EventContextType lEventContext;

  lEventContext.EventId = EventId;
  lEventContext.OldEventStatus = Dem_Mem_EventGetStatus(EventId);
  lEventContext.NewEventStatus = lEventContext.OldEventStatus;
  lEventContext.EventEffects = Effects;
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  lEventContext.GroupId = Dem_Cfg_EventCombinedGroup(EventId);
  lEventContext.OldDtcStatus = Dem_Util_DtcGetStatus(EventId);
  lEventContext.NewDtcStatus = lEventContext.OldDtcStatus;
  lEventContext.DtcEffects = DEM_CFG_TRIGGER_NONE;
#endif

#if (DEM_FEATURE_NEED_HEALING == STD_ON)
  Dem_Esm_EventPassed_ProcessHealing(&lEventContext);
#endif /* (DEM_FEATURE_NEED_HEALING == STD_ON) */

#if (DEM_CFG_AGING_START_TESTS_TFTOC == STD_OFF) || (DEM_CFG_AGING_AT_PASSED_00_TARGET_ONLY == STD_ON)
# if (DEM_CFG_ISCONST_AGINGTARGET == STD_OFF)
  if (Dem_Cfg_EventAgingTarget(EventId) == 0)
# endif
  {
# if (DEM_FEATURE_NEED_AGING_IMMEDIATE == STD_ON)
#  if (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
    if (Dem_Esm_TestDtcHealed(EventId) == TRUE)
#  endif
    {
#  if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
      if (DEM_CFG_COMBINED_GROUP_INVALID != lEventContext.GroupId)
      {
        if ( (DEM_ESM_TEST_UDS_STATUS_TF(lEventContext.NewDtcStatus) == FALSE)
          && (DEM_ESM_TEST_UDS_STATUS_TNCTOC(lEventContext.NewDtcStatus) == FALSE)
#   if (DEM_CFG_AGING_AT_PASSED_00_TARGET_ONLY == STD_ON)
          && (DEM_ESM_TEST_UDS_STATUS_TFTOC(lEventContext.NewDtcStatus) == FALSE)
#   endif
          )
        {
          Dem_Esm_EventAgingStartZeroTarget(EventId);
        }
      }
      else
#  endif
      {
#   if (DEM_CFG_AGING_AT_PASSED_00_TARGET_ONLY == STD_ON)
        if (DEM_ESM_TEST_UDS_STATUS_TFTOC(lEventContext.NewEventStatus) == FALSE)
#   endif
        {
          Dem_Esm_EventAgingStartZeroTarget(EventId);
        }
      }
    }
# endif
  }
#endif
#if (DEM_CFG_AGING_START_TESTS_TFTOC == STD_OFF)
# if (DEM_CFG_ISCONST_AGINGTARGET == STD_OFF)
  else
# endif
  {
# if (DEM_FEATURE_NEED_AGING_DELAYED == STD_ON)
#  if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
    if ( (DEM_CFG_COMBINED_GROUP_INVALID == lEventContext.GroupId)
      || ( (DEM_ESM_TEST_UDS_STATUS_TF(lEventContext.NewDtcStatus) == FALSE)
        && (DEM_ESM_TEST_UDS_STATUS_TNCTOC(lEventContext.NewDtcStatus) == FALSE)
       ) )
#  endif
    {
#  if (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
      if (Dem_Esm_TestDtcHealed(EventId) == TRUE)
#  endif
      {
        Dem_Esm_EventAgingStartMultiTarget(EventId);
      }
    }
# endif
  }
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  Dem_Esm_PrestorageDiscard();
#endif
}                                                                                                                                /* PRQA S 6010, 6030, 6050, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL, MD_MSR_STMIF */

#if (DEM_FEATURE_NEED_TRIPPING == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventTestConfirmed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventTestConfirmed(
  P2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext                                                             /* PRQA S 3673 */ /* MD_DEM_16.7_Design */
  )
{
  boolean lReturnValue;
  lReturnValue = FALSE;

  {
# if (DEM_FEATURE_NEED_MULTITRIP == STD_ON)
    if (Dem_Mem_EventGetTripCount(EventContext->EventId) >= Dem_Cfg_EventTripTarget(EventContext->EventId))
    {
      /* multi-trip target reached */
      lReturnValue = TRUE;
    }
# else
#  if ( (DEM_CFG_ISCONST_TRIPTARGET != STD_ON) && (DEM_FEATURE_NEED_TWOTRIP == STD_ON) )
    if ( (0 == Dem_Cfg_EventTripTarget(EventContext->EventId))
      || ( (FALSE != (DEM_ESM_TEST_UDS_STATUS_PDTC(EventContext->OldEventStatus)))
        && (FALSE != (EventContext->EventEffects & DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE))) )
    {
      /* event is either configured as single-trip, or event has tripped twice */
      lReturnValue = TRUE;
    }
#  elif (DEM_FEATURE_NEED_TWOTRIP == STD_ON)
    if ( (FALSE != (DEM_ESM_TEST_UDS_STATUS_PDTC(EventContext->OldEventStatus)))
      && (FALSE != (EventContext->EventEffects & DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE)) )
    {
      /* event has tripped twice (all events are configured as two-trip) */
      lReturnValue = TRUE;
    }
#  endif
# endif
  }

  return lReturnValue;
}
#endif /* (DEM_FEATURE_NEED_TRIPPING == STD_ON) */

/* ****************************************************************************
 % Process test DTC pending bit (Bit2)
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_ProcessPending(
  P2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext
  )
{
  /* Confirm n cycles after pending was set */
  if (FALSE == DEM_ESM_TEST_UDS_STATUS_PDTC(EventContext->OldEventStatus))
  { /* Not yet pending, set pending independently of TFTOC */
    EventContext->EventEffects = (uint8)(EventContext->EventEffects | DEM_CFG_TRIGGER_PENDING);
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
    if (FALSE == DEM_ESM_TEST_UDS_STATUS_PDTC(EventContext->OldDtcStatus))
    {
      EventContext->DtcEffects = (uint8)(EventContext->DtcEffects | DEM_CFG_TRIGGER_PENDING);
    }
#endif

#if (DEM_FEATURE_NEED_MULTITRIP == STD_ON)
    /* Initialize trip counter */
    Dem_Mem_EventSetTripCount(EventContext->EventId, 0);
#endif

  }
}

/* ****************************************************************************
 % Process test DTC confirmation (Bit3)
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_ProcessConfirmed(
  P2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext
  )
{
#if (DEM_FEATURE_NEED_TRIPPING == STD_ON)
  boolean lEventConfirmed;
  lEventConfirmed = Dem_Esm_EventTestConfirmed(EventContext);
  if (FALSE != lEventConfirmed)
#endif /* MIL groups  OR  multi-trip  OR  two-trip */
  { /* Event has confirmed */
#if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
    if (FALSE == DEM_ESM_TEST_UDS_STATUS_WIR(EventContext->OldEventStatus))
    {
# if (DEM_FEATURE_NEED_USER_INDICATORS == STD_ON)
      Dem_Cfg_EventIndicatorIterType lIndicatorIter;

      Dem_Cfg_EventIndicatorIterInit(EventContext->EventId, &lIndicatorIter);                                                    /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
# endif
      if (
# if (DEM_FEATURE_NEED_USER_INDICATORS == STD_ON)
           (FALSE != Dem_Cfg_EventIndicatorIterExists(EventContext->EventId, &lIndicatorIter))
# endif
        )
      {
        EventContext->EventEffects = (uint8)(EventContext->EventEffects | DEM_CFG_TRIGGER_INDICATOR);
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
        if (FALSE == DEM_ESM_TEST_UDS_STATUS_WIR(EventContext->OldDtcStatus))
        {
          EventContext->DtcEffects = (uint8)(EventContext->DtcEffects | DEM_CFG_TRIGGER_INDICATOR);
        }
# endif
      }
    }
#endif

    if (FALSE == DEM_ESM_TEST_UDS_STATUS_CDTC(EventContext->OldEventStatus))
    {
      EventContext->EventEffects = (uint8)(EventContext->EventEffects | DEM_CFG_TRIGGER_CONFIRMED);
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
      if (FALSE == DEM_ESM_TEST_UDS_STATUS_CDTC(EventContext->OldDtcStatus))
      {
        EventContext->DtcEffects = (uint8)(EventContext->DtcEffects | DEM_CFG_TRIGGER_CONFIRMED);
      }
#endif
    } /* else: No transition for confirmed dtc, so no update */
  } /* else: not yet confirmed, no further action */
}

/* ****************************************************************************
 % Process test DTC storage/update
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventFailed_ProcessStorage(
  P2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext
  )
{
  Dem_Cfg_MemoryIndexType lMemoryIndex;
  Dem_Cfg_EventInternalStatusType lInternalStatus;
  boolean lReturnValue;

  lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;
  lInternalStatus = Dem_Util_DtcGetInternalStatus(EventContext->EventId);

  if (DEM_ESM_STORED_STATUS_NONE == DEM_ESM_GET_STORED_STATUS(lInternalStatus))
  { /* Not stored yet - If no entry can be created we need to discard some updates */
    if (0 != (Dem_Esm_SelectStorageEffects(EventContext) & DEM_ESM_EVENT_STORAGE_TRIGGER))
    { /* We have to store this event in memory */
      lMemoryIndex = Dem_Esm_EventCreateMemory(EventContext->EventId);
      if (DEM_MEM_INVALID_MEMORY_INDEX == lMemoryIndex)
      { /* Storage was not possible, discard changes that require storage */
        EventContext->EventEffects = (uint8)(EventContext->EventEffects & DEM_ESM_EVENT_RESET_TRIGGER_MASK);
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
        EventContext->DtcEffects = (uint8)(EventContext->DtcEffects & DEM_ESM_EVENT_RESET_TRIGGER_MASK);
# endif
      }
      else
      {
        /* Make sure failed update data is correctly stored for first time entry */
        EventContext->EventEffects = (uint8)(EventContext->EventEffects | DEM_CFG_TRIGGER_TESTFAILED);
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
        EventContext->DtcEffects = (uint8)(EventContext->DtcEffects | DEM_CFG_TRIGGER_TESTFAILED);
# endif
      }
    }
  }
  else
  { /* Already stored - Update the existing entry if necessary */
#if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
    if (DEM_ESM_STORED_STATUS_AGED == DEM_ESM_GET_STORED_STATUS(lInternalStatus))
    {
      if (0 != (Dem_Esm_SelectStorageEffects(EventContext) & DEM_ESM_EVENT_STORAGE_TRIGGER))
      { /* Reclaim aged event */
        lMemoryIndex = Dem_Esm_EventUpdateMemory(EventContext->EventId, TRUE);
      }
    }
    else
#endif
    {
      lMemoryIndex = Dem_Esm_EventUpdateMemory(EventContext->EventId,
                                               (boolean)((Dem_Esm_SelectStorageEffects(EventContext) & DEM_ESM_EVENT_UPDATE_TRIGGER) != 0));
    }
  }

  lReturnValue = (boolean)(Dem_Data_EntryUpdate(EventContext->EventId, Dem_Esm_SelectStorageEffects(EventContext), lMemoryIndex));
  return lReturnValue;
}

/* ****************************************************************************
 % Process commit status changes to memory
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_CommitToMemory(
  P2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext
  )
{
  Dem_Cfg_EventInternalStatusType lNewInternalStatus;

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  /* We cannot simply store the status byte, synchronous modifications may have
   * modified it. Instead, reapply modified bits on the current status value */
  EventContext->NewEventStatus = Dem_Mem_EventGetStatus(EventContext->EventId);
  EventContext->OldEventStatus = EventContext->NewEventStatus;
  lNewInternalStatus = Dem_Util_DtcGetInternalStatus(EventContext->EventId);

  if (DEM_ESM_STORED_STATUS_NONE != DEM_ESM_GET_STORED_STATUS(lNewInternalStatus))
  {
#if (DEM_CFG_PROCESS_TFSLC_STOREDONLY == STD_ON)
    EventContext->NewEventStatus = DEM_ESM_SET_UDS_STATUS_TFSLC(EventContext->NewEventStatus);
#endif
    lNewInternalStatus = DEM_ESM_SET_STORED_STATUS(lNewInternalStatus, DEM_ESM_STORED_STATUS_ACTIVE);
    Dem_Util_DtcSetInternalStatus(EventContext->EventId, lNewInternalStatus);
  }
  if (0 != (EventContext->EventEffects & DEM_CFG_TRIGGER_PENDING))
  {
    EventContext->NewEventStatus = DEM_ESM_SET_UDS_STATUS_PDTC(EventContext->NewEventStatus);
  }
  if (0 != (EventContext->EventEffects & DEM_CFG_TRIGGER_CONFIRMED))
  {
    EventContext->NewEventStatus = DEM_ESM_SET_UDS_STATUS_CDTC(EventContext->NewEventStatus);
  }
#if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
  if (0 != (EventContext->EventEffects & DEM_CFG_TRIGGER_INDICATOR))
  {
    EventContext->NewEventStatus = DEM_ESM_SET_UDS_STATUS_WIR(EventContext->NewEventStatus);
    {
# if (DEM_FEATURE_NEED_USER_INDICATORS == STD_ON)
      Dem_Esm_UserIndicatorEnable(EventContext->EventId);
# endif
    }
  }
#endif /* (DEM_FEATURE_NEED_INDICATORS == STD_ON) */

  Dem_Mem_EventSetStatus(EventContext->EventId, EventContext->NewEventStatus);
  /* Status block will later be marked unconditionally */

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  if (DEM_CFG_COMBINED_GROUP_INVALID != EventContext->GroupId)
  {
    EventContext->NewDtcStatus = Dem_Data_CombinedGroupGetStatus(EventContext->GroupId);
    Dem_Mem_CombinedGroupSetStatus(EventContext->GroupId, EventContext->NewDtcStatus);
  }
  else
  {
    EventContext->NewDtcStatus = EventContext->NewEventStatus;
  }
#endif

}                                                                                                                                /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */

#if (DEM_FEATURE_NEED_NOTIFY == STD_ON)
/* ****************************************************************************
 % Notify changes to event and DTC status
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_ProcessNotifications(
  P2VAR(Dem_Esm_EventContextType, AUTOMATIC, AUTOMATIC) EventContext,                                                            /* PRQA S 3673 */ /* MD_DEM_16.7_Design */
  boolean DataModified                                                                                                           /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
#if (DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON) || (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
  if (EventContext->OldEventStatus != EventContext->NewEventStatus)
  {
# if (DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON)
    Dem_Cbk_StatusChanged(EventContext->EventId, EventContext->OldEventStatus, EventContext->NewEventStatus);
# endif
# if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
#  if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
    Dem_Cbk_DtcStatusChanged(EventContext->EventId, EventContext->OldDtcStatus, EventContext->NewDtcStatus);
#  else
    Dem_Cbk_DtcStatusChanged(EventContext->EventId, EventContext->OldEventStatus, EventContext->NewEventStatus);
#  endif
# endif
  }
#endif

#if (DEM_FEATURE_NEED_NOTIFY_DATA == STD_ON)
  if (FALSE != DataModified)
  {
    Dem_Cbk_EventDataChanged(EventContext->EventId);
  }
#else
  DEM_IGNORE_UNUSED_ARGUMENT(DataModified)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
#endif
}
#endif /* DEM_FEATURE_NEED_NOTIFY == STD_ON */

/* ****************************************************************************
 % Dem_Esm_EventOpCycleStart
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventOpCycleStart(
  Dem_EventIdType  EventId
  )
{
  uint8 lOldEventStatus;
  uint8 lNewEventStatus;

  lOldEventStatus = Dem_Mem_EventGetStatus(EventId);

  lNewEventStatus = lOldEventStatus;
#if (DEM_CFG_SUPPORT_CLEAR_TESTFAILED_ON_OPCYCLE == STD_ON)
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TF(lNewEventStatus);
#endif
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TFTOC(lNewEventStatus);
  lNewEventStatus = DEM_ESM_SET_UDS_STATUS_TNCTOC(lNewEventStatus);

  Dem_Mem_EventSetStatus(EventId, lNewEventStatus);

#if ( (DEM_FEATURE_NEED_OBD == STD_ON) && (DEM_FEATURE_NEED_CYCLEAUTOMATICEND == STD_ON) \
   || (DEM_CFG_SUPPORT_RESTART_CYCLE == STD_ON) )
  if (Dem_InitState == DEM_INIT_INITIALIZED)
#endif
  {
#if (DEM_FEATURE_NEED_DEBOUNCE == STD_ON)
    Dem_Esm_EventResetDebounceValues(EventId);

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
    {
      Dem_Cfg_EventInternalStatusType lInternalStatus;
      lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
# if (DEM_CFG_SUPPORT_DEBOUNCE_TIME == STD_ON)
      lInternalStatus = DEM_ESM_SET_DEBOUNCE_STATUS(lInternalStatus, DEM_ESM_DEBOUNCE_STATUS_NONE);
# endif
# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
      lInternalStatus = DEM_ESM_RESET_FDC_TRIP(lInternalStatus);
# endif
# if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
      lInternalStatus = DEM_ESM_RESET_FDC_MAX(lInternalStatus);
# endif
# if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON)
      lInternalStatus = DEM_ESM_RESET_FDC_TOC(lInternalStatus);
# endif
      Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);
    }
    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */

#endif
  }

}

#if ( (DEM_FEATURE_NEED_INDICATORS == STD_ON) \
   && ((DEM_FEATURE_NEED_MULTIHEAL == STD_ON) || (DEM_FEATURE_NEED_SINGLEHEAL == STD_ON)) )
/* ****************************************************************************
 % Dem_Esm_EventHealed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Esm_EventHealed(
  Dem_EventIdType  EventId,
  uint8 EventStatus
  )
{
  uint8 lNewEventStatus;
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_WIR(EventStatus);

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

#  if (DEM_FEATURE_NEED_USER_INDICATORS == STD_ON)
  Dem_Esm_UserIndicatorDisable(EventId);
#  endif

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */

  return lNewEventStatus;
}
#endif

#if (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_MULTIHEAL == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventProcessHealing
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(uint8, DEM_CODE)
Dem_Esm_EventProcessHealing(
Dem_EventIdType  EventId,
uint8 EventStatus                                                                                                                /* PRQA S 3206 */ /* MD_DEM_3206 */
)
{
# if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
  uint8 lNewEventStatus;

  lNewEventStatus = EventStatus;
# else
  DEM_IGNORE_UNUSED_ARGUMENT(EventStatus)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */
# endif

  if (Dem_Mem_EventGetTripCount(EventId) > 0)
  { /* Continue healing */
    Dem_Mem_EventSetTripCount(EventId, (uint8)(Dem_Mem_EventGetTripCount(EventId) - 1));
  }
  if (Dem_Mem_EventGetTripCount(EventId) == 0)
  {
# if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
    if (DEM_ESM_TEST_UDS_STATUS_WIR(EventStatus) == TRUE)
    { /* Healing target reached -> heal all related indicators */
      lNewEventStatus = Dem_Esm_EventHealed(EventId, EventStatus);
    }
# endif
  }

  return lNewEventStatus;
}
#endif /* (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_MULTIHEAL == STD_ON) */

/* ****************************************************************************
 % Dem_Esm_EventOpCycleEnd
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventOpCycleEnd(
  Dem_EventIdType  EventId,
  uint8 OldDtcStatus                                                                                                             /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  uint8 lEventStatus;
#if (DEM_CFG_AGING_START_TESTS_TFTOC == STD_ON) || (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
  boolean lEventStartAging;
#endif
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
#endif

  /* Argument unused in some configurations */
  DEM_IGNORE_UNUSED_ARGUMENT(OldDtcStatus)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */

  lEventStatus = Dem_Mem_EventGetStatus(EventId);
#if (DEM_CFG_AGING_START_TESTS_TFTOC == STD_ON) || (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
  lEventStartAging = FALSE;
#endif
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
#endif

  if (FALSE == DEM_ESM_TEST_UDS_STATUS_TNCTOC(lEventStatus))
  {
    if (FALSE == DEM_ESM_TEST_UDS_STATUS_TFTOC(lEventStatus))
    { /* Event tested this operation cycle and was not failed, reset pending state */
#if (DEM_FEATURE_NEED_MULTIHEAL == STD_ON) || (DEM_FEATURE_NEED_SINGLEHEAL == STD_ON)
      if (FALSE != DEM_ESM_TEST_UDS_STATUS_PDTC(lEventStatus))
      {
# if (DEM_FEATURE_NEED_MULTIHEAL == STD_ON)
        Dem_Mem_EventSetTripCount(EventId, Dem_Cfg_EventHealingTarget(EventId));
# elif (DEM_FEATURE_NEED_SINGLEHEAL == STD_ON)
        lEventStatus = Dem_Esm_EventHealed(EventId, lEventStatus);
# endif
      }
#endif
      lEventStatus = DEM_ESM_RESET_UDS_STATUS_PDTC(lEventStatus);
#if (DEM_FEATURE_NEED_MULTIHEAL == STD_ON)
      lEventStatus = Dem_Esm_EventProcessHealing(EventId, lEventStatus);
#endif

#if (DEM_FEATURE_NEED_HEALING == STD_ON) && (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
      if ( (Dem_Esm_TestEventHealed(EventId, lEventStatus) == TRUE)
        )
#endif
#if (DEM_CFG_AGING_START_TESTS_TFTOC == STD_ON) || (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
      {
        lEventStartAging = TRUE;
      }
#endif
    }
#if (DEM_FEATURE_NEED_MULTITRIP == STD_ON)
    else
    {
      /* test failed: increment trip counter if trip target has not yet been reached */
      if (Dem_Mem_EventGetTripCount(EventId) < Dem_Cfg_EventTripTarget(EventId))
      {
        Dem_Mem_EventSetTripCount(EventId, (uint8)(Dem_Mem_EventGetTripCount(EventId) + 1));
      }
    }
#endif

    Dem_Mem_EventSetStatus(EventId, lEventStatus);
  }

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
# if (DEM_CFG_AGING_START_TESTS_TFTOC == STD_ON) || (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
    if (FALSE != lEventStartAging)
    {
      /* event may age, test the same based on dtc */
      if ( (FALSE != DEM_ESM_TEST_UDS_STATUS_TNCTOC(OldDtcStatus))                                                               /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        || (FALSE != DEM_ESM_TEST_UDS_STATUS_TFTOC(OldDtcStatus))
#  if (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
        || ( (Dem_Esm_TestDtcHealed(EventId) == FALSE)
           )
#  endif
        )
      {
        lEventStartAging = FALSE;
      }
    }
# endif
  }
#endif

#if (DEM_CFG_AGING_START_TESTS_TFTOC == STD_ON) || (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
  if (FALSE != lEventStartAging)
  {
# if (DEM_CFG_ISCONST_AGINGTARGET == STD_OFF)
    if (Dem_Cfg_EventAgingTarget(EventId) == 0)
# endif
# if (DEM_FEATURE_NEED_AGING_IMMEDIATE == STD_ON)
    {
#  if (DEM_CFG_AGING_AT_PASSED_00_TARGET_ONLY == STD_OFF) || (DEM_FEATURE_NEED_AGING_AFTER_HEALING == STD_ON)
      Dem_Esm_EventAgingStartZeroTarget(EventId);
#  endif
    }
# endif
# if (DEM_CFG_ISCONST_AGINGTARGET == STD_OFF)
    else
# endif
# if (DEM_FEATURE_NEED_AGING_DELAYED == STD_ON)
    {
      Dem_Esm_EventAgingStartMultiTarget(EventId);
    }
# endif
  }
#endif
}                                                                                                                                /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

#if ((DEM_CFG_AGING_NEXT_TESTS_TNCTOC == STD_ON) || (DEM_CFG_AGING_NEXT_TESTS_TFTOC == STD_ON))
/* ****************************************************************************
 % Dem_Esm_TestStatusForAgingCycle
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_TestStatusForAgingCycle(
  uint8 EventStatus
  )
{
  return (boolean)(
# if(DEM_CFG_AGING_NEXT_TESTS_TFTOC == STD_ON)
    (FALSE == DEM_ESM_TEST_UDS_STATUS_TFTOC(EventStatus))
# endif
# if ((DEM_CFG_AGING_NEXT_TESTS_TNCTOC == STD_ON) && (DEM_CFG_AGING_NEXT_TESTS_TFTOC == STD_ON))
      &&
# endif
# if(DEM_CFG_AGING_NEXT_TESTS_TNCTOC == STD_ON)
    (FALSE == DEM_ESM_TEST_UDS_STATUS_TNCTOC(EventStatus))
# endif
    );
}
#endif

/* ****************************************************************************
 % Dem_Esm_EventAgingCycle
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventAgingCycle(
  Dem_EventIdType  EventId,
  uint16  CycleCounter,
  Dem_Cfg_MemoryIndexType  MemoryIndex
  )
{
  uint8 lDtcStatus;

  lDtcStatus = Dem_Util_DtcGetStatus(EventId);

  if (FALSE == DEM_ESM_TEST_UDS_STATUS_TF(lDtcStatus))
  { /* passive event */
    Dem_Mem_EntryPtrType lEntry;
    lEntry = Dem_Mem_MemoryGetEntry(MemoryIndex);                                                                                /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */

#if ((DEM_CFG_AGING_NEXT_TESTS_TNCTOC == STD_ON) || (DEM_CFG_AGING_NEXT_TESTS_TFTOC == STD_ON))
    if (FALSE == Dem_Esm_TestStatusForAgingCycle(lDtcStatus))
    { /* Untested cycle requires recalculation of aging target */
      uint16 lCycleCount = Dem_Mem_EntryGetAgingCount(lEntry);
      if (lCycleCount <= DEM_ESM_CYCLECOUNT_MAX)
      { /* Ignore maxed (latched) counter */
        lCycleCount = Dem_Esm_AddCycleCount(lCycleCount, 1);
        Dem_Mem_EntrySetAgingCount(lEntry, lCycleCount);

        Dem_Mem_MemorySetBlockState(MemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
      }
    }
    else
#endif
    if (CycleCounter == Dem_Mem_EntryGetAgingCount(lEntry))
    { /* Aging cycle reached, so this event has aged */
      Dem_Esm_EventAged(EventId, MemoryIndex);
    }
    else
    { /* Still counting */ }
  }
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

#if (DEM_CFG_NOTIFY_CLEAR_ALLOWED == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventCleared_Optional
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Esm_EventCleared_Optional(
  Dem_EventIdType  EventId
  )
{
  boolean lDoClear;
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
#endif

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  lDoClear = TRUE;
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    Dem_Cfg_CombinedGroupIterType lGroupIter;
    Dem_Cfg_CombinedGroupIterInit(lGroupId, &lGroupIter);                                                                        /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
    while ( (FALSE != lDoClear)
         && (FALSE != Dem_Cfg_CombinedGroupIterExists(lGroupId, &lGroupIter)) )
    {
      Dem_EventIdType lSubEventId;
      lSubEventId = Dem_Cfg_CombinedGroupIterGet(lGroupId, &lGroupIter);
# if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
      if (FALSE != Dem_Cfg_EventAvailableInVariant(lSubEventId))
# endif
      {
# if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
        if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(lSubEventId)))
# endif
        {
          lDoClear = Dem_Util_CallClearEventAllowed(lSubEventId);
        }
      }
      Dem_Cfg_CombinedGroupIterNext(lGroupId, &lGroupIter);
    }
  }
  else
#endif
  {
    lDoClear = Dem_Util_CallClearEventAllowed(EventId);
  }

  if (FALSE != lDoClear)
  {
    Dem_Esm_EventCleared_Internal(EventId);
  }

#if (DEM_CFG_NOTIFY_INIT_MONITOR == STD_ON)
  /* Always call init monitor callbacks */
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    Dem_Cfg_CombinedGroupIterType lGroupIter;
    Dem_Cfg_CombinedGroupIterInit(lGroupId, &lGroupIter);                                                                        /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
    while (FALSE != Dem_Cfg_CombinedGroupIterExists(lGroupId, &lGroupIter))
    {
      Dem_EventIdType lSubEventId;
      lSubEventId = Dem_Cfg_CombinedGroupIterGet(lGroupId, &lGroupIter);
# if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
      if (FALSE != Dem_Cfg_EventAvailableInVariant(lSubEventId))
# endif
      {
# if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
        if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(lSubEventId)))
# endif
        {
          Dem_Cbk_InitMonitorForEvent(lSubEventId, DEM_INIT_MONITOR_CLEAR);
        }
      }
      Dem_Cfg_CombinedGroupIterNext(lGroupId, &lGroupIter);
    }
  }
  else
# endif
  {
    Dem_Cbk_InitMonitorForEvent(EventId, DEM_INIT_MONITOR_CLEAR);
  }
#endif
#if (DEM_CFG_NOTIFY_INIT_FUNC == STD_ON)
  Dem_Cbk_InitMonitorForFunction(EventId);
#endif

  return lDoClear;
}
#endif /* (DEM_CFG_NOTIFY_CLEAR_ALLOWED == STD_ON) */

#if (DEM_CFG_NOTIFY_CLEAR_ALLOWED != STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventCleared_Always
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventCleared_Always(
  Dem_EventIdType  EventId
  )
{
#if ((DEM_CFG_NOTIFY_INIT_MONITOR == STD_ON) && (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON))
  Dem_Cfg_CombinedGroupIndexType lGroupId;
#endif

  Dem_Esm_EventCleared_Internal(EventId);

#if (DEM_CFG_NOTIFY_INIT_MONITOR == STD_ON)
  /* Always call init monitor callbacks */
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    Dem_Cfg_CombinedGroupIterType lGroupIter;
    Dem_Cfg_CombinedGroupIterInit(lGroupId, &lGroupIter);                                                                        /* PRQA S 3417 */ /* MD_DEM_12.10 */
    while (FALSE != Dem_Cfg_CombinedGroupIterExists(lGroupId, &lGroupIter))
    {
      Dem_EventIdType lSubEventId;
      lSubEventId = Dem_Cfg_CombinedGroupIterGet(lGroupId, &lGroupIter);
# if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
      if (FALSE != Dem_Cfg_EventAvailableInVariant(lSubEventId))
# endif
      {
# if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
        if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(lSubEventId)))
# endif
        {
          Dem_Cbk_InitMonitorForEvent(lSubEventId, DEM_INIT_MONITOR_CLEAR);
        }
      }
      Dem_Cfg_CombinedGroupIterNext(lGroupId, &lGroupIter);
    }
  }
  else
# endif
  {
    Dem_Cbk_InitMonitorForEvent(EventId, DEM_INIT_MONITOR_CLEAR);
  }
#endif
#if (DEM_CFG_NOTIFY_INIT_FUNC == STD_ON)
  Dem_Cbk_InitMonitorForFunction(EventId);
#endif
}
#endif /* (DEM_CFG_NOTIFY_CLEAR_ALLOWED != STD_ON) */

#if (DEM_FEATURE_NEED_OBD == STD_ON) && (DEM_CFG_SUPPORT_RESTART_DCY_ON_CLEAR_DTC == STD_ON)
/* ****************************************************************************
 % Dem_Esm_PreOnClear_AllDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PreOnClear_AllDtc(
  uint8  MemoryId
  )
{
  if (DEM_CFG_MEMORYID_PRIMARY == MemoryId)
  {
    Dem_Esm_CycleUpdate(Dem_Cfg_GlobalObdDrivingCycleId(), DEM_QUEUE_CYCLE_RESTARTED);
  }
}
#endif

/* ****************************************************************************
 % Dem_Esm_PostOnClear_AllDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PostOnClear_AllDtc(
  uint8  MemoryId
  )
{
#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
  Dem_Mem_ResetOverflow(MemoryId);
#endif

  if (DEM_CFG_MEMORYID_PRIMARY == MemoryId)
  {
    Dem_Mem_SetFirstFailedEvent(DEM_EVENT_INVALID);
    Dem_Mem_SetFirstConfirmedEvent(DEM_EVENT_INVALID);
    Dem_Mem_SetMostRecentFailedEvent(DEM_EVENT_INVALID);
    Dem_Mem_SetMostRecentConfmdEvent(DEM_EVENT_INVALID);
  }
}

#if (DEM_FEATURE_NEED_OBD == STD_ON) || (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
/* ****************************************************************************
 % Dem_Esm_PostOnClear_Always
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PostOnClear_Always(
  uint8  MemoryId                                                                                                                /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_ARGUMENT(MemoryId)                                                                                           /* PRQA S 3112 */ /* MD_DEM_14.2 */

# if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
  /* copy debounce values from debounce array to nvram mirror */
  Dem_Mem_CopyDataDebounceNv();
  Dem_Mem_DebounceSetBlockState(DEM_NVM_BLOCKSTATE_DIRTYCLEAREDIMMEDIATE);
# endif
}
#endif

#if (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventDisplaced
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_EventDisplaced(
  Dem_EventIdType  EventId
  )
{
  Dem_Util_ForEachCombinedArgType lArgs;
  Dem_Util_ForEachCombinedEvent(EventId, Dem_Esm_EventDisplaced_Internal, &lArgs);

# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  {
    Dem_Cfg_CombinedGroupIndexType lGroupId;
    lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
    if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
    {
      Dem_Cfg_EventInternalStatusType lInternalStatus;
      lInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);
      lInternalStatus = DEM_ESM_SET_STORED_STATUS(lInternalStatus, DEM_ESM_STORED_STATUS_NONE);
      Dem_Mem_CombinedGroupSetStatus(lGroupId, lArgs.Common.NewDtcStatus);
      Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, lInternalStatus);
    }
  }
# endif
# if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
  /* Call status changed notifications (there is always a change) */
  Dem_Cbk_DtcStatusChanged(EventId, lArgs.Common.OldDtcStatus, lArgs.Common.NewDtcStatus);
# endif
}
#endif

/* ****************************************************************************
 % Dem_Esm_CycleUpdateAging
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_CycleUpdateAging(
  uint8  CycleId,
  uint16 CycleCounter
  )
{
  Dem_Cfg_MemoryIndexType lMemoryIndex;
  Dem_Cfg_MemoryIndexType lMemoryIndexEnd;
  /* Iterate through the primary indices - the chronological index becomes
      invalid in case an event ages */
  lMemoryIndexEnd = Dem_Mem_MemoryIndexAll_End();
  for (lMemoryIndex = Dem_Mem_MemoryIndexAll_Begin(); lMemoryIndex < lMemoryIndexEnd; ++lMemoryIndex)
  {
    Dem_Mem_EntryPtrType lEntry;
    Dem_EventIdType lEventId;

    lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);                                                                               /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
    lEventId = Dem_Mem_EntryGetEventId(lEntry);
    /* If the event does not support aging, the cycleId returned by
        Dem_Cfg_EventAgingCycle is not valid -> and it cannot match CycleId */
    if (DEM_EVENT_INVALID != lEventId)
    {
      if (Dem_Cfg_EventAgingCycle(lEventId) == CycleId)
      {
        Dem_Esm_EventAgingCycle(lEventId, CycleCounter, lMemoryIndex);
      }
#if (DEM_FEATURE_NEED_CYCLE_COUNTERS == STD_ON)
      if (Dem_Cfg_EventOperationCycle(lEventId) == CycleId)
      {
        boolean lDirty;
        lDirty = Dem_Data_EntryOpCycleStart(lEntry, CycleCounter);
        if (FALSE != lDirty)
        {
          Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
        }
      }
#endif
    }
  }
}

/* ****************************************************************************
 % Dem_Esm_CycleUpdateReadiness
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_CycleUpdateReadiness(
  uint8  CycleId,
  uint8 CycleStatus
  )
{
  Dem_EventIdType lEventId;

  /* Perform transitions due to cycle end or tick */

  for (lEventId = DEM_EVENT_FIRST; lEventId < Dem_Cfg_GlobalEventCount(); ++lEventId)
  {
    Dem_Util_ForEachCombinedArgType lArgs;

    if (Dem_Cfg_EventOperationCycle(lEventId) != CycleId)
    { /* Event needs to depend on the modified cycle */
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }
#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
    if (FALSE == Dem_Util_DtcAvailableInVariant(lEventId))
    { /* Don't process unavailable DTCs */
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }
#endif
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
    if (Dem_Util_DtcGetMasterEvent(lEventId) != lEventId)
    { /* Make sure to only process each event once */
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }
#endif
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
    if (FALSE != DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Util_DtcGetInternalStatus(lEventId)))
    { /* Don't process unavailable DTCs */
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }
#endif

#if (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON) || (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
    Dem_Data_DtcOpCycleUpdate(
       lEventId,
       Dem_Util_DtcApplyCombinedStatus(Dem_Util_DtcGetStatus(lEventId)),
       CycleStatus
    );
#endif

    lArgs.Specific.EventOpCycle_Internal.CycleStatus = CycleStatus;
    Dem_Util_ForEachCombinedEvent(lEventId, Dem_Esm_EventOpCycle_Internal, &lArgs);

#if ((DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON) || (DEM_CFG_NOTIFY_INIT_FUNC == STD_ON))
    /* Skip notifications if the cycle started was during Dem_Init - the
       environment is not initialized yet and cannot handle callbacks */
    if (Dem_InitState == DEM_INIT_INITIALIZED)
    {
# if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
      if (lArgs.Common.OldDtcStatus != lArgs.Common.NewDtcStatus)
      { /* Call notifications only if event status has changed */
        Dem_Cbk_DtcStatusChanged(lEventId, lArgs.Common.OldDtcStatus, lArgs.Common.NewDtcStatus);
      }
# endif
# if (DEM_CFG_NOTIFY_INIT_FUNC == STD_ON)
      /* Call Init Monitor Callbacks */
      Dem_Cbk_InitMonitorForFunction(lEventId);
# endif
    }
#endif
  } /* while (lEventId > DEM_EVENT_INVALID) */

}                                                                                                                                /* PRQA S 6010, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCAL */

                                                                    /* Timer */
/* ------------------------------------------------------------------------- */
                                                                    /* Queue */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Queue_PreInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_PreInit(
  void
  )
{
  Dem_EventIdType lEventId;

  Dem_Queue_CycleState = 0U;
  Dem_Queue_CycleFlag = 0U;
  Dem_Queue_EventCount = 0U;
#if (DEM_CFG_SUPPORT_EVENT_QUEUE == STD_ON)
  Dem_Queue_EventReadIndex = 0U;
  Dem_Queue_EventWriteIndex = 0U;
#endif

  for (lEventId = DEM_EVENT_FIRST; lEventId < Dem_Cfg_GlobalEventCount(); ++lEventId)
  {
    Dem_Queue_SetEventStatus(lEventId, 0U);
  }
}

/* ****************************************************************************
 % Dem_Queue_Init
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_Init(
  void
  )
{
  Dem_Queue_SetClearState(DEM_QUEUE_CLEARSTATE_IDLE);
#if (DEM_CFG_SUPPORT_CLEAR_DTC_RUNTIME_LIMIT== STD_ON)
  Dem_Queue_ClearEventIterator = DEM_EVENT_INVALID;
#endif
#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
  Dem_Queue_EnableConditionStates = Dem_Cfg_GlobalEnableCondInit();
#endif
}

/* ****************************************************************************
 % Dem_Queue_Shutdown
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_Shutdown(
  void
  )
{
  Dem_Queue_CycleState = 0U;
  Dem_Queue_CycleFlag = 0U;

}

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_Queue_ProcessFilterEventData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessFilterEventData(
  void
  )
{
  Dem_EventIdType lEventId;

  lEventId = Dem_Dcm_FilterDataGetEventId();

  if (DEM_EVENT_INVALID != lEventId)
  {
    DEM_MEM_MEMORYINFO_PARAM_VARDEF
    Dem_Cfg_MemoryIndexType lMemoryIndex;

    DEM_MEM_MEMORYINFO_PARAM_INIT(Dem_Dcm_FilterDataGetMemoryId())
    lMemoryIndex = Dem_Mem_MemoryFindIndex(lEventId);

    if (lMemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX)
    {
      Dem_MemCpy((Dem_DataPtrType)(&Dem_Cfg_ReadoutBuffer),                                                                      /* PRQA S 0310, 3305, 0602 */ /* MD_DEM_11.4_cpy, MD_DEM_3305, MD_DEM_20.2 */
                  (Dem_NvDataPtrType)(Dem_Mem_MemoryGetEntry(lMemoryIndex)),                                                     /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
                  sizeof(Dem_Cfg_PrimaryEntryType));
    }
  }

  Dem_Dcm_FilterDataSetState(DEM_DCM_FILTERDATA_READY);
}
#endif

#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
/* ****************************************************************************
 % Dem_Queue_ProcessClearSingleDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Queue_ProcessClearSingleDtc(
  void
  )
{
  boolean lReturnValue;
  uint8 lClearState;

# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_Queue_GetClearMemory() != Dem_Cfg_EventDestination(Dem_Queue_GetClearEvent()))
  {
    Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_INCONSISTENT_STATE)
  }
# endif

# if (DEM_CFG_NOTIFY_CLEAR_ALLOWED == STD_ON)
  lReturnValue = Dem_Esm_EventCleared_Optional(Dem_Queue_GetClearEvent());
# else
  Dem_Esm_EventCleared_Always(Dem_Queue_GetClearEvent());
  lReturnValue = TRUE;
# endif

# if (DEM_CFG_NOTIFY_CLEAR_ALLOWED == STD_ON)
  if (FALSE == lReturnValue)
  {
#  if (DEM_FEATURE_NEED_OBD == STD_ON) || (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
    Dem_Esm_PostOnClear_Always(Dem_Queue_GetClearMemory());
#  endif
/* >>>> ------------------------------------- Enter Critical Section: DcmApi */
    Dem_EnterCritical_DcmApi();                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lClearState = Dem_Queue_GetClearState();
    lClearState = DEM_QUEUE_RESETCLEARSTATE_PENDING(lClearState);
    lClearState = DEM_QUEUE_SETCLEARSTATE_DONE(lClearState);
    lClearState = DEM_QUEUE_SETCLEARSTATE_FAILED(lClearState);
    Dem_Queue_SetClearState(lClearState);
    Dem_LeaveCritical_DcmApi();                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< ------------------------------------- Enter Critical Section: DcmApi */
  }
  else
# endif
  {
# if (DEM_FEATURE_NEED_OBD == STD_ON) || (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
    Dem_Esm_PostOnClear_Always(Dem_Queue_GetClearMemory());
# endif
    Dem_Mem_StatusSetBlockState(DEM_NVM_BLOCKSTATE_DIRTYCLEAREDIMMEDIATE);
/* >>>> ------------------------------------- Enter Critical Section: DcmApi */
    Dem_EnterCritical_DcmApi();                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lClearState = Dem_Queue_GetClearState();
    lClearState = DEM_QUEUE_RESETCLEARSTATE_PENDING(lClearState);
    lClearState = DEM_QUEUE_SETCLEARSTATE_DONE(lClearState);
    Dem_Queue_SetClearState(lClearState);
    Dem_LeaveCritical_DcmApi();                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< ------------------------------------- Enter Critical Section: DcmApi */
  }

  return lReturnValue;
}
#endif

/* ****************************************************************************
 % Dem_Queue_ProcessClearDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessClearDtc(
  void
  )
{
  DEM_MEM_MEMORYINFO_PARAM_VARDEF
#if (DEM_CFG_SUPPORT_CLEAR_DTC_RUNTIME_LIMIT == STD_ON)
  uint16 lEventLowerLimit;
#endif
#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
  boolean lClearSuccess;
#endif

  DEM_MEM_MEMORYINFO_PARAM_INIT(Dem_Queue_GetClearMemory())

  {
#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
    if (DEM_EVENT_INVALID != Dem_Queue_GetClearEvent())
    { /* Clear single event */
      lClearSuccess = Dem_Queue_ProcessClearSingleDtc();
    }
    else
#endif
    { /* Clear group of events */
#if (DEM_CFG_SUPPORT_CLEAR_DTC_RUNTIME_LIMIT == STD_ON)
      if (DEM_EVENT_INVALID == Dem_Queue_ClearEventIterator)
      { /* Not yet started */
        Dem_Queue_ClearEventIterator = Dem_Mem_MemoryGetLastEvent();

# if (DEM_FEATURE_NEED_OBD == STD_ON) && (DEM_CFG_SUPPORT_RESTART_DCY_ON_CLEAR_DTC == STD_ON)
        if (Dem_Queue_GetClearGroup() == DEM_CFG_GROUPMASK_ALLDTCS)
        {
          Dem_Esm_PreOnClear_AllDtc(Dem_Queue_GetClearMemory());
        }
# endif
      }

      if (Dem_Cfg_GlobalClearDtcRuntimeLimit() > Dem_Queue_ClearEventIterator)
      { /* At most delete all events to prevent overflow */
        lEventLowerLimit = (uint16)(Dem_Mem_MemoryGetFirstEvent() - 1);
      }
      else
      {
        lEventLowerLimit = (uint16)(Dem_Queue_ClearEventIterator - Dem_Cfg_GlobalClearDtcRuntimeLimit());
# if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
        if (lEventLowerLimit < Dem_Mem_MemoryGetFirstEvent())
        {
          lEventLowerLimit = (uint16)(Dem_Mem_MemoryGetFirstEvent() - 1);
        }
# endif
      }

      /* Attention: lEventLowerLimit is numerically smaller than current iterator */
      Dem_Queue_ProcessClearDtcGroup(lEventLowerLimit + 1, Dem_Queue_ClearEventIterator);
      Dem_Queue_ClearEventIterator = lEventLowerLimit;
#else
# if (DEM_FEATURE_NEED_OBD == STD_ON) && (DEM_CFG_SUPPORT_RESTART_DCY_ON_CLEAR_DTC == STD_ON)
      if (Dem_Queue_GetClearGroup() == DEM_CFG_GROUPMASK_ALLDTCS)
      {
        Dem_Esm_PreOnClear_AllDtc(Dem_Queue_GetClearMemory());
      }
# endif
      Dem_Queue_ProcessClearDtcGroup(Dem_Mem_MemoryGetFirstEvent(), Dem_Mem_MemoryGetLastEvent());
#endif
#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
      lClearSuccess = TRUE;
#endif
    } /* Clear group of events */
  }

#if (DEM_CFG_SUPPORT_CLEAR_DTC_RUNTIME_LIMIT == STD_ON)
  if ( (0 == Dem_Queue_ClearEventIterator)
# if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
    || (Dem_Mem_MemoryGetFirstEvent() > Dem_Queue_ClearEventIterator)
# endif
    )
#endif
  {
#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
    if (FALSE != lClearSuccess)
#endif
    {
      uint8 lClearState;

#if (DEM_CFG_SUPPORT_CLEAR_DTC_RUNTIME_LIMIT== STD_ON)
      Dem_Queue_ClearEventIterator = DEM_EVENT_INVALID;
#endif

      {
        if (Dem_Queue_GetClearGroup() == DEM_CFG_GROUPMASK_ALLDTCS)
        {
          Dem_Esm_PostOnClear_AllDtc(Dem_Queue_GetClearMemory());
        }
      }
#if (DEM_FEATURE_NEED_OBD == STD_ON) || (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
      Dem_Esm_PostOnClear_Always(Dem_Queue_GetClearMemory());
#endif
      Dem_Mem_StatusSetBlockState(DEM_NVM_BLOCKSTATE_DIRTYCLEAREDIMMEDIATE);

      /* Set state as last action because of concurrency */
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DcmApi */
      Dem_EnterCritical_DcmApi();                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
      lClearState = Dem_Queue_GetClearState();
      lClearState = DEM_QUEUE_RESETCLEARSTATE_PENDING(lClearState);
      lClearState = DEM_QUEUE_SETCLEARSTATE_DONE(lClearState);
      Dem_Queue_SetClearState(lClearState);
      Dem_LeaveCritical_DcmApi();                                                                                                /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Enter Critical Section: DcmApi */
    }
  }
}                                                                                                                                /* PRQA S 6010, 6050, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCAL, MD_MSR_STCYC, MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_Queue_ProcessEvent_Queued
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEvent_Queued(
  Dem_EventIdType  EventId,
  uint8 QueueStatus
)
{
#if ((DEM_FEATURE_NEED_FDC_TRIP == STD_ON) && (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON))
  if (FALSE != DEM_QUEUE_TEST_FDCPROCESSING(QueueStatus))
  {
    Dem_Esm_ProcessFdc(EventId);
  }
#endif

  switch (DEM_QUEUE_GET_QUEUEACTION(QueueStatus))
  {
  case 1:
    Dem_Esm_EventPassed_Queued(EventId);
    break;
  case 2:
    Dem_Esm_EventPassed_Queued(EventId);
    Dem_Esm_EventFailed_Queued(EventId);
    break;
  case 3:
    Dem_Esm_EventPassed_Queued(EventId);
    Dem_Esm_EventFailed_Queued(EventId);
    Dem_Esm_EventPassed_Queued(EventId);
    break;

  case 5:
    Dem_Esm_EventFailed_Queued(EventId);
    break;
  case 6:
    Dem_Esm_EventFailed_Queued(EventId);
    Dem_Esm_EventPassed_Queued(EventId);
    break;
  case 7:
    Dem_Esm_EventFailed_Queued(EventId);
    Dem_Esm_EventPassed_Queued(EventId);
    Dem_Esm_EventFailed_Queued(EventId);
    break;

  default:
    /* No action */
    break;
  }
}

/* ****************************************************************************
 % Dem_Queue_ProcessEvent_Immediate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEvent_Immediate(
  Dem_EventIdType  EventId,
  uint8 QueueStatus
  )
{
#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  if (FALSE != DEM_QUEUE_TEST_FDCPROCESSING(QueueStatus))
  {
    Dem_Esm_ProcessFdc(EventId);
  }
#endif

  switch (DEM_QUEUE_GET_QUEUEACTION(QueueStatus))
  {
  case 1:
  case 4:
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    break;
  case 2:
  case 5:
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    break;
  case 3:
  case 6:
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    Dem_Esm_EventFailed_Immediate(EventId, DEM_CFG_TRIGGER_TESTFAILED, DEM_CFG_TRIGGER_TESTFAILED);
    break;

  case 7:
    Dem_Esm_EventFailed_Immediate(EventId, DEM_CFG_TRIGGER_TESTFAILED, DEM_CFG_TRIGGER_TESTFAILED);
    break;
  case 8:
    Dem_Esm_EventFailed_Immediate(EventId, DEM_CFG_TRIGGER_TESTFAILED, DEM_CFG_TRIGGER_TESTFAILED);
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    break;
  case 9:
    Dem_Esm_EventFailed_Immediate(EventId, DEM_CFG_TRIGGER_TESTFAILED, DEM_CFG_TRIGGER_TESTFAILED);
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    Dem_Esm_EventFailed_Immediate(EventId, DEM_CFG_TRIGGER_TESTFAILED, DEM_CFG_TRIGGER_TESTFAILED);
    break;

  case 10:
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    break;
  case 11:
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    break;
  case 12:
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    Dem_Esm_EventFailed_Immediate(EventId, DEM_CFG_TRIGGER_TESTFAILED, DEM_CFG_TRIGGER_TESTFAILED);
    break;

  case 13:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    break;
  case 14:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    break;
  case 15:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    break;

  case 16:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    break;
  case 17:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    Dem_Esm_EventFailed_Immediate(EventId, DEM_CFG_TRIGGER_TESTFAILED, DEM_CFG_TRIGGER_TESTFAILED);
    break;
  case 18:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    Dem_Esm_EventFailed_Immediate(EventId, DEM_CFG_TRIGGER_TESTFAILED, DEM_CFG_TRIGGER_TESTFAILED);
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    break;

  case 19:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_NONE);
    break;
  case 20:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_NONE);
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    break;
  case 21:
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_NONE);
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    Dem_Esm_EventPassed_Immediate(EventId, DEM_CFG_TRIGGER_TESTPASSED);
    break;

#if (DEM_CFG_SUPPORT_RETRY_STORAGE == STD_ON)
  case 22:
    Dem_Esm_EventFailed_Immediate(EventId,
      (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
      (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
    break;
#endif

  default:
    /* Do nothing with this event */
    break;
  }
}                                                                                                                                /* PRQA S 6030 */ /* MD_MSR_STCYC */

/* ****************************************************************************
 % Dem_Queue_ProcessEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEvent(
Dem_EventIdType  EventId
)
{
  uint8 lEventQueueStatus;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
/* A monitor could interrupt the MainFunction and try to publish a new test result. This critical section prevents
   such a monitor from modifying the toggle count. We removed the queue entry and reset the update pending flag as
   well. A monitor waiting on this critical section can immediately requeue this event without losing information. */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lEventQueueStatus = Dem_Queue_GetEventStatus(EventId);
  Dem_Queue_SetEventStatus(EventId, DEM_QUEUE_EVENT_NONE);

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  Dem_Esm_EventPrestorageLock(EventId);
#endif

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */

  /* Filter out cleared queue entries */
  if (lEventQueueStatus != DEM_QUEUE_EVENT_QUEUED)
  {
    if ( (DEM_CFG_EVENT_KIND_BSW == Dem_Cfg_EventKind(EventId))
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
      || (DEM_CFG_COMBINED_GROUP_INVALID != Dem_Cfg_EventCombinedGroup(EventId))
#endif
# if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
      || (DEM_CFG_DEBOUNCETYPE_TIMER == Dem_Cfg_EventDebounceType(EventId))
# endif
      )
    {
      Dem_Queue_ProcessEvent_Queued(EventId, lEventQueueStatus);
    }
    else
    {
      Dem_Queue_ProcessEvent_Immediate(EventId, lEventQueueStatus);
    }
  }

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  Dem_Esm_EventPrestorageRelease();
#endif
}

/* ****************************************************************************
 % Dem_Queue_ProcessSetEventStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessSetEventStatus(
  void
  )
{
  /* Count the number of events processed - This allows to modify the global 'Pending Events' counter only once,
   * and we could use it to implement a runtime limiter if we so desire */
  uint16 lProcessedEventCount;
  lProcessedEventCount = 0;

#if (DEM_CFG_SUPPORT_EVENT_QUEUE == STD_ON)
  {
    /* Create a local copy of the global read index to optimize access - we are known to be the only writer of the
      * global variable, so it is safe to do so. On the other hand the global itself must be volatile since we might
      * interrupt a monitor */
    uint8 lQueueReadIndex;
    lQueueReadIndex = Dem_Queue_EventReadIndex;

    /* Dem_Queue_EventReadIndex == Dem_Queue_EventWriteIndex indicates a completely filled queue. So, the loop has
      * to run at least once, hence the do..while loop. After the first fetch we have exhausted the queue if we catch
      * up with the write index (again). */
    do
    {
      Dem_EventIdType lEventId;
      lEventId = Dem_Cfg_EventQueue[lQueueReadIndex];

      Dem_WrappingIncrement(lQueueReadIndex, Dem_Cfg_GlobalQueueSize())
      Dem_Queue_EventReadIndex = lQueueReadIndex;

      Dem_Queue_ProcessEvent(lEventId);
      ++lProcessedEventCount;
    }
    while (lQueueReadIndex != Dem_Queue_EventWriteIndex);
  }
#endif
  if (Dem_Queue_EventCount > lProcessedEventCount)
  { /* Queue overflow (also no queue available) */
    Dem_EventIdType lEventId;

    for (lEventId = DEM_EVENT_FIRST; lEventId < Dem_Cfg_GlobalEventCount(); ++lEventId)
    { /* Clear stored state for all events */
      if (DEM_QUEUE_EVENT_PENDING == DEM_QUEUE_GET_QUEUESTATE(Dem_Queue_GetEventStatus(lEventId)))
      {
        Dem_Queue_ProcessEvent(lEventId);
        ++lProcessedEventCount;
      }
    }
  }

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
  Dem_Queue_EventCount = (uint16)(Dem_Queue_EventCount - lProcessedEventCount);
  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
}

/* ****************************************************************************
 % Dem_Queue_ProcessCycles
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessCycles(
  void
  )
{
  uint8 lCycleId;
  uint16 lDem_Queue_CycleState;
  uint16 lDem_Queue_CycleFlag;

/* >>>> --------------------------------- Enter Critical Section: StateManager */
  Dem_EnterCritical_StateManager();                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lDem_Queue_CycleState = Dem_Queue_CycleState;
  Dem_Queue_CycleState = 0U;

  lDem_Queue_CycleFlag = Dem_Queue_CycleFlag;
  Dem_Queue_CycleFlag = 0U;

  Dem_LeaveCritical_StateManager();                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< --------------------------------- Leave Critical Section: StateManager */

  lCycleId = 0;
  while (0 != lDem_Queue_CycleFlag)
  {
    if ((lDem_Queue_CycleFlag & 0x01U) != 0)
    {
      uint8 lNewStatus;
      uint8 lOldStatus;
      lNewStatus = (uint8)(((lDem_Queue_CycleState & 0x01U) != 0)?DEM_QUEUE_CYCLE_STARTED:DEM_QUEUE_CYCLE_STOPPED);
      lOldStatus = Dem_Mem_GetCycleStatus(lCycleId);
      if (DEM_QUEUE_CYCLE_STARTED == lNewStatus)
      {

        if (lNewStatus == lOldStatus)
        {
          Dem_Esm_CycleUpdate(lCycleId, DEM_QUEUE_CYCLE_RESTARTED);
        }
        else
        {
          Dem_Esm_CycleUpdate(lCycleId, DEM_QUEUE_CYCLE_STARTED);
        }
      }
      else
      {
        Dem_Esm_CycleUpdate(lCycleId, DEM_QUEUE_CYCLE_STOPPED);
      }
    }
    ++lCycleId;
    lDem_Queue_CycleFlag = (uint16)(lDem_Queue_CycleFlag >> 1U);
    lDem_Queue_CycleState = (uint16)(lDem_Queue_CycleState >> 1U);
  }
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
/* ****************************************************************************
 % Dem_Queue_ProcessEventEnableConditions
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEventEnableConditions(
  Dem_EventIdType EventId,
  uint32 OldConditionStates,
  uint32 NewConditionStates
)
{
  /* Reset/Freeze de-bouncing on enable condition state change unlocked -> locked */
# if ( (DEM_FEATURE_NEED_DEBOUNCEFREEZE == STD_ON) \
    || (DEM_FEATURE_NEED_DEBOUNCEDISABLE == STD_ON) \
    || ((DEM_FEATURE_NEED_DEBOUNCERESET == STD_ON) && (DEM_CFG_RESET_DEBOUNCE_ON_DISABLE_ENABLE_CONDITIONS == STD_ON)) )
  if (((OldConditionStates & Dem_Cfg_EventEnableConditions(EventId)) == Dem_Cfg_EventEnableConditions(EventId))
    && ((NewConditionStates & Dem_Cfg_EventEnableConditions(EventId)) != Dem_Cfg_EventEnableConditions(EventId)))
  {
    /* Enable conditions become disabled.
       If DEM_CFG_RESET_DEBOUNCE_ON_ENABLE_ENABLE_CONDITIONS:
         If the event is configured to freeze, or will not continue counting: freeze it
       If DEM_CFG_RESET_DEBOUNCE_ON_DISABLE_ENABLE_CONDITIONS:
         If the event is configured to freeze: freeze it
         Otherwise: reset it
       */
#  if (DEM_CFG_RESET_DEBOUNCE_ON_ENABLE_ENABLE_CONDITIONS == STD_ON)
#   if (DEM_FEATURE_NEED_DEBOUNCECONTINUOUS == STD_ON)
#    if (DEM_CFG_ISCONST_DEBOUNCERESET != STD_ON) || (DEM_CFG_ISCONST_DEBOUNCECONTINUOUS != STD_ON)
    if (
#    endif
#    if (DEM_CFG_ISCONST_DEBOUNCERESET != STD_ON)
         (Dem_Cfg_EventDebounceReset(EventId) == FALSE)
#    endif
#    if (DEM_CFG_ISCONST_DEBOUNCERESET != STD_ON) && (DEM_CFG_ISCONST_DEBOUNCECONTINUOUS != STD_ON)
      ||
#    endif
#    if (DEM_CFG_ISCONST_DEBOUNCECONTINUOUS != STD_ON)
         (Dem_Cfg_EventDebounceContinuous(EventId) == FALSE)
#    endif
#    if (DEM_CFG_ISCONST_DEBOUNCERESET != STD_ON) || (DEM_CFG_ISCONST_DEBOUNCECONTINUOUS != STD_ON)
       )
#    endif
#   endif
#   if (DEM_FEATURE_NEED_DEBOUNCEFREEZE == STD_ON) || (DEM_FEATURE_NEED_DEBOUNCEDISABLE == STD_ON)
    {
      Dem_Esm_EventResetDebounceState(EventId, DEM_DEBOUNCE_STATUS_FREEZE);
    }
#   endif
#  endif
#  if (DEM_CFG_RESET_DEBOUNCE_ON_DISABLE_ENABLE_CONDITIONS == STD_ON)
#   if (DEM_CFG_ISCONST_DEBOUNCERESET != STD_ON)
    if (Dem_Cfg_EventDebounceReset(EventId) == FALSE)
#   endif
    {
#   if (DEM_FEATURE_NEED_DEBOUNCEFREEZE == STD_ON)
      Dem_Esm_EventResetDebounceState(EventId, DEM_DEBOUNCE_STATUS_FREEZE);
#   endif
    }
#   if (DEM_CFG_ISCONST_DEBOUNCERESET != STD_ON)
    else
#   endif
    {
#   if (DEM_FEATURE_NEED_DEBOUNCERESET == STD_ON)
      Dem_Esm_EventResetDebounceState(EventId, DEM_DEBOUNCE_STATUS_RESET);
#   endif
    }
#  endif
  }
  else
# endif
# if ( (((DEM_CFG_NOTIFY_INIT_MONITOR == STD_ON) || (DEM_CFG_NOTIFY_INIT_FUNC == STD_ON)) && (DEM_CFG_NOTIFY_ENABLECONDITION == STD_ON)) \
    || ((DEM_FEATURE_NEED_DEBOUNCERESET == STD_ON) && (DEM_CFG_RESET_DEBOUNCE_ON_ENABLE_ENABLE_CONDITIONS == STD_ON)) )
  /* Un-freeze de-bouncing, notify enable condition state change locked -> unlocked */
  if ( ((OldConditionStates & Dem_Cfg_EventEnableConditions(EventId)) != Dem_Cfg_EventEnableConditions(EventId))
    && ((NewConditionStates & Dem_Cfg_EventEnableConditions(EventId)) == Dem_Cfg_EventEnableConditions(EventId)) )
  {
    /* Enable conditions become fulfilled.
       Freeze Debouncing:
         -
       Reset Debouncing:
         If the event is configured to reset, and the global setting is to reset on disable EC
       Call InitMonitor for event/function:
         If any are configured
       */
#  if (DEM_CFG_RESET_DEBOUNCE_ON_ENABLE_ENABLE_CONDITIONS == STD_ON)
#   if (DEM_CFG_ISCONST_DEBOUNCERESET != STD_ON)
    if (FALSE != Dem_Cfg_EventDebounceReset(EventId))
#   endif
#   if (DEM_FEATURE_NEED_DEBOUNCERESET == STD_ON)
    {
      Dem_Esm_EventResetDebounceState(EventId, DEM_DEBOUNCE_STATUS_RESET);
    }
#   endif
#  endif
#  if (DEM_CFG_NOTIFY_INIT_MONITOR == STD_ON)
    Dem_Cbk_InitMonitorForEvent(EventId, DEM_INIT_MONITOR_REENABLED);
#  endif
#  if (DEM_CFG_NOTIFY_INIT_FUNC == STD_ON)
    Dem_Cbk_InitMonitorForFunction(EventId);
#  endif
  }
  else
# endif
  {
    /* Do nothing */
  }
}
#endif

#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
/* ****************************************************************************
 % Dem_Queue_ProcessEnableConditions
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_ProcessEnableConditions(
  void
  )
{
  if ( (Dem_CurrentEnableConditionStates != Dem_Queue_EnableConditionStates)                                                     /* PRQA S 3415 */ /* MD_DEM_12.4_cs */
    || (Dem_CurrentEnableConditionStates != Dem_NextEnableConditionStates))
  {
    Dem_EventIdType lEventId;
    uint32 lCurrentEnableConditions;
    uint32 lNextEnableConditions;

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: StateManager */
    Dem_EnterCritical_StateManager();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* Copy current value to avoid concurrent modification */
    lCurrentEnableConditions = Dem_CurrentEnableConditionStates;
    lNextEnableConditions = Dem_NextEnableConditionStates;

    Dem_LeaveCritical_StateManager();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: StateManager */

    if ( (lCurrentEnableConditions != Dem_Queue_EnableConditionStates)
      || (lCurrentEnableConditions != lNextEnableConditions))
    {
      for (lEventId = DEM_EVENT_FIRST; lEventId < Dem_Cfg_GlobalEventCount(); ++lEventId)
      {
# if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
        if (FALSE != Dem_Cfg_EventAvailableInVariant(lEventId))
# endif
        {
# if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
          if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(lEventId)))
# endif
          {
            /* Notify/Process for Queue->Current */
            Dem_Queue_ProcessEventEnableConditions(lEventId, Dem_Queue_EnableConditionStates, lCurrentEnableConditions);
            /* Notify/Process for Current->Next */
            Dem_Queue_ProcessEventEnableConditions(lEventId, lCurrentEnableConditions, lNextEnableConditions);
          }
        }
      }
    }

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: StateManager */
    Dem_EnterCritical_StateManager();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* Keep newly disabled bits, but process newly enabled bits until next task */
    lNextEnableConditions = (lNextEnableConditions & Dem_NextEnableConditionStates);
    Dem_CurrentEnableConditionStates = lNextEnableConditions;

    Dem_LeaveCritical_StateManager();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: StateManager */

    /* Store reference value */
    Dem_Queue_EnableConditionStates = lNextEnableConditions;
  }
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

/* ****************************************************************************
 % Dem_Queue_MainFunction
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Queue_MainFunction(
  void
  )
{
#if (DEM_CFG_SUPPORT_DCM == STD_ON)
  if (DEM_DCM_FILTERDATA_PENDING == Dem_Dcm_FilterDataGetState())
  {
    Dem_Queue_ProcessFilterEventData();
  }
#endif

#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
  Dem_Queue_ProcessEnableConditions();
#endif

  if (FALSE != DEM_QUEUE_TESTCLEARSTATE_PENDING(Dem_Queue_GetClearState()))
  {
    Dem_Queue_ProcessClearDtc();
  }

  if (0U != Dem_Queue_EventCount)
  {
    Dem_Queue_ProcessSetEventStatus();
  }

  if (0U != Dem_Queue_CycleFlag)
  {
    Dem_Queue_ProcessCycles();
  }

}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_CAL */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_AGINGCTR == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyUpwardsAgingCounter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyUpwardsAgingCounter(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

  if ( (DEM_ESM_CYCLECOUNT_INVALID == Dem_Mem_EntryGetAgingCount(CopyDidInfoPtr->Entry))
  # if (DEM_CFG_AGING_COUNT_ONLY_AGEABLE == STD_ON)
    || (FALSE == Dem_Cfg_EventSupportAging(CopyDidInfoPtr->EventId))
  # endif
     )
  {
    CopyDidInfoPtr->DestinationBuffer[0] = 0x00U;
  }
  else
  if (DEM_ESM_CYCLECOUNT_LATCHED == Dem_Mem_EntryGetAgingCount(CopyDidInfoPtr->Entry))
  {
    CopyDidInfoPtr->DestinationBuffer[0] = 0xffU;
  }
# if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
  else
  if (DEM_ESM_CYCLECOUNT_EVENT_AGED == Dem_Mem_EntryGetAgingCount(CopyDidInfoPtr->Entry))
  {
    CopyDidInfoPtr->DestinationBuffer[0] = (uint8)(Dem_Cfg_EventAgingTarget(CopyDidInfoPtr->EventId));
  }
# endif
  else
  {
    uint16 lTarget = Dem_Mem_EntryGetAgingCount(CopyDidInfoPtr->Entry);
    uint16 lCurrent = Dem_Mem_GetCycleCounter(Dem_Cfg_EventAgingCycle(CopyDidInfoPtr->EventId));
    CopyDidInfoPtr->DestinationBuffer[0] = (uint8)(Dem_Cfg_EventAgingTarget(CopyDidInfoPtr->EventId) - Dem_Esm_CycleCountDistance(lCurrent, lTarget));
  }

  return TRUE;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_AGINGCTR == STD_ON) */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_AGINGCTR_INVERTED == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyDownwardsAgingCounter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyDownwardsAgingCounter(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

  if ( (DEM_ESM_CYCLECOUNT_INVALID == Dem_Mem_EntryGetAgingCount(CopyDidInfoPtr->Entry))
# if (DEM_CFG_AGING_COUNT_ONLY_AGEABLE == STD_ON)
    || (FALSE == Dem_Cfg_EventSupportAging(CopyDidInfoPtr->EventId))
# endif
     )
  {
    CopyDidInfoPtr->DestinationBuffer[0] = Dem_Cfg_EventAgingTarget(CopyDidInfoPtr->EventId);
  }
  else
  if ( (DEM_ESM_CYCLECOUNT_LATCHED == Dem_Mem_EntryGetAgingCount(CopyDidInfoPtr->Entry))
#  if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
    || (DEM_ESM_CYCLECOUNT_EVENT_AGED == Dem_Mem_EntryGetAgingCount(CopyDidInfoPtr->Entry))
#  endif
    )
  {
    CopyDidInfoPtr->DestinationBuffer[0] = 0x00U;
  }
  else
  {
    uint16 lTarget = Dem_Mem_EntryGetAgingCount(CopyDidInfoPtr->Entry);
    uint16 lCurrent = Dem_Mem_GetCycleCounter(Dem_Cfg_EventAgingCycle(CopyDidInfoPtr->EventId));
    CopyDidInfoPtr->DestinationBuffer[0] = (uint8)(Dem_Esm_CycleCountDistance(lCurrent, lTarget));
  }
  return TRUE;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_AGINGCTR_INVERTED == STD_ON) */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_OCCCTR == STD_ON)
/* ****************************************************************************
 % Dem_Data_Copy1ByteOccurrenceCounter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_Copy1ByteOccurrenceCounter(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  boolean lReturnValue;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

# if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
  if (FALSE != DEM_MEM_TEST_AGING_ONLY(Dem_Mem_EntryGetState(CopyDidInfoPtr->Entry)))
  {
    lReturnValue = FALSE;
  }
  else
# endif
# if (DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON)
  if (Dem_Mem_EntryGetOccurrenceCount(CopyDidInfoPtr->Entry) > 0xffU)
  {
    CopyDidInfoPtr->DestinationBuffer[0] = 0xffU;
    lReturnValue = TRUE;
  }
  else
# endif
  {
    CopyDidInfoPtr->DestinationBuffer[0] = (uint8)Dem_Mem_EntryGetOccurrenceCount(CopyDidInfoPtr->Entry);
    lReturnValue = TRUE;
  }

  return lReturnValue;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_OCCCTR == STD_ON) */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON)
/* ****************************************************************************
 % Dem_Data_Copy2ByteOccurrenceCounter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_Copy2ByteOccurrenceCounter(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  boolean lReturnValue;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

# if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
  if (FALSE != DEM_MEM_TEST_AGING_ONLY(Dem_Mem_EntryGetState(CopyDidInfoPtr->Entry)))
  {
    lReturnValue = FALSE;
  }
  else
# endif
  {
    CopyDidInfoPtr->DestinationBuffer[0] = Dem_GetHiByte(Dem_Mem_EntryGetOccurrenceCount(CopyDidInfoPtr->Entry));
    CopyDidInfoPtr->DestinationBuffer[1] = Dem_GetLoByte(Dem_Mem_EntryGetOccurrenceCount(CopyDidInfoPtr->Entry));
    lReturnValue = TRUE;
  }

  return lReturnValue;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON) */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_OVFLIND == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyOverflowIndication
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyOverflowIndication(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

  CopyDidInfoPtr->DestinationBuffer[0] = (uint8)Dem_Mem_GetOverflow(Dem_Cfg_EventDestination(CopyDidInfoPtr->EventId));

  return TRUE;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_OVFLIND == STD_ON) */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_SIGNIFICANCE == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyEventSignificance
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyEventSignificance(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

  CopyDidInfoPtr->DestinationBuffer[0] = (uint8)(Dem_Cfg_EventSignificance(CopyDidInfoPtr->EventId) == DEM_CFG_EVENT_SIGNIFICANCE_FAULT);

  return TRUE;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_SIGNIFICANCE == STD_ON) */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_PRIORITY == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyEventPriority
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyEventPriority(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

  CopyDidInfoPtr->DestinationBuffer[0] = (uint8)Dem_Cfg_EventPriority(CopyDidInfoPtr->EventId);

  return TRUE;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_PRIORITY == STD_ON) */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyMaxFdcSinceLastClear
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyMaxFdcSinceLastClear(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  boolean lReturnValue;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

# if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
  if (FALSE != DEM_MEM_TEST_AGING_ONLY(Dem_Mem_EntryGetState(CopyDidInfoPtr->Entry)))
  {
    lReturnValue = FALSE;
  }
  else
# endif
  {
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
    Dem_Cfg_CombinedGroupIndexType lGroupId;
    lGroupId = Dem_Cfg_EventCombinedGroup(CopyDidInfoPtr->EventId);
    if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
    {
      CopyDidInfoPtr->DestinationBuffer[0] = (uint8)Dem_Mem_EntryGetDebounceValueMax(CopyDidInfoPtr->Entry);
    }
    else
# endif
    {
      switch (Dem_Cfg_EventDebounceType(CopyDidInfoPtr->EventId))
      {
# if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
      case DEM_CFG_DEBOUNCETYPE_COUNTER:
        CopyDidInfoPtr->DestinationBuffer[0] = (uint8)Dem_Data_CalculateFDC_CounterBased(CopyDidInfoPtr->EventId,
                                                                                         Dem_Mem_EntryGetDebounceValueMax(CopyDidInfoPtr->Entry));
        break;
# endif  /* ( DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON ) */
# if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
      case DEM_CFG_DEBOUNCETYPE_TIMER:
        if (FALSE != DEM_ESM_TEST_UDS_STATUS_TFSLC(Dem_Mem_EventGetStatus(CopyDidInfoPtr->EventId)))
        {
          CopyDidInfoPtr->DestinationBuffer[0] = (uint8)127U;
        }
        else
        {
          CopyDidInfoPtr->DestinationBuffer[0] = (uint8)Dem_Data_CalculateFDC_TimeBased(CopyDidInfoPtr->EventId,
                                                                                        Dem_Mem_EntryGetDebounceValueMax(CopyDidInfoPtr->Entry),
                                                                                        DEM_ESM_DEBOUNCE_COUNT_FAILED);
        }
        break;
# endif /* (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) */
# if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
      case DEM_CFG_DEBOUNCETYPE_EXTERNAL:
        if (FALSE != DEM_ESM_TEST_UDS_STATUS_TFSLC(Dem_Mem_EventGetStatus(CopyDidInfoPtr->EventId)))
        {
          CopyDidInfoPtr->DestinationBuffer[0] = (uint8)127U;
        }
        else
        {
          CopyDidInfoPtr->DestinationBuffer[0] = (uint8)0U;
        }
        break;
# endif
      default:
        /* unreachable MISRA case */
        break;
      }
    }

    lReturnValue = TRUE;
  }

  return lReturnValue;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON) */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyMaxFdcThisCycle
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyMaxFdcThisCycle(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  sint8 lFdc;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

  {
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
    Dem_Cfg_CombinedGroupIndexType lGroupId;
    lGroupId = Dem_Cfg_EventCombinedGroup(CopyDidInfoPtr->EventId);
    if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
    {
      lFdc = Dem_Data_CombinedGroupGetFDCMax(lGroupId);
    }
    else
# endif
    {
      lFdc = Dem_Data_EventGetFDCMax(CopyDidInfoPtr->EventId);
    }
  }

  CopyDidInfoPtr->DestinationBuffer[0] = (uint8)lFdc;

  return TRUE;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON) */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyCyclesSinceLastFailed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCyclesSinceLastFailed(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

  if (DEM_ESM_CYCLECOUNT_INVALID == Dem_Mem_EntryGetLastFailedCycleCount(CopyDidInfoPtr->Entry))
  {
    CopyDidInfoPtr->DestinationBuffer[0] = 0x00U;
  }
  else
  if (DEM_ESM_CYCLECOUNT_LATCHED == Dem_Mem_EntryGetLastFailedCycleCount(CopyDidInfoPtr->Entry))
  {
    CopyDidInfoPtr->DestinationBuffer[0] = 0xffU;
  }
  else
  {
    CopyDidInfoPtr->DestinationBuffer[0] = (uint8)Dem_Esm_CycleCountDistance(
      Dem_Mem_EntryGetLastFailedCycleCount(CopyDidInfoPtr->Entry),
      Dem_Mem_GetCycleCounter(Dem_Cfg_EventOperationCycle(CopyDidInfoPtr->EventId)));
  }

  return TRUE;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON) */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyCyclesSinceFirstFailed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCyclesSinceFirstFailed(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

  if (DEM_ESM_CYCLECOUNT_INVALID == Dem_Mem_EntryGetFirstFailedCycleCount(CopyDidInfoPtr->Entry))
  {
    CopyDidInfoPtr->DestinationBuffer[0] = 0x00U;
  }
  else
  if (DEM_ESM_CYCLECOUNT_LATCHED == Dem_Mem_EntryGetFirstFailedCycleCount(CopyDidInfoPtr->Entry))
  {
    CopyDidInfoPtr->DestinationBuffer[0] = 0xffU;
  }
  else
  {
    CopyDidInfoPtr->DestinationBuffer[0] = (uint8)Dem_Esm_CycleCountDistance(
      Dem_Mem_EntryGetFirstFailedCycleCount(CopyDidInfoPtr->Entry),
      Dem_Mem_GetCycleCounter(Dem_Cfg_EventOperationCycle(CopyDidInfoPtr->EventId)));
  }

  return TRUE;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON) */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_FAILED_CYCLES == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyFailedCycles
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyFailedCycles(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  boolean lReturnValue;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

# if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
  if (FALSE != DEM_MEM_TEST_AGING_ONLY(Dem_Mem_EntryGetState(CopyDidInfoPtr->Entry)))
  {
    lReturnValue = FALSE;
  }
  else
# endif
  {
    CopyDidInfoPtr->DestinationBuffer[0] = Dem_Mem_EntryGetFailedCycleCount(CopyDidInfoPtr->Entry);
    lReturnValue = TRUE;
  }

  return lReturnValue;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_FAILED_CYCLES == STD_ON) */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyConsecutiveFailedCycles
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyConsecutiveFailedCycles(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  boolean lReturnValue;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

# if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
  if (FALSE != DEM_MEM_TEST_AGING_ONLY(Dem_Mem_EntryGetState(CopyDidInfoPtr->Entry)))
  {
    lReturnValue = FALSE;
  }
  else
# endif
  {
    CopyDidInfoPtr->DestinationBuffer[0] = Dem_Mem_EntryGetConsecutiveFailedCycleCount(CopyDidInfoPtr->Entry);
    lReturnValue = TRUE;
  }

  return lReturnValue;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON) */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyCyclesTestedSinceFirstFailed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCyclesTestedSinceFirstFailed(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  boolean lReturnValue;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->Entry != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

# if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
  if (FALSE != DEM_MEM_TEST_AGING_ONLY(Dem_Mem_EntryGetState(CopyDidInfoPtr->Entry)))
  {
    lReturnValue = FALSE;
  }
  else
# endif
  {
    CopyDidInfoPtr->DestinationBuffer[0] = Dem_Mem_EntryGetTestedSinceFirstFailedCycleCount(CopyDidInfoPtr->Entry);
    lReturnValue = TRUE;
  }

  return lReturnValue;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON) */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_ROOTCAUSE_EVENTID == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyRootCauseEventId
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyRootCauseEventId(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->SourceBuffer != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

  CopyDidInfoPtr->DestinationBuffer[0] = CopyDidInfoPtr->SourceBuffer[0];
  CopyDidInfoPtr->DestinationBuffer[1] = CopyDidInfoPtr->SourceBuffer[1];
  CopyDidInfoPtr->SourceBuffer = &CopyDidInfoPtr->SourceBuffer[2];

  return TRUE;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_ROOTCAUSE_EVENTID == STD_ON) */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_OBDDTC == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyEventObdDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyEventObdDtc(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

# if (DEM_CFG_SUPPORT_OBDII == STD_ON)
  CopyDidInfoPtr->DestinationBuffer[0] = Dem_GetHiByte(Dem_Cfg_EventObdDtc(CopyDidInfoPtr->EventId));
  CopyDidInfoPtr->DestinationBuffer[1] = Dem_GetLoByte(Dem_Cfg_EventObdDtc(CopyDidInfoPtr->EventId));
# else
  CopyDidInfoPtr->DestinationBuffer[0] = 0x00U;
  CopyDidInfoPtr->DestinationBuffer[1] = 0x00U;
# endif

  return TRUE;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_OBDDTC == STD_ON) */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_OBDDTC_3BYTE == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyEventObdDtc_3Byte
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyEventObdDtc_3Byte(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

# if (DEM_CFG_SUPPORT_OBDII == STD_ON)
  CopyDidInfoPtr->DestinationBuffer[0] = Dem_GetHiByte(Dem_Cfg_EventObdDtc(CopyDidInfoPtr->EventId));
  CopyDidInfoPtr->DestinationBuffer[1] = Dem_GetLoByte(Dem_Cfg_EventObdDtc(CopyDidInfoPtr->EventId));
  CopyDidInfoPtr->DestinationBuffer[2] = 0x00;
# else
  CopyDidInfoPtr->DestinationBuffer[0] = 0x00U;
  CopyDidInfoPtr->DestinationBuffer[1] = 0x00U;
  CopyDidInfoPtr->DestinationBuffer[2] = 0x00U;
# endif

  return TRUE;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_OBDDTC == STD_ON) */

#if ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_CURRENT_FDC == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyCurrentFdc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(boolean, DEM_CODE)
Dem_Data_CopyCurrentFdc(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr
  )
{
  boolean lReturnValue;
  sint8 lFdc;

  Dem_Internal_AssertReturnValue(CopyDidInfoPtr->EventId != DEM_EVENT_INVALID, DEM_E_INCONSISTENT_STATE, FALSE)

  lReturnValue = (boolean)(E_OK == Dem_Util_DtcGetFaultDetectionCounter(CopyDidInfoPtr->EventId, &lFdc));
  if (FALSE != lReturnValue)
  {
    CopyDidInfoPtr->DestinationBuffer[0] = (uint8)lFdc;
  }

  return lReturnValue;
}
#endif /* ((DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)) && (DEM_CFG_DATA_CURRENT_FDC == STD_ON) */

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 % Dem_Nvm_CommitBlock
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_CommitBlock(
  void
  )
{
  Std_ReturnType lNvmResult;
  uint16_least lBufferSize;

  if (Dem_Nvm_CommitData.MemoryIndex == Dem_Cfg_MemoryAdminIndex())
  {
    lBufferSize = sizeof(Dem_Cfg_AdminDataType);
  }
  else
  if (Dem_Nvm_CommitData.MemoryIndex == Dem_Cfg_MemoryStatusIndex())
  {
    lBufferSize = sizeof(Dem_Cfg_StatusDataType);
  }
  else
#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
  if (Dem_Nvm_CommitData.MemoryIndex == Dem_Cfg_MemoryDebounceIndex())
  {
    lBufferSize = sizeof(Dem_Cfg_DebounceDataType);
  }
  else
#endif
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
  if (Dem_Nvm_CommitData.MemoryIndex == Dem_Cfg_MemoryEventAvailableIndex())
  {
    lBufferSize = sizeof(Dem_Cfg_EventAvailableDataType);
  }
  else
#endif
  {
    lBufferSize = sizeof(Dem_Cfg_PrimaryEntryType);
  }

#if (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON)
  Dem_Nvm_CommitData.BlockIsCleared = (boolean)(0 != (DEM_NVM_BLOCKSTATE_CLEARFLAG & Dem_Nvm_GetBlockState(Dem_Nvm_CommitData.MemoryIndex)));
#endif
  if (Dem_Nvm_CommitData.MemoryIndex == Dem_Cfg_MemoryAdminIndex())
  {
    Dem_Nvm_SetBlockState(Dem_Nvm_CommitData.MemoryIndex, DEM_NVM_BLOCKSTATE_DIRTY);
  }
  else
  {
    Dem_Nvm_SetBlockState(Dem_Nvm_CommitData.MemoryIndex, DEM_NVM_BLOCKSTATE_UNMODIFIED);
  }

  Dem_MemCpy((Dem_DataPtrType)&Dem_Cfg_CommitBuffer.mRaw[0],                                                                     /* PRQA S 0602 */ /* MD_DEM_20.2 */
             Dem_Cfg_MemoryDataPtr[Dem_Nvm_CommitData.MemoryIndex],
             lBufferSize);

  /* Job End notification might return immediately - set the commit state before WriteBlock */
  Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_WRITING;
  lNvmResult = NvM_WriteBlock(Dem_Nvm_GetBlockId(Dem_Nvm_CommitData.MemoryIndex), &Dem_Cfg_CommitBuffer.mRaw[0]);

  if (lNvmResult != E_OK)
  { /* Write attempt failed - act as if callback had returned failed. This case is handled by Dem_NvM_MainFunction */
    Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_FAILED;
  }
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON) */

#if (DEM_CFG_USE_NVM == STD_ON)
/* ****************************************************************************
 % Dem_Nvm_Init
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_Init(
  void
  )
{
  Dem_MemSet(Dem_Cfg_MemoryStatus, DEM_NVM_BLOCKSTATE_UNMODIFIED, Dem_Cfg_GlobalNvBlockCount()*sizeof(uint8));                   /* PRQA S 0602, 3109 */ /* MD_DEM_20.2, MD_MSR_14.3 */
  Dem_Mem_AdminSetBlockState(DEM_NVM_BLOCKSTATE_DIRTY);

# if (DEM_CFG_SUPPORT_NVM_APPL_SYNCHRONIZE == STD_ON)
  Dem_Nvm_SynchronizationRequest = FALSE;
# endif
# if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
  Dem_Nvm_PendingStatusBlockState = DEM_NVM_BLOCKSTATE_UNMODIFIED;
#  if (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
  Dem_Nvm_PendingEventAvailabilityBlockState = DEM_NVM_BLOCKSTATE_UNMODIFIED;
#  endif
  Dem_Nvm_CommitData.MemoryIndex = 0;
  Dem_Nvm_CommitData.PendingCount = 0;
  Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_IDLE;
# endif
# if (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON)
  Dem_Nvm_CommitData.PendingClearCount = 0;
  Dem_Nvm_CommitData.BlockIsCleared = FALSE;
# endif
}
#endif /* (DEM_CFG_USE_NVM == STD_ON) */

#if (DEM_CFG_USE_NVM == STD_ON)
/* ****************************************************************************
 % Dem_Nvm_Shutdown
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_Shutdown(
  void
  )
{
  Dem_Cfg_MemoryIndexType lMemoryIndex;

# if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
  /* Process queued modification status of the status data block */
  if (Dem_Nvm_PendingStatusBlockState != DEM_NVM_BLOCKSTATE_UNMODIFIED)
  {
    Dem_Nvm_StatusSetBlockState(Dem_Nvm_PendingStatusBlockState);
    Dem_Nvm_PendingStatusBlockState = DEM_NVM_BLOCKSTATE_UNMODIFIED;
  }
# if (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
  /* Process queued modification status of the status data block */
  if (Dem_Nvm_PendingEventAvailabilityBlockState  != DEM_NVM_BLOCKSTATE_UNMODIFIED)
  {
    Dem_Nvm_EventAvailableSetBlockState(Dem_Nvm_PendingEventAvailabilityBlockState);
    Dem_Nvm_PendingEventAvailabilityBlockState = DEM_NVM_BLOCKSTATE_UNMODIFIED;
  }
# endif
# endif

  for (lMemoryIndex = 0; lMemoryIndex < Dem_Cfg_GlobalNvBlockCount(); ++lMemoryIndex)
  {
    if (DEM_NVM_BLOCKSTATE_UNMODIFIED != Dem_Nvm_GetBlockState(lMemoryIndex))
    {
      (void)NvM_SetRamBlockStatus((NvM_BlockIdType)Dem_Cfg_MemoryBlockId[lMemoryIndex], TRUE);
    }
  }

# if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
  Dem_Nvm_CommitData.MemoryIndex = 0;
  Dem_Nvm_CommitData.PendingCount = 0;
  Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_IDLE;
# endif
# if (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON)
  Dem_Nvm_CommitData.PendingClearCount = 0;
  Dem_Nvm_CommitData.BlockIsCleared = FALSE;
# endif
}                                                                                                                                /* PRQA S 6010 */ /* MD_MSR_STPTH */
#endif /* (DEM_CFG_USE_NVM == STD_ON) */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 % Dem_Nvm_ProcessQueue
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_ProcessQueue(
  void
  )
{
  /* Process queued modification status of the status data block */
  if (Dem_Nvm_PendingStatusBlockState != DEM_NVM_BLOCKSTATE_UNMODIFIED)
  {
    Dem_Nvm_SetBlockStateImmediate(Dem_Cfg_MemoryStatusIndex(), Dem_Nvm_PendingStatusBlockState);
    Dem_Nvm_PendingStatusBlockState = DEM_NVM_BLOCKSTATE_UNMODIFIED;
  }
  /* Process queued modification status of the status data block */
# if (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
  if (Dem_Nvm_PendingEventAvailabilityBlockState != DEM_NVM_BLOCKSTATE_UNMODIFIED)
  {
    Dem_Nvm_SetBlockStateImmediate(Dem_Cfg_MemoryEventAvailableIndex(), Dem_Nvm_PendingEventAvailabilityBlockState);
    Dem_Nvm_PendingEventAvailabilityBlockState = DEM_NVM_BLOCKSTATE_UNMODIFIED;
  }
#endif

#if (DEM_CFG_SUPPORT_NVM_APPL_SYNCHRONIZE == STD_ON)
  /* Process queued request for full NV sync */
  if (FALSE != Dem_Nvm_SynchronizationRequest)
  {
    Dem_Cfg_MemoryIndexType lMemoryIndex;
    for (lMemoryIndex = 0; lMemoryIndex < Dem_Cfg_GlobalNvBlockCount(); ++lMemoryIndex)
    {
      if (DEM_NVM_BLOCKSTATE_DIRTY == ((DEM_NVM_BLOCKSTATE_IMMEDIATEFLAG | DEM_NVM_BLOCKSTATE_DIRTY) & Dem_Nvm_GetBlockState(lMemoryIndex)))
      {
        Dem_Nvm_SetBlockStateImmediate(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTYIMMEDIATE);
      }
    }

    Dem_Nvm_SynchronizationRequest = FALSE;
  }
#endif
}
#endif

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON) && (DEM_CFG_SUPPORT_NVM_POLLING == STD_ON )
/* ****************************************************************************
 % Dem_Nvm_GetNvMResult
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_GetNvMResult(
  void
  )
{
  if (Dem_Nvm_CommitData.WriteState == DEM_NVM_COMMIT_WRITING)
  {
    NvM_RequestResultType lRequestResult;
    Std_ReturnType lCallResult;

    lRequestResult = NVM_REQ_NOT_OK;

    lCallResult = NvM_GetErrorStatus(Dem_Nvm_GetBlockId(Dem_Nvm_CommitData.MemoryIndex), &lRequestResult);
    if (lCallResult == E_OK)
    {
      if (lRequestResult != NVM_REQ_PENDING)
      {
        if (lRequestResult != NVM_REQ_OK)
        { /* Write request aborted or otherwise failed. */
          Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_FAILED;
        }
        else
        {
          /* continue with next block */
          Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_FINISHED;
        }
      }
      /* else: NvM is still busy, wait */
    }
    else
    {
      Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_FAILED;
    }
  }
}
#endif

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 % Dem_Nvm_MainFunction
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Nvm_MainFunction(
  void
  )
{
  Dem_Nvm_ProcessQueue();

  /* Check for ongoing NV commit */
  if (Dem_Nvm_CommitData.PendingCount > 0)
  {
# if (DEM_CFG_SUPPORT_NVM_POLLING == STD_ON )
    Dem_Nvm_GetNvMResult();
# endif /* (DEM_CFG_SUPPORT_NVM_POLLING == STD_ON ) */

    switch (Dem_Nvm_CommitData.WriteState)
    {
    case DEM_NVM_COMMIT_FAILED:
    {
      /* Error handling:
         This implementation will mark the block as dirty in case of failed
         NvM_WriteBlock. Another immediate update is done only if the block
         changes again */
      (void)NvM_SetRamBlockStatus(Dem_Nvm_GetBlockId(Dem_Nvm_CommitData.MemoryIndex), TRUE);
# if (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON)
      if (FALSE != Dem_Nvm_CommitData.BlockIsCleared)
      { /* Note: on failure, PendingClearCount must be decremented after setting
           the failure bit to prevent an observable gap where the clear operation
           seems to have completed without error */
        uint8 lClearState;
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DcmApi */
        Dem_EnterCritical_DcmApi();                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
        lClearState = Dem_Queue_GetClearState();
        lClearState = DEM_QUEUE_SETCLEARSTATE_NVFAILED(lClearState);
        Dem_Queue_SetClearState(lClearState);
        Dem_LeaveCritical_DcmApi();                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DcmApi */
      }
# endif
    }
    /* FALL THROUGH */

    case DEM_NVM_COMMIT_FINISHED:                                                                                                /* PRQA S 2003 */ /* MD_DEM_15.2 */
    {
      /* Post-processing of NV update */
      Dem_Nvm_CommitData.PendingCount = (uint8)(Dem_Nvm_CommitData.PendingCount - 1);
# if (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON)
      if (FALSE != Dem_Nvm_CommitData.BlockIsCleared)
      {
        Dem_Nvm_CommitData.BlockIsCleared = FALSE;
        Dem_Nvm_CommitData.PendingClearCount = (uint8)(Dem_Nvm_CommitData.PendingClearCount - 1);
      }
# endif
    }
    /* FALL THROUGH */

    case DEM_NVM_COMMIT_IDLE:                                                                                                    /* PRQA S 2003 */ /* MD_DEM_15.2 */
    {
      /* Look for next dirty/immediate NV block */
      if (Dem_Nvm_CommitData.PendingCount > 0)
      {
        /* Event states first, they are bound to be modified quickly */
        if (0 != (DEM_NVM_BLOCKSTATE_IMMEDIATEFLAG & Dem_Nvm_StatusGetBlockState()))
        {
          Dem_Nvm_CommitData.MemoryIndex = Dem_Cfg_MemoryStatusIndex();
        }
        else
        {
          /* Start at last inspected index to write blocks fairly */
          uint8 lEndIndex;
          boolean lFoundBlock;

          lEndIndex = Dem_Nvm_CommitData.MemoryIndex;
          lFoundBlock = FALSE;
          do
          {
            Dem_WrappingIncrement(Dem_Nvm_CommitData.MemoryIndex, Dem_Cfg_GlobalNvBlockCount())                                  /* PRQA S 0715 */ /* MD_MSR_1.1_715 */

            if (0 != (DEM_NVM_BLOCKSTATE_IMMEDIATEFLAG & Dem_Nvm_GetBlockState(Dem_Nvm_CommitData.MemoryIndex)))
            { /* Found a block that needs to be committed */                                                                     /* PRQA S 0715 */ /* MD_MSR_1.1_715 */
              lFoundBlock = TRUE;
              break;
            }
          }
          while (Dem_Nvm_CommitData.MemoryIndex != lEndIndex);   /* Stop when all slots have been inspected */

          if (lFoundBlock == FALSE)
          {
            Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_IDLE;
            break; /* We will continue looking for the pending block in the next task */                                         /* PRQA S 3333 */ /* MD_DEM_14.6_opt */
          }
        }

        Dem_Nvm_CommitBlock();
      }
      else
      {
        Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_IDLE;
      }
    }
    break;

    default: break;
      /* DEM_NVM_COMMIT_WRITING - NvM is still busy, do nothing until this changes (no timeout) */
    } /* end switch */
  } /* end if (Dem_Nvm_CommitData.PendingCount > 0) */
}                                                                                                                                /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
#endif /* (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON) */

                                                            /* DCM Interface */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Dcm_Init
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Dcm_Init(
  void
  )
{
#if (DEM_CFG_SUPPORT_DCM == STD_ON) || (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
  Dem_Dcm_Cache[0].Dtc = DEM_CFG_DTC_UDS_INVALID;
  Dem_Dcm_Cache[0].EventId = DEM_EVENT_INVALID;
  Dem_Dcm_Cache[0].MemoryId = DEM_CFG_MEMORYID_PRIMARY;
  Dem_Dcm_Cache[1].Dtc = DEM_CFG_DTC_UDS_INVALID;
  Dem_Dcm_Cache[1].EventId = DEM_EVENT_INVALID;
  Dem_Dcm_Cache[1].MemoryId = DEM_CFG_MEMORYID_PRIMARY;
#endif
#if (DEM_CFG_SUPPORT_DCM == STD_ON)
  Dem_Dcm_FilterResetCancelled();
  Dem_Dcm_FilterDtcSetFunctionPtr(NULL_PTR);
  Dem_Dcm_FilterDataSetState(DEM_DCM_FILTERDATA_IDLE);
  Dem_Dcm_FilterDataSetEventId(DEM_EVENT_INVALID);
#endif
}

#if (DEM_CFG_SUPPORT_DCM == STD_ON) || (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_FindEventFromUdsDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FindEventFromUdsDtc(
  uint32  UdsDtc,
  uint8  MemoryId,
  uint8  ClientId
  )
{
  Dem_EventIdType lEventId;

  if (DEM_CFG_DTC_UDS_INVALID == UdsDtc)
  {
    lEventId = DEM_EVENT_INVALID;
  }
  else
  {
    Dem_Dcm_CacheType lCache;

    for (;;)
    {
      if (Dem_Dcm_Cache[ClientId].Dtc != UdsDtc)
      {
        lCache.Dtc = UdsDtc;
        lCache.MemoryId = MemoryId;
        lCache.EventId = Dem_Cfg_FindEventFromUdsDtc(UdsDtc, MemoryId);
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
        if (DEM_EVENT_INVALID != lCache.EventId)
        {
          lCache.EventId = Dem_Util_DtcGetMasterEvent(lCache.EventId);
        }
# endif
        if (lCache.EventId != DEM_EVENT_INVALID)
        {
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DcmApi */
          Dem_EnterCritical_DcmApi();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
          Dem_Dcm_Cache[ClientId] = lCache;
          Dem_LeaveCritical_DcmApi();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DcmApi */
        }

        lEventId = lCache.EventId;
        break;
      }
      else
      {
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DcmApi */
        Dem_EnterCritical_DcmApi();                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
        lCache = Dem_Dcm_Cache[ClientId];
        Dem_LeaveCritical_DcmApi();                                                                                              /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DcmApi */
        if (lCache.Dtc == UdsDtc)
        {
          if (lCache.MemoryId == MemoryId)
          {
            lEventId = lCache.EventId;
          }
          else
          {
            /* #010 Since DTCs are unique across memories, a request for a different
               memory fails even if the DTCs exists */
            lEventId = DEM_EVENT_INVALID;
          }
          break;                                                                                                                 /* PRQA S 0771 */ /* MD_DEM_14.6_opt */
        }
        /* else: concurrent modification has invalidated the cache - repeat */
      }
    }
  }

  return lEventId;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) || (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON) */

#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_CopyDidFromSRec
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Dcm_CopyDidFromSRec(
  Dem_EventIdType  EventId,
  uint8  RecordNumber,
  boolean  ReportTotalRecord,
  uint16  DataId,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer
)
{
  Std_ReturnType lReturnValue;
  uint8 lSRecIndex;

  lReturnValue = E_OK;
  lSRecIndex = 0;

  /* Test for valid RecordNumber */
  if (RecordNumber != 0xff)
  {
    Dem_Cfg_EventSRecIterType lRecordIter;

    for (Dem_Cfg_EventSRecIterInit(EventId, &lRecordIter);                                                                       /* PRQA S 3198, 3418 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
         FALSE != Dem_Cfg_EventSRecIterExists(EventId, &lRecordIter);
         Dem_Cfg_EventSRecIterNext(EventId, &lRecordIter))
    {
      Dem_Cfg_SRecIndexType lCfgSRecIndex;
      lCfgSRecIndex = Dem_Cfg_EventSRecIterGet(EventId, &lRecordIter);
      if (RecordNumber == Dem_Cfg_SRecId(lCfgSRecIndex))
      {
        break;
      }
      else
      {
        ++lSRecIndex;
      }
    }
    if (FALSE == Dem_Cfg_EventSRecIterExists(EventId, &lRecordIter))
    {
      lReturnValue = DEM_E_WRONG_RECORDNUMBER;
    }
  }
# if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
  else
  {
    lReturnValue = DEM_E_WRONG_RECORDNUMBER;
  }
# endif

  if (lReturnValue == E_OK)
  {
    DEM_MEM_MEMORYINFO_PARAM_VARDEF
    Dem_Cfg_MemoryIndexType lMemoryIndex;
    boolean lModificationDetected;

    DEM_MEM_MEMORYINFO_PARAM_INIT(Dem_Cfg_EventDestination(EventId))

    do
    {
      lModificationDetected = FALSE;
      lMemoryIndex = Dem_Mem_MemoryFindIndex(EventId);

      if (lMemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX)
      { /* The record currently exists, but without critical section it could age or displace */
        uint8 lUpdateState;
        Dem_Data_CopyDidInfoType lCopyDidInfo;

        lUpdateState = Dem_Mem_MemoryUpdateGetState(lMemoryIndex);

        if (FALSE == Dem_Mem_UpdateTestInProgress(lUpdateState))
        { /* This call does not currently interrupt a concurrent data update */
          Dem_Mem_EntryPtrType lEntry;
          lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);                                                                         /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */

# if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
          if (RecordNumber == 0xffU)
          {
            lSRecIndex = (uint8)(lEntry->SnapshotHeader - 1);
          }
# endif
          if (FALSE != Dem_Data_SRecIsStored(lEntry, lSRecIndex))
          {
            Dem_Cfg_EventDidIterType lDidIter;

            Dem_Cfg_EventDidIterInit(EventId, &lDidIter);                                                                        /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
            lCopyDidInfo.DestinationBuffer = &DestBuffer[0];
            lCopyDidInfo.SourceBuffer      = (Dem_ConstSharedDataPtrType)&lEntry->SnapshotData[lSRecIndex][0];
            lCopyDidInfo.Entry             = lEntry;
            lCopyDidInfo.EventId           = EventId;

            lReturnValue = DEM_E_WRONG_DIDNUMBER;

            while (FALSE != Dem_Cfg_EventDidIterExists(EventId, &lDidIter))
            {
              Dem_Cfg_DidIndexType lDidIndex;
              lDidIndex = Dem_Cfg_EventDidIterGet(EventId, &lDidIter);
              Dem_Cfg_EventDidIterNext(EventId, &lDidIter);

              if ( (Dem_Cfg_DidNumber(lDidIndex) == DataId)
                || (FALSE != ReportTotalRecord) )
              { /* Add the DID related data to the destination buffer */
                (void)Dem_Data_CopyDid(&lCopyDidInfo, lDidIndex);
                lReturnValue = E_OK;

                if (FALSE == ReportTotalRecord)
                {                                                                                                                /* PRQA S 0715 */ /* MD_MSR_1.1_715 */
                  /* BEWARE: loop aborted here */
                  break;
                }
              }
              else
              { /* not the requested DID */
                Dem_Data_SkipDid(&lCopyDidInfo, lDidIndex);
              }
            }
            if ( (lReturnValue == E_OK)
              && (lUpdateState != Dem_Mem_MemoryUpdateGetState(lMemoryIndex)) )
            { /* The memory entry has been modified while trying to copy the stored data. */
              /* We cannot be sure it is still used by the same event, so start from the
                  beginning */
              lModificationDetected = TRUE;
            }
          }
          else
          {
            /* The requested data is currently not stored in the event memory */
            lReturnValue = DEM_E_NODATAAVAILABLE;
          }
        }
        else
        {
          /* The caller task has higher priority than Dem_MainFunction, but we cannot 'wait' for
             the update to complete. The requested data is not available at this moment. */
          lReturnValue = E_NOT_OK;
        }
      }
      else
      {
        /* The requested event is currently not stored in the event memory */
        lReturnValue = DEM_E_NODATAAVAILABLE;
      }
    }
    while (FALSE != lModificationDetected);
  }
  return lReturnValue;
}                                                                                                                                /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) */

#if (DEM_CFG_SUPPORT_ERECS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_CopyERecs
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Dcm_CopyERecs(
  Dem_EventIdType  EventId,
  uint8  RecordNumber,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer
)
{
  Std_ReturnType lReturnValue;
  Dem_Cfg_EventERecIterType lRecordIter;
  Dem_Data_CopyDidInfoType  lCopyDidInfo;
  Dem_Cfg_ERecIndexType lCfgERecIndex;
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
  uint8 lERecStoredIndex;
# endif

  Dem_Cfg_EventERecIterInit(EventId, &lRecordIter);                                                                              /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */

  lCopyDidInfo.DestinationBuffer = &DestBuffer[0];
  lCopyDidInfo.EventId = EventId;

  lCfgERecIndex = 0;
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
  lERecStoredIndex = 0;
# endif

  /* Find the requested record, and it's storage location */
  for (;
       FALSE != Dem_Cfg_EventERecIterExists(EventId, &lRecordIter);
       Dem_Cfg_EventERecIterNext(EventId, &lRecordIter))
  {
    lCfgERecIndex = Dem_Cfg_EventERecIterGet(EventId, &lRecordIter);

    if (RecordNumber == Dem_Cfg_DidNumber(Dem_Cfg_ERecDid(lCfgERecIndex)))
    {
      break;
    }
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
    else
    {
      if (DEM_CFG_EREC_TYPE_USER == Dem_Cfg_ERecType(lCfgERecIndex))
      {
        ++lERecStoredIndex;
      }
    }
# endif
  }

  if (FALSE != Dem_Cfg_EventERecIterExists(EventId, &lRecordIter))
  { /* Found the record, retrieve it from its storage */
    uint8 lRecordType;

    lRecordType = Dem_Cfg_ERecType(lCfgERecIndex);
    if (DEM_CFG_EREC_TYPE_GLOBAL != lRecordType)
    { /* A stored record needs to be rtrieved from event memory */
      DEM_MEM_MEMORYINFO_PARAM_VARDEF
      Dem_Cfg_MemoryIndexType lMemoryIndex;
      boolean lModificationDetected;

      DEM_MEM_MEMORYINFO_PARAM_INIT(Dem_Cfg_EventDestination(EventId))

      do
      {
        lModificationDetected = FALSE;

        lMemoryIndex = Dem_Mem_MemoryFindIndex(EventId);

        if (lMemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX)
        { /* The record currently exists, but without critical section it could age or displace */
          uint8 lUpdateState;
          lUpdateState = Dem_Mem_MemoryUpdateGetState(lMemoryIndex);

          if (FALSE == Dem_Mem_UpdateTestInProgress(lUpdateState))
          { /* This call does not currently interrupt a concurrent data update */
            lCopyDidInfo.Entry = Dem_Mem_MemoryGetEntry(lMemoryIndex);                                                           /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */

# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
            /* Supported record, test if it is currently stored */
            if ( (DEM_CFG_EREC_TYPE_USER == lRecordType)                                                                         /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
              && (FALSE == Dem_Data_ERecIsStored(lCopyDidInfo.Entry, lERecStoredIndex)) )                                        /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
            { /* The DTC has an event entry, but the requested record was not yet stored */
              lReturnValue = DEM_E_NODATAAVAILABLE;
            }
            else
# endif
            {
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
              lCopyDidInfo.SourceBuffer = (Dem_ConstSharedDataPtrType)&lCopyDidInfo.Entry->ExtendedData[lERecStoredIndex][0];
# else
              lCopyDidInfo.SourceBuffer = (Dem_ConstSharedDataPtrType)NULL_PTR;
# endif
              if (FALSE != Dem_Data_CopyDid(&lCopyDidInfo, Dem_Cfg_ERecDid(lCfgERecIndex)))
              {
                lReturnValue = E_OK;
              }
              else
              {
                lReturnValue = DEM_E_NODATAAVAILABLE;
              }
            }

            if (lUpdateState != Dem_Mem_MemoryUpdateGetState(lMemoryIndex))
            { /* The memory entry has been modified while trying to copy the stored data. */
              /* We cannot be sure it is still used by the same event, so start from the
                 beginning */
              lModificationDetected = TRUE;
            }
          }
          else
          { /* The caller task has higher priority than Dem_MainFunction, but we cannot 'wait' for
               the update to complete. The requested data is not available at this moment. */
            lReturnValue = E_NOT_OK;
          }
        }
        else
        { /* The requested data is currently not stored in the event memory */
          lReturnValue = DEM_E_NODATAAVAILABLE;
        }
      }
      while (FALSE != lModificationDetected);
    }
    else
    { /* Statistic records always need to collect current data - if possible depending on event state */
      lCopyDidInfo.SourceBuffer = (Dem_ConstSharedDataPtrType)NULL_PTR;
      lCopyDidInfo.Entry        = (Dem_SharedMemoryEntryPtrType)NULL_PTR;

      /* Ignore return value, global statistics never fail the call. */
      (void)Dem_Data_CopyDid(&lCopyDidInfo, Dem_Cfg_ERecDid(lCfgERecIndex));
      lReturnValue = E_OK;
    }
  }
  else
  {
    lReturnValue = DEM_E_WRONG_RECORDNUMBER;
  }
  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_ERECS == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_CopySRec
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_ReturnGetFreezeFrameDataByDTCType, DEM_CODE)
Dem_Dcm_CopySRec(
  Dem_EventIdType  EventId,
  uint8  RecordNumber,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  BufSize
)
{
  Dem_ReturnGetFreezeFrameDataByDTCType lReturnValue;
  Dem_Cfg_EventSRecIterType lRecordIter;
  uint8 lSRecIndex;

  lReturnValue = DEM_GET_FFDATABYDTC_OK;
  Dem_Cfg_EventSRecIterInit(EventId, &lRecordIter);                                                                              /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
  lSRecIndex = 0;

  while ( (FALSE != Dem_Cfg_EventSRecIterExists(EventId, &lRecordIter))
# if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
       && (DEM_GET_FFDATABYDTC_OK == lReturnValue)
# endif
        )
  {
    Dem_Cfg_SRecIndexType lCfgSRecIndex;
    lCfgSRecIndex = Dem_Cfg_EventSRecIterGet(EventId, &lRecordIter);

# if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
    if (RecordNumber < Dem_Cfg_SRecId(lCfgSRecIndex))
    { /* overshoot -> snapshot not supported */
      lReturnValue = DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER;
    }
    else
# endif
    if (RecordNumber == Dem_Cfg_SRecId(lCfgSRecIndex))
    {
      if (Dem_Cfg_EventSRecUdsSize(EventId) > *BufSize)
      { /* supported record, but the buffer is not large enough for all the data */
        lReturnValue = DEM_GET_FFDATABYDTC_WRONG_BUFFERSIZE;
      }
      else
      {
        lReturnValue = DEM_GET_FFDATABYDTC_OK;
        if (FALSE != Dem_Data_SRecIsStored(&Dem_Cfg_ReadoutBuffer, lSRecIndex))
        {
          DestBuffer[0] = RecordNumber;
          Dem_Data_SRecCopyData(&DestBuffer[1], lSRecIndex);
          *BufSize = Dem_Cfg_EventSRecUdsSize(EventId);
        }
        else
        {
          *BufSize = 0;
        }
      }
      break;
    }
    else
    { /* next snapshot record */ }

    Dem_Cfg_EventSRecIterNext(EventId, &lRecordIter);
    ++lSRecIndex;
  }
  if (FALSE == Dem_Cfg_EventSRecIterExists(EventId, &lRecordIter))
  {
    lReturnValue = DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER;
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && ((DEM_CFG_SUPPORT_SRECS == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_OBDII == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_WWHOBD == STD_ON))
/* ****************************************************************************
 % Dem_Dcm_GetSizeOfSRec
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_ReturnGetSizeOfDataByDTCType, DEM_CODE)
Dem_Dcm_GetSizeOfSRec(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  uint8  RecordNumber,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  SizeOfFreezeFrame                                                                     /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_False */
)
{
  Dem_ReturnGetSizeOfDataByDTCType lReturnValue;

  if (RecordNumber == 0xffU)
  { /* No data is a positive result for 0xff */
# if (DEM_CFG_SUPPORT_SRECS == STD_ON)
    lReturnValue = DEM_GETSIZEBYDTC_OK;
    *SizeOfFreezeFrame = (uint16)(Dem_Data_SRecCount(&Dem_Cfg_ReadoutBuffer) * Dem_Cfg_EventSRecUdsSize(EventId));
# else
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_RECNUM;
    /* SizeOfFreezeFrame intentionally not modified due to invalid request */
# endif
  }
  else
# if (DEM_CFG_SUPPORT_SRECS == STD_ON)
  { /* Specific record not found is a negative result */
    Dem_Cfg_EventSRecIterType lRecordIter;
    uint8 lSRecIndex;

    Dem_Cfg_EventSRecIterInit(EventId, &lRecordIter);                                                                            /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
    lSRecIndex = 0;
    lReturnValue = DEM_GETSIZEBYDTC_OK;

    while ( (FALSE != Dem_Cfg_EventSRecIterExists(EventId, &lRecordIter))
#  if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
              && (DEM_GETSIZEBYDTC_OK == lReturnValue)
#  endif
          )
    {
      Dem_Cfg_SRecIndexType lCfgSRecIndex;
      lCfgSRecIndex = Dem_Cfg_EventSRecIterGet(EventId, &lRecordIter);

#  if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
      if (RecordNumber < Dem_Cfg_SRecId(lCfgSRecIndex))
      { /* overshoot -> snapshot not supported */
        lReturnValue = DEM_GETSIZEBYDTC_WRONG_RECNUM;
      }
      else
#  endif
      if (RecordNumber == Dem_Cfg_SRecId(lCfgSRecIndex))
      {
        lReturnValue = DEM_GETSIZEBYDTC_OK;
        if (FALSE != Dem_Data_SRecIsStored(&Dem_Cfg_ReadoutBuffer, lSRecIndex))
        {
          *SizeOfFreezeFrame = Dem_Cfg_EventSRecUdsSize(EventId);
        }
        else
        {
          *SizeOfFreezeFrame = 0;
        }
        break;
      }
      else
      {
        /* next snapshot record */
      }

      Dem_Cfg_EventSRecIterNext(EventId, &lRecordIter);
      ++lSRecIndex;
    }

    if (FALSE == Dem_Cfg_EventSRecIterExists(EventId, &lRecordIter))
    {
      lReturnValue = DEM_GETSIZEBYDTC_WRONG_RECNUM;
    }
  }
# else
  {
    DEM_IGNORE_UNUSED_ARGUMENT(SizeOfFreezeFrame)                                                                                /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(EventId)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_RECNUM;
  }
# endif
  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SRECS == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_ERECS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_CopyERec
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_ReturnGetExtendedDataRecordByDTCType , DEM_CODE)
Dem_Dcm_CopyERec(
  Dem_EventIdType  EventId,
  uint8  RecordNumber,
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  BufSize
)
{
  Dem_ReturnGetExtendedDataRecordByDTCType lReturnValue;
  Dem_Cfg_EventERecIterType lRecordIter;
  Dem_Data_CopyDidInfoType lCopyDidInfo;
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
  uint8 lERecStoredIndex;
# endif

  lReturnValue = DEM_RECORD_WRONG_NUMBER;
  Dem_Cfg_EventERecIterInit(EventId, &lRecordIter);                                                                              /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
  lCopyDidInfo.DestinationBuffer = &DestBuffer[0];
  lCopyDidInfo.EventId  = EventId;
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
  lERecStoredIndex = 0;
# endif

  /* Find the Record number */
  while (FALSE != Dem_Cfg_EventERecIterExists(EventId, &lRecordIter))
  {
    Dem_Cfg_ERecIndexType lCfgERecIndex;

    lCfgERecIndex = Dem_Cfg_EventERecIterGet(lEventId, &lRecordIter);
    Dem_Cfg_EventERecIterNext(lEventId, &lRecordIter);

    if (RecordNumber == Dem_Cfg_DidNumber(Dem_Cfg_ERecDid(lCfgERecIndex)))
    {
      uint8 lERecType = Dem_Cfg_ERecType(lCfgERecIndex);

      if (DEM_CFG_EREC_TYPE_GLOBAL != lERecType)
      { /* Supported record, test if it is stored - if no entry was found, the stored mask is cleared as well! */
        if ( (DEM_EVENT_INVALID != Dem_Cfg_ReadoutBuffer.EventId)                                                                /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
          && ( (DEM_CFG_EREC_TYPE_INTERNAL == lERecType)                                                                         /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
            || (FALSE != Dem_Data_ERecIsStored(&Dem_Cfg_ReadoutBuffer, lERecStoredIndex)) )                                      /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
# endif
          )
        { /* Check buffer size after storage state - the buffer needs not be large enough for an empty response */
          if (Dem_Cfg_DidSize(Dem_Cfg_ERecDid(lCfgERecIndex)) > *BufSize)
          {
            lReturnValue = DEM_RECORD_WRONG_BUFFERSIZE;
          }
          else
          {
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
            lCopyDidInfo.SourceBuffer = (Dem_ConstSharedDataPtrType)&Dem_Cfg_ReadoutBuffer.ExtendedData[lERecStoredIndex][0];
# else
            lCopyDidInfo.SourceBuffer = (Dem_ConstSharedDataPtrType)NULL_PTR;
# endif
            lCopyDidInfo.Entry = (Dem_SharedMemoryEntryPtrType)&Dem_Cfg_ReadoutBuffer;

            if (FALSE != Dem_Data_CopyDid(&lCopyDidInfo, Dem_Cfg_ERecDid(lCfgERecIndex)))
            {
              *BufSize = Dem_Cfg_DidSize(Dem_Cfg_ERecDid(lCfgERecIndex));
            }
            else
            {
              *BufSize = 0;
            }
            lReturnValue = DEM_RECORD_OK;
          }
        }
        else
        { /* records not currently stored are returned with empty content */
          lReturnValue = DEM_RECORD_OK;
          *BufSize = 0;
        }
      }
      else
      { /* Statistic records always need to collect current data - if possible depending on event state */
        if (Dem_Cfg_DidSize(Dem_Cfg_ERecDid(lCfgERecIndex)) > *BufSize)
        {
          lReturnValue = DEM_RECORD_WRONG_BUFFERSIZE;
        }
        else
        {
          lReturnValue = DEM_RECORD_OK;

          lCopyDidInfo.SourceBuffer = (Dem_ConstSharedDataPtrType)NULL_PTR;
          lCopyDidInfo.Entry        = (Dem_SharedMemoryEntryPtrType)NULL_PTR;

          (void)Dem_Data_CopyDid(&lCopyDidInfo, Dem_Cfg_ERecDid(lCfgERecIndex));

          *BufSize = Dem_Cfg_DidSize(Dem_Cfg_ERecDid(lCfgERecIndex));
        }
      }
    }
    else
    {
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
      if (DEM_CFG_EREC_TYPE_USER == Dem_Cfg_ERecType(lCfgERecIndex))
      {
        ++lERecStoredIndex;
      }
# endif
    }
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_ERECS == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_ERECS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_GetSizeOfERec
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Dem_ReturnGetSizeOfDataByDTCType, DEM_CODE)
Dem_Dcm_GetSizeOfERec(
  Dem_EventIdType  EventId,
  uint8  RecordNumber,
  P2VAR(uint16, AUTOMATIC, DEM_APPL_DATA)  SizeOfExtendedDataRecord
)
{
  Dem_ReturnGetSizeOfDataByDTCType lReturnValue;
  Dem_Cfg_EventERecIterType lRecordIter;
  uint16 lAccumulatedSize;
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
  uint8 lERecStoredIndex;
# endif

  /* Find the Record number */
  lReturnValue = DEM_GETSIZEBYDTC_WRONG_RECNUM;

  Dem_Cfg_EventERecIterInit(EventId, &lRecordIter);                                                                              /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
  lAccumulatedSize = 0;
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
  lERecStoredIndex = 0;
# endif

  if (RecordNumber < 0xf0U)
  { /* Look for one specific record */
    while (FALSE != Dem_Cfg_EventERecIterExists(EventId, &lRecordIter))
    {
      Dem_Cfg_ERecIndexType lCfgERecIndex;

      lCfgERecIndex = Dem_Cfg_EventERecIterGet(EventId, &lRecordIter);
      Dem_Cfg_EventERecIterNext(EventId, &lRecordIter);

      if (RecordNumber == Dem_Cfg_DidNumber(Dem_Cfg_ERecDid(lCfgERecIndex)))
      { /* If the record is supported, the result is always 'OK' */
        uint8 lERecType;

        lERecType = Dem_Cfg_ERecType(lCfgERecIndex);
        lReturnValue = DEM_GETSIZEBYDTC_OK;

        if (DEM_CFG_EREC_TYPE_GLOBAL != lERecType)
        { /* Supported record, test if it is stored - if no entry was found, the stored mask is cleared as well! */
          if ( (DEM_EVENT_INVALID != Dem_Cfg_ReadoutBuffer.EventId)                                                              /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
            && ( (DEM_CFG_EREC_TYPE_INTERNAL == lERecType)                                                                       /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
              || (FALSE != Dem_Data_ERecIsStored(&Dem_Cfg_ReadoutBuffer, lERecStoredIndex)) )                                    /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
# endif
            )
          { /* add record id to data size */
            lAccumulatedSize = (uint16)(Dem_Cfg_DidSize(Dem_Cfg_ERecDid(lCfgERecIndex)) + 1);
          }
          else
          {
            lAccumulatedSize = 0;
          }
        }
        else
        { /* Currently statistic data is always available, add record id to data size */
          lAccumulatedSize = (uint16)(Dem_Cfg_DidSize(Dem_Cfg_ERecDid(lCfgERecIndex)) + 1);
        }
        break;
      }
      else
      {
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
        if (DEM_CFG_EREC_TYPE_USER == Dem_Cfg_ERecType(lCfgERecIndex))
        {
          ++lERecStoredIndex;
        }
# endif
      }
    }
  }
  else
  { /* Look for all supported records */
    uint8 lERecMinNumber;
    if (RecordNumber == 0xffU)
    {
      lERecMinNumber = 0x00U;
    }
    else
    {
      lERecMinNumber = 0x8fU;
    }

    while (FALSE != Dem_Cfg_EventERecIterExists(EventId, &lRecordIter))
    {
      Dem_Cfg_ERecIndexType lCfgERecIndex;

      lCfgERecIndex = Dem_Cfg_EventERecIterGet(EventId, &lRecordIter);
      Dem_Cfg_EventERecIterNext(EventId, &lRecordIter);

      if (Dem_Cfg_DidNumber(Dem_Cfg_ERecDid(lCfgERecIndex)) > lERecMinNumber)
      { /* At least one record found - the result should be negative in case the event doesn't
            support any of the requested extended records. */
        uint8 lERecType;

        lERecType = Dem_Cfg_ERecType(lCfgERecIndex);
        lReturnValue = DEM_GETSIZEBYDTC_OK;

        if (DEM_CFG_EREC_TYPE_GLOBAL != lERecType)
        { /* Supported record, test if it is stored - if no entry was found, the stored mask is cleared as well! */
          if ( (DEM_EVENT_INVALID != Dem_Cfg_ReadoutBuffer.EventId)                                                              /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
            && ( (DEM_CFG_EREC_TYPE_INTERNAL == lERecType)                                                                       /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
              || (FALSE != Dem_Data_ERecIsStored(&Dem_Cfg_ReadoutBuffer, lERecStoredIndex)) )                                    /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
# endif
            )
          { /* add record id to data size */
            lAccumulatedSize = (uint16)(lAccumulatedSize + Dem_Cfg_DidSize(Dem_Cfg_ERecDid(lCfgERecIndex)) + 1);
          }
        }
        else
        { /* Currently statistic data is always available, add record id to data size */
          lAccumulatedSize = (uint16)(lAccumulatedSize + Dem_Cfg_DidSize(Dem_Cfg_ERecDid(lCfgERecIndex)) + 1);
        }
      }
      else
      {
# if (DEM_CFG_SUPPORT_USER_ERECS == STD_ON)
        if (DEM_CFG_EREC_TYPE_USER == Dem_Cfg_ERecType(lCfgERecIndex))
        {
          ++lERecStoredIndex;
        }
# endif
      }
    }
  }

  if (lReturnValue == DEM_GETSIZEBYDTC_OK)
  {
    *SizeOfExtendedDataRecord = lAccumulatedSize;
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_ERECS == STD_ON) */

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Esm_EventQueueAsync_Queued
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventQueueAsync_Queued(
  Dem_EventIdType  EventId,
  Dem_ConstDebounceInfoPtrType  DebounceInfo
  )
{
  Std_ReturnType lReturnValue;

#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  if (FALSE != DebounceInfo->Common.RequestProcessing)
  { /* update event entry with a new max value > pre-confirmation limit on task level */
    Dem_Queue_SetEventStatus(EventId, DEM_QUEUE_SET_FDCPROCESSING(Dem_Queue_GetEventStatus(EventId)));
  }
#endif

  lReturnValue = Dem_Queue_SetPendingEvent_Queued(EventId, DebounceInfo->Common.MonitorStatus);

  return lReturnValue;
}

/* ****************************************************************************
 % Dem_Esm_EventQueueAsync_Immediate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventQueueAsync_Immediate(
  Dem_EventIdType  EventId,
  Dem_ConstDebounceInfoPtrType  DebounceInfo
  )
{
  Std_ReturnType lReturnValue;
  uint8 lOldEventStatus;

  lOldEventStatus = Dem_Mem_EventGetStatus(EventId);

#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  if (FALSE != DebounceInfo->Common.RequestProcessing)
  { /* update event entry with a new max value > pre-confirmation limit on task level */
    Dem_Queue_SetEventStatus(EventId, DEM_QUEUE_SET_FDCPROCESSING(Dem_Queue_GetEventStatus(EventId)));
  }
#endif

  lReturnValue = Dem_Queue_SetPendingEvent_Immediate(EventId,
                                                     DebounceInfo->Common.MonitorStatus,
                                                     lOldEventStatus);

  return lReturnValue;
}

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Esm_ProcessTimeDebounce
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_ProcessTimeDebounce(
  Dem_EventIdType  EventId
  )
{
  Dem_DebounceInfoType lDebounceInfo;
  sint16 lOldDebounceTime;
  sint16 lNewDebounceTime;
  boolean lEnableConditionsSatisfied;

  lDebounceInfo.Specific.TimeBased.OldInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
  switch (DEM_ESM_GET_DEBOUNCE_STATUS(lDebounceInfo.Specific.TimeBased.OldInternalStatus))
  {
  case DEM_ESM_DEBOUNCE_FREEZE_PASSED:
  case DEM_ESM_DEBOUNCE_FREEZE_FAILED:
  case DEM_ESM_DEBOUNCE_FREEZE_FAILED_FDC:
  case DEM_ESM_DEBOUNCE_DONE_PASSED:
  case DEM_ESM_DEBOUNCE_DONE_FAILED:
  case DEM_ESM_DEBOUNCE_STATUS_NONE:
    /* nothing to do here */
    return;
  default:
    break;
  }

  lDebounceInfo.Specific.TimeBased.NewInternalStatus = lDebounceInfo.Specific.TimeBased.OldInternalStatus;
#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  lDebounceInfo.Common.RequestProcessing = FALSE;
#endif
  lDebounceInfo.Common.MonitorStatus = DEM_EVENT_STATUS_INVALID;
  lOldDebounceTime = Dem_Mem_EventGetDebounceValue(EventId);

  lEnableConditionsSatisfied = (boolean)
    ((Dem_CurrentEnableConditionStates & Dem_Cfg_EventEnableConditions(EventId)) == Dem_Cfg_EventEnableConditions(EventId));

  /* Process debounce counters */
  switch (DEM_ESM_GET_DEBOUNCE_STATUS(lDebounceInfo.Specific.TimeBased.OldInternalStatus))
  {
  case DEM_ESM_DEBOUNCE_RESET_PASSED:
    lNewDebounceTime = Dem_Cfg_EventPassedTime(EventId);
    lDebounceInfo.Specific.TimeBased.NewInternalStatus =
        DEM_ESM_SET_DEBOUNCE_STATUS(lDebounceInfo.Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_COUNT_PASSED);
    break;

  case DEM_ESM_DEBOUNCE_RESET_FAILED:
    lNewDebounceTime = Dem_Cfg_EventFailedTime(EventId);
    lDebounceInfo.Specific.TimeBased.NewInternalStatus =
        DEM_ESM_SET_DEBOUNCE_STATUS(lDebounceInfo.Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_COUNT_FAILED);
    break;

  case DEM_ESM_DEBOUNCE_COUNT_PASSED:
    /* process event timer */
    lNewDebounceTime = (sint16)(lOldDebounceTime - 1);
    if (0 == lNewDebounceTime)
    {
      lDebounceInfo.Specific.TimeBased.NewInternalStatus =
        DEM_ESM_SET_DEBOUNCE_STATUS(lDebounceInfo.Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_DONE_PASSED);
      lDebounceInfo.Common.MonitorStatus = DEM_EVENT_STATUS_PASSED;
    }
    break;

  case DEM_ESM_DEBOUNCE_COUNT_FAILED:
    /* process event timer */
    lNewDebounceTime = (sint16)(lOldDebounceTime - 1);
#if (DEM_CFG_STORAGE_AT_FDC != STD_ON)
    if (0 == lNewDebounceTime)
    {
      lDebounceInfo.Specific.TimeBased.NewInternalStatus =
        DEM_ESM_SET_DEBOUNCE_STATUS(lDebounceInfo.Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_DONE_FAILED);
      lDebounceInfo.Common.MonitorStatus = DEM_EVENT_STATUS_FAILED;
    }
#endif
#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
# if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
    if (lNewDebounceTime <= Dem_Cfg_EventStorageTime(EventId))
    {
      if (0 == lNewDebounceTime)
      {
        lDebounceInfo.Specific.TimeBased.NewInternalStatus =
          DEM_ESM_SET_DEBOUNCE_STATUS(lDebounceInfo.Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_DONE_FAILED);
        lDebounceInfo.Common.MonitorStatus = DEM_EVENT_STATUS_FAILED;
      }
      else
      {
        lDebounceInfo.Specific.TimeBased.NewInternalStatus =
          DEM_ESM_SET_DEBOUNCE_STATUS(lDebounceInfo.Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_COUNT_FAILED_FDC);
      }
      if (lEnableConditionsSatisfied == TRUE)
      {
        lDebounceInfo.Specific.TimeBased.NewInternalStatus =
          DEM_ESM_SET_FDC_TRIP(lDebounceInfo.Specific.TimeBased.NewInternalStatus);
        lDebounceInfo.Common.RequestProcessing = TRUE;
      }
    }
# endif
# if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
    if ( (lEnableConditionsSatisfied == TRUE)
      && (Dem_Mem_EventGetDebounceValueMax(EventId) > lNewDebounceTime) )
    {
      lDebounceInfo.Specific.TimeBased.NewInternalStatus =
        DEM_ESM_SET_FDC_MAX(lDebounceInfo.Specific.TimeBased.NewInternalStatus);
      lDebounceInfo.Common.RequestProcessing = TRUE;
    }
# endif
#endif
    break;

#if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
  case DEM_ESM_DEBOUNCE_COUNT_FAILED_FDC:
    /* process event timer */
    lNewDebounceTime = (sint16)(lOldDebounceTime - 1);
    if (0 == lNewDebounceTime)
    {
      lDebounceInfo.Specific.TimeBased.NewInternalStatus =
          DEM_ESM_SET_DEBOUNCE_STATUS(lDebounceInfo.Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_DONE_FAILED);
      lDebounceInfo.Common.MonitorStatus = DEM_EVENT_STATUS_FAILED;
    }

# if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
    if ( (lEnableConditionsSatisfied == TRUE)
      && (Dem_Mem_EventGetDebounceValueMax(EventId) > lNewDebounceTime) )
    {
      lDebounceInfo.Specific.TimeBased.NewInternalStatus =
          DEM_ESM_SET_FDC_MAX(lDebounceInfo.Specific.TimeBased.NewInternalStatus);
      lDebounceInfo.Common.RequestProcessing = TRUE;
    }
# endif
    break;
#endif

  default:
    Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_INCONSISTENT_STATE)
    return;
  }

  /* Commit changes */
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  if (lDebounceInfo.Specific.TimeBased.OldInternalStatus == Dem_Mem_EventGetInternalStatus(EventId))
  {
    Dem_Mem_EventSetDebounceValue(EventId, lNewDebounceTime);
    Dem_Mem_EventSetInternalStatus(EventId, lDebounceInfo.Specific.TimeBased.NewInternalStatus);

# if (DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE == STD_ON)
    if (DEM_ESM_DEBOUNCE_COUNT_FAILED == DEM_ESM_GET_DEBOUNCE_STATUS(lDebounceInfo.Specific.TimeBased.OldInternalStatus))
    {
      if (Dem_Mem_EventGetDebounceValueMax(EventId) > lNewDebounceTime)
      {
        Dem_Mem_EventSetDebounceValueMax(EventId, lNewDebounceTime);
      }
    }
# endif
    if ( (lEnableConditionsSatisfied == TRUE)
      && ( (lDebounceInfo.Common.MonitorStatus <= DEM_EVENT_STATUS_FAILED)
#  if ( (DEM_CFG_STORAGE_AT_FDC == STD_ON) \
     || (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON) )
        || (FALSE != lDebounceInfo.Common.RequestProcessing)
#  endif
       ) )
    {
      (void)Dem_Esm_EventQueueAsync_Queued(EventId, &lDebounceInfo);
    }
  }

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
}                                                                                                                                /* PRQA S 2006, 6010, 6030 */ /* MD_DEM_14.7, MD_MSR_STPTH, MD_MSR_STCYC */
#endif /* (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) */

/* ****************************************************************************
 % Dem_Esm_PreInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PreInit(
  void
  )
{
  Dem_Mem_CurrentCycleState = 0U;
#if (DEM_CFG_SUPPORT_RESTART_CYCLE == STD_ON)
  Dem_Mem_CurrentCycleState = (uint16)(Dem_Mem_CurrentCycleState | (uint16)(1U << Dem_Cfg_GlobalRestartCycleId()));
#endif
  {
    Dem_EventIdType lEventId;
    for (lEventId = DEM_EVENT_FIRST; lEventId < Dem_Cfg_GlobalEventCount(); ++lEventId)
    {
#if ( (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)  \
   || (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) )
      Dem_Mem_EventSetDebounceValue(lEventId, 0);
#endif
#if (DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE == STD_ON)
      Dem_Mem_EventSetDebounceValueMax(lEventId, 0);
#endif
#if (DEM_FEATURE_NEED_EVENTAVAILABLE_DEFAULT == STD_ON)
# if (DEM_CFG_ISCONST_EVENTAVAILABLE != STD_ON)
      if (FALSE != Dem_Cfg_EventAvailable(lEventId))
# endif
      {
# if (DEM_FEATURE_NEED_EVENTAVAILABLE == STD_ON)
        Dem_Mem_EventSetInternalStatus(lEventId, 0);
# endif
      }
# if (DEM_CFG_ISCONST_EVENTAVAILABLE != STD_ON)
      else
# endif
      {
# if (DEM_FEATURE_NEED_EVENTNOTAVAILABLE == STD_ON)
        Dem_Mem_EventSetInternalStatus(lEventId, DEM_ESM_SET_EVENT_DISCONNECTED(0));
# endif
      }
#else
      Dem_Mem_EventSetInternalStatus(lEventId, 0);
#endif
    }
  }
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  {
    Dem_Cfg_CombinedGroupIndexType lGroupId;
    for (lGroupId = 0; lGroupId < Dem_Cfg_GlobalCombinedGroupCount(); ++lGroupId)
    {
      Dem_Cfg_EventInternalStatusType lInternalStatus;
      lInternalStatus = 0;

# if ( (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON) \
    || (DEM_FEATURE_NEED_EVENTAVAILABLE_DEFAULT == STD_ON) && (DEM_CFG_ISCONST_EVENTAVAILABLE != STD_ON) )
      {
        Dem_Cfg_CombinedGroupIterType lSubEventIter;

#  if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
        lInternalStatus = DEM_ESM_SET_EVENT_DISCONNECTED(lInternalStatus);
#  endif
        for (Dem_Cfg_CombinedGroupIterInit(lGroupId, &lSubEventIter);                                                            /* PRQA S 3198, 3418 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
             (FALSE != Dem_Cfg_CombinedGroupIterExists(lGroupId, &lSubEventIter));
             Dem_Cfg_CombinedGroupIterNext(lGroupId, &lSubEventIter))
        {
#  if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
          if (FALSE != Dem_Cfg_EventAvailableInVariant(Dem_Cfg_CombinedGroupIterGet(lGroupId, &lSubEventIter)))
          {
            lInternalStatus = DEM_ESM_SET_AVAILABLEINVARIANT(lInternalStatus);
          }
#  endif
#  if (DEM_FEATURE_NEED_EVENTAVAILABLE_DEFAULT == STD_ON)
#   if (DEM_CFG_ISCONST_EVENTAVAILABLE == STD_OFF)
          if (Dem_Cfg_EventAvailable(Dem_Cfg_CombinedGroupIterGet(lGroupId, &lSubEventIter)) == TRUE)
#   endif
          {
#   if (DEM_FEATURE_NEED_EVENTAVAILABLE == STD_ON)
            lInternalStatus = DEM_ESM_RESET_EVENT_DISCONNECTED(lInternalStatus);
#   endif
          }
#  endif
        }
      }
# else
#  if (DEM_FEATURE_NEED_EVENTAVAILABLE_DEFAULT == STD_ON) && (DEM_CFG_ISCONST_EVENTAVAILABLE == STD_ON)
#   if (DEM_CFG_CONST_EVENTAVAILABLE == FALSE)
      lInternalStatus = DEM_ESM_SET_EVENT_DISCONNECTED(lInternalStatus);
#   endif
#  endif
# endif
      Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, lInternalStatus);
    }
  }
#endif
#if (DEM_CFG_SUPPORT_DEBOUNCE_TIME_LR == STD_ON)
  Dem_Esm_DebounceLoResTimer = Dem_Cfg_DebounceLoResTimerValue();
#endif
}

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Esm_PrestorageInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_PrestorageInit(
  void
  )
{
  Dem_Esm_PrestorageLockedIndex = DEM_MEM_INVALID_PRESTORAGE_INDEX;
}
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) && (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
/* ****************************************************************************
 % Dem_Esm_InitEventAvailableNV
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_InitEventAvailableNV(
  void
  )
{
  Dem_EventIdType lEventId;
  uint16_least lMaskIndex;
  uint16_least lMaskIndex_End;

  lEventId = 0;
  lMaskIndex_End = (uint16_least)((Dem_Cfg_GlobalEventCount() + 7) / 8);
  
  /* */
  for (lMaskIndex = 0; lMaskIndex < lMaskIndex_End; ++lMaskIndex)
  {
    Dem_EventIdType lEventId_End;
    uint8 lNvAvailableMask;
    
    lEventId_End = lEventId + 8;
    if (lEventId_End > Dem_Cfg_GlobalEventCount())
    {
      lEventId_End = Dem_Cfg_GlobalEventCount();
    }
    lNvAvailableMask = Dem_Mem_EventGetAvailableMask(lMaskIndex);

    while (lEventId < lEventId_End)
    {
      if ((lNvAvailableMask & 0x01) != 0)
      {
        boolean lMayDisconnect;
        lMayDisconnect = Dem_Esm_EventMayDisconnect(lEventId);
        Dem_Esm_EventSetDisconnectedBit(lEventId, lMayDisconnect);
      }
      else
      {
        Dem_Esm_EventSetDisconnectedBit(lEventId, FALSE);
      }
      lNvAvailableMask = (uint8)(lNvAvailableMask >> 1);
      ++lEventId;
    }
  }
}
#endif

#if (DEM_FEATURE_NEED_EVENTAVAILABLE_DEFAULT == STD_ON)
/* ****************************************************************************
 % Dem_Esm_InitEventInternalStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_InitEventInternalStatus(
  Dem_EventIdType EventId                                                                                                        /* PRQA S 3206 */ /* MD_DEM_3206 */
)
{
# if (DEM_CFG_ISCONST_EVENTAVAILABLE != STD_ON)
  if (Dem_Cfg_EventAvailable(EventId) == FALSE)
  {
    boolean lMayDisconnect;
    lMayDisconnect = Dem_Esm_EventMayDisconnect(EventId);
    Dem_Esm_EventSetDisconnectedBit(EventId, lMayDisconnect);
  }
  else
# endif
  {
    Dem_Esm_EventSetDisconnectedBit(EventId, FALSE);
  }
}
#endif

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 % Dem_Esm_InitGroupInternalStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_InitGroupInternalStatus(
  Dem_Cfg_CombinedGroupIndexType GroupId                                                                                         /* PRQA S 3206 */ /* MD_DEM_3206 */
)
{
# if (DEM_FEATURE_NEED_EVENTAVAILABLE_DEFAULT == STD_ON) && (DEM_CFG_ISCONST_EVENTAVAILABLE != STD_ON)
  Dem_Cfg_CombinedGroupIterType lSubEventIter;
  Dem_Cfg_EventInternalStatusType lInternalStatus;

  lInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(GroupId);
  lInternalStatus = DEM_ESM_SET_EVENT_DISCONNECTED(lInternalStatus);

  for (Dem_Cfg_CombinedGroupIterInit(GroupId, &lSubEventIter);                                                                   /* PRQA S 3198, 3418 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
       (FALSE != Dem_Cfg_CombinedGroupIterExists(GroupId, &lSubEventIter));
       Dem_Cfg_CombinedGroupIterNext(GroupId, &lSubEventIter))
  {
    if (FALSE != Dem_Cfg_EventAvailable(Dem_Cfg_CombinedGroupIterGet(GroupId, &lSubEventIter)))
    {
      lInternalStatus = DEM_ESM_RESET_EVENT_DISCONNECTED(lInternalStatus);
    }
  }
  Dem_Mem_CombinedGroupSetInternalStatus(GroupId, lInternalStatus);
# else
  DEM_IGNORE_UNUSED_ARGUMENT(GroupId)                                                                                            /* PRQA S 3112 */ /* MD_DEM_14.2 */
# endif
}
#endif

/* ****************************************************************************
 % Dem_Esm_InitEventStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_InitEventStatus(
  Dem_EventIdType EventId
  )
{
  uint8 lEventStatus;
  Dem_Cfg_EventInternalStatusType lAgedStatus;

  lEventStatus = Dem_Mem_EventGetStatus(EventId);
  lAgedStatus = DEM_ESM_GET_STORED_STATUS(Dem_Util_DtcGetInternalStatus(EventId));

#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
  if (Dem_Cfg_EventAvailableInVariant(EventId) == FALSE)
  {
    lEventStatus = 0x00;
  }
  else
#endif
#if (DEM_FEATURE_NEED_STOREDONLY_BITS == STD_ON)
  if (DEM_ESM_STORED_STATUS_NONE == lAgedStatus)
  {
    /* Event is not stored, reset stored-only bits.
      * Note: this relies on the compiler to optimize the different bit operations into a single mask operation.
      * The intention is to find a dedicated access for each Bit modification for review purposes.*/
# if (DEM_CFG_PROCESS_PDTC_STOREDONLY == STD_ON)
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_PDTC(lEventStatus);
# endif
# if (DEM_CFG_PROCESS_CDTC_STOREDONLY == STD_ON)
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_CDTC(lEventStatus);
# endif
# if (DEM_CFG_PROCESS_TFSLC_STOREDONLY == STD_ON)
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_TFSLC(lEventStatus);
# endif
  }
  else
#endif
#if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
  if (DEM_ESM_STORED_STATUS_AGED == lAgedStatus)
  {
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_PDTC(lEventStatus);
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_CDTC(lEventStatus);
# if (DEM_CFG_PROCESS_TFSLC_ALL_DTC == STD_ON)
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_TFSLC(lEventStatus);
# endif
  }
  else
#endif
  if (DEM_ESM_STORED_STATUS_AGING == lAgedStatus)
  {
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_PDTC(lEventStatus);
  }
  else
  {
    /* Satisfy MISRA */
  }

#if (DEM_CFG_SUPPORT_TESTFAILED_STORAGE != STD_ON)
  lEventStatus = DEM_ESM_RESET_UDS_STATUS_TF(lEventStatus);
#endif

  if ((DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_TNCTOC) == (lEventStatus & (DEM_UDS_STATUS_TFTOC | DEM_UDS_STATUS_TNCTOC)))
  { /* Test not completed, but failed this cycle is not a consistent state.
       Reset TFTOC to restore consistency. This also makes sure a new test
       result is processed */
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_TFTOC(lEventStatus);
  }
  if ((DEM_UDS_STATUS_TFSLC | DEM_UDS_STATUS_TNCSLC) == (lEventStatus & (DEM_UDS_STATUS_TFSLC | DEM_UDS_STATUS_TNCSLC)))
  { /* Test not completed, but failed since last clear is not a consistent state.
       Reset TNCSLC to restore consistency. Keep TFSLC since it is sometimes
       set by correction code */
    lEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCSLC(lEventStatus);
  }

  {
#if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
# if (DEM_FEATURE_NEED_USER_INDICATORS == STD_ON)
    Dem_Cfg_EventIndicatorIterType lIndicatorIter;
    Dem_Cfg_EventIndicatorIterInit(EventId, &lIndicatorIter);                                                                    /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
    if (FALSE == Dem_Cfg_EventIndicatorIterExists(EventId, &lIndicatorIter))
# endif
    {
#endif /* (DEM_FEATURE_NEED_INDICATORS == STD_ON) */
      {
        lEventStatus = DEM_ESM_RESET_UDS_STATUS_WIR(lEventStatus);
      }
#if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
    }
#endif
  }

  Dem_Mem_EventSetStatus(EventId, lEventStatus);

#if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
  if (FALSE != DEM_ESM_TEST_UDS_STATUS_WIR(lEventStatus))
  {
    {
# if (DEM_FEATURE_NEED_USER_INDICATORS == STD_ON)
      Dem_Esm_UserIndicatorEnable(EventId);
# endif
    }
  }
#endif /* (DEM_CFG_SUPPORT_INDICATORS == STD_ON) */
}                                                                                                                                /* PRQA S 6030 */ /* MD_MSR_STCYC */                                                                                                        /* PRQA S 6010 */ /* MD_MSR_STPTH */

/* ****************************************************************************
 % Dem_Esm_Init
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_Init(
  void
  )
{
  Dem_EventIdType lEventId;
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
#endif

  for (lEventId = DEM_EVENT_FIRST; lEventId < Dem_Cfg_GlobalEventCount(); ++lEventId)
  {
#if (DEM_FEATURE_NEED_EVENTAVAILABLE_DEFAULT == STD_ON)
    Dem_Esm_InitEventInternalStatus(lEventId);
#endif
    Dem_Esm_InitEventStatus(lEventId);

  } /* for each event */

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) && (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
  Dem_Esm_InitEventAvailableNV();
#endif

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  {
    lGroupId = Dem_Cfg_GlobalCombinedGroupCount();
    while (lGroupId > 0)
    {
      --lGroupId;
      Dem_Esm_InitGroupInternalStatus(lGroupId);
      Dem_Mem_CombinedGroupSetStatus(lGroupId, Dem_Data_CombinedGroupGetStatus(lGroupId));
    }
  }
#endif
#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  Dem_Esm_PrestorageInit();
#endif
#if (DEM_CFG_SUPPORT_RESTART_CYCLE == STD_ON)
  Dem_Esm_CycleUpdate(Dem_Cfg_GlobalRestartCycleId(), DEM_QUEUE_CYCLE_RESTARTED);
#endif
}                                                                                                                                /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */

#if (DEM_CFG_SUPPORT_OPCYCLE_STORAGE != STD_ON) || (DEM_CFG_SUPPORT_OPCYCLE_AUTOMATIC_END == STD_ON)
/* ****************************************************************************
 % Dem_Esm_Shutdown
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_Shutdown(
  void
  )
{
  uint8 lCycleIndex;

  for (lCycleIndex = 0; lCycleIndex < Dem_Cfg_GlobalCycleCount(); ++lCycleIndex)
  {
    {
      if ( (DEM_QUEUE_CYCLE_STARTED == Dem_Mem_GetCycleStatus(lCycleIndex))
# if (DEM_FEATURE_NEED_CYCLEAUTOMATICEND == STD_ON)
        && (FALSE != Dem_Cfg_CycleIsAutomaticEnd(lCycleIndex))
# endif
        )
      {
        Dem_Esm_CycleUpdate(lCycleIndex, DEM_QUEUE_CYCLE_STOPPED);
      }
    }
  }

#if (DEM_CFG_SUPPORT_RESTART_CYCLE == STD_ON)
  Dem_Mem_CurrentCycleState = (uint16)(Dem_Mem_CurrentCycleState | (uint16)(1U << Dem_Cfg_GlobalRestartCycleId()));
#endif
}
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Esm_MainFunction
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL_INLINE FUNC(void, DEM_CODE)
Dem_Esm_MainFunction(
  void
  )
{
  Dem_EventIdType lEventId;

# if (DEM_CFG_SUPPORT_DEBOUNCE_TIME_HR == STD_ON)
  {
    Dem_Cfg_DebounceHiResIterType lIter;

    /* Process Time Based Debounce Events which use the high resolution timer */
    Dem_Cfg_DebounceHiResIterInit(&lIter);                                                                                       /* PRQA S 3417 */ /* MD_DEM_12.10 */
    while (FALSE != Dem_Cfg_DebounceHiResIterExists(&lIter))
    {
      lEventId = Dem_Cfg_DebounceHiResIterGet(&lIter);
      Dem_Esm_ProcessTimeDebounce(lEventId);
      Dem_Cfg_DebounceHiResIterNext(&lIter);
    }
  }
# endif /* ( DEM_CFG_SUPPORT_DEBOUNCE_TIME_HR == STD_ON ) */

# if (DEM_CFG_SUPPORT_DEBOUNCE_TIME_LR == STD_ON)
  Dem_Esm_DebounceLoResTimer--;

  if (Dem_Esm_DebounceLoResTimer == 0)
  {
    Dem_Cfg_DebounceLoResIterType lIter;

    /* Process Time Based Debounce Events which use the low resolution timer */
    Dem_Cfg_DebounceLoResIterInit(&lIter);                                                                                       /* PRQA S 3417 */ /* MD_DEM_12.10 */
    while (FALSE != Dem_Cfg_DebounceLoResIterExists(&lIter))
    {
      lEventId = Dem_Cfg_DebounceLoResIterGet(&lIter);
      Dem_Esm_ProcessTimeDebounce(lEventId);
      Dem_Cfg_DebounceLoResIterNext(&lIter);
    }

    /* restart low resolution timer */
    Dem_Esm_DebounceLoResTimer = Dem_Cfg_DebounceLoResTimerValue();
  }
# endif /* (DEM_CFG_SUPPORT_DEBOUNCE_TIME_LR == STD_ON) */
}
#endif /* (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) */

#define DEM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/* ********************************************************************************************************************
 *  LOCAL FUNCTION DEFINITIONS
 *********************************************************************************************************************/

#define DEM_START_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                                            /* Notifications */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
/* ****************************************************************************
 % Dem_Cbk_DtcStatusChanged_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Cbk_DtcStatusChanged_Internal(
  Dem_EventIdType  EventId,
  Dem_EventStatusExtendedType  DtcStatusOld,
  Dem_EventStatusExtendedType  DtcStatusNew
  )
{
# if (DEM_FEATURE_NEED_TESTSUPPRESSION == STD_ON)
  if (FALSE == Dem_Esm_TestDtcSuppressed(EventId))
# endif
  {
    uint8 lDtcStatusOld;
    uint8 lDtcStatusNew;

    lDtcStatusOld = (uint8)(DtcStatusOld & Dem_Cfg_GlobalStatusMask());
    lDtcStatusNew = (uint8)(DtcStatusNew & Dem_Cfg_GlobalStatusMask());

    if (0 != (lDtcStatusOld ^ lDtcStatusNew))
    { /* DTC Status has changed */
      uint32 lUdsDtc;

      lUdsDtc = Dem_Cfg_EventUdsDtc(EventId);

      if (DEM_CFG_DTC_UDS_INVALID != lUdsDtc)
      {
# if (DEM_CFG_NOTIFY_DTC_STATUS == STD_ON)
        {
          Dem_Cfg_GlobalCbkDtcIterType lIter;

          /* Call all configured status change callbacks */
          Dem_Cfg_GlobalCbkDtcIterInit(&lIter);                                                                                  /* PRQA S 3417 */ /* MD_DEM_12.10 */

          while (FALSE != Dem_Cfg_GlobalCbkDtcIterExists(&lIter))
          {
            Dem_DtcStatusChangedFPtrType lpDtcStatusChangedFunc;

            lpDtcStatusChangedFunc = Dem_Cfg_GlobalCbkDtcIterGet(&lIter);

            (void)(*lpDtcStatusChangedFunc)(lUdsDtc, lDtcStatusOld, lDtcStatusNew);

            Dem_Cfg_GlobalCbkDtcIterNext(&lIter);
          }
        }
# endif /* (DEM_CFG_NOTIFY_DTC_STATUS == STD_ON) */

# if (DEM_CFG_NOTIFY_DCM == STD_ON)
        /* Call Dcm Dtc status change callback */
        (void)Dcm_DemTriggerOnDTCStatus(lUdsDtc, lDtcStatusOld, lDtcStatusNew);
# endif
      } /* if (DEM_CFG_DTC_UDS_INVALID != lUdsDtc) */

    } /* if DTC Status has changed */
  } /* if DTC is not suppressed */
}
#endif /* (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON) */

#if (DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON)
/* ****************************************************************************
 % Dem_Cbk_StatusChanged
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Cbk_StatusChanged(
  Dem_EventIdType  EventId,
  Dem_EventStatusExtendedType  EventStatusOld,
  Dem_EventStatusExtendedType  EventStatusNew
  )
{
# if (DEM_CFG_NOTIFY_FIM == STD_ON)
  /* Call FiM event status change callback */
  (void)FiM_DemTriggerOnEventStatus(EventId, EventStatusOld, EventStatusNew);
# endif

# if (DEM_CFG_NOTIFY_DLT == STD_ON)
  /* Call Dlt event status change callback */
  Dlt_DemTriggerOnEventStatus(EventId, EventStatusOld, EventStatusNew);
# endif

# if (DEM_CFG_NOTIFY_EVENT_STATUS == STD_ON)
  {
    Dem_Cfg_EventCbkStatusIterType lIter;
    /* Call all configured status change callbacks for this event */
    Dem_Cfg_EventCbkStatusIterInit(EventId, &lIter);                                                                             /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */

    while (FALSE != Dem_Cfg_EventCbkStatusIterExists(EventId, &lIter))
    {
      Dem_EventStatusChangedFPtrType lpEventStatusChangedFunc;

      lpEventStatusChangedFunc = Dem_Cfg_EventCbkStatusIterGet(EventId, &lIter);

      (void)(*lpEventStatusChangedFunc)(EventStatusOld, EventStatusNew);

      Dem_Cfg_EventCbkStatusIterNext(EventId, &lIter);
    }
  }
# endif

# if (DEM_CFG_NOTIFY_GENERAL_STATUS == STD_ON)
  /* Call general event status changed callback */
  (void)Dem_Cfg_GlobalCbkStatus(EventId, EventStatusOld, EventStatusNew);                                                       /* PRQA S 3423 */ /* MD_DEM_3423 */
# endif
}
#endif

                                                           /* Memory Manager */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON)
/* ****************************************************************************
 % Dem_Mem_SelectDisplacedIndex
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(uint8, DEM_CODE)
Dem_Mem_SelectDisplacedIndex(
  DEM_MEM_MEMORYINFO_PARAMDEF_FIRST
  Dem_EventIdType  DisplacingEventId
  )
{
  struct DisplacementInfoType
  {
    uint16                   EventId;
    Dem_Cfg_MemoryIndexType  MemoryIndex;
    uint8                    DtcStatus;
  } lBestMatchInfo;

  uint8 lChronoIndexIterator;

  lBestMatchInfo.EventId = DisplacingEventId;
  lBestMatchInfo.MemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;
  lBestMatchInfo.DtcStatus = DEM_UDS_STATUS_TF;

  /* find lowest priority DTC in memory. scan in chronological order, so the
     first found entry is the older one (to break ties) */
  for (lChronoIndexIterator = 0; lChronoIndexIterator < Dem_Mem_MemoryGetCurrentSize(); ++lChronoIndexIterator)
  {
    struct DisplacementInfoType lCandidateInfo;
    Dem_Mem_EntryPtrType lMemoryEntry;

    lCandidateInfo.MemoryIndex = Dem_Mem_MemoryGetChronology(lChronoIndexIterator);
    lMemoryEntry = Dem_Mem_MemoryGetEntry(lCandidateInfo.MemoryIndex);                                                           /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
    lCandidateInfo.EventId = Dem_Mem_EntryGetEventId(lMemoryEntry);
    lCandidateInfo.DtcStatus = Dem_Util_DtcApplyCombinedStatus(Dem_Util_DtcGetStatus(lCandidateInfo.EventId));

# if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
    if (DEM_ESM_CYCLECOUNT_EVENT_AGED == Dem_Mem_EntryGetAgingCount(lMemoryEntry))
    { /* aged event can be displaced immediately */
      lBestMatchInfo = lCandidateInfo;
      break;                                                                                                                     /* PRQA S 0771 */ /* MD_DEM_14.6_opt */
    }
# endif
# if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON)
    if (FALSE != DEM_MEM_TEST_AGING_ONLY(Dem_Mem_EntryGetState(lMemoryEntry)))
    { /* aging counter can be displaced immediately */
      lBestMatchInfo = lCandidateInfo;
      break;                                                                                                                     /* PRQA S 0771 */ /* MD_DEM_14.6_opt */
    }
# endif

# if (DEM_CFG_ISCONST_PRIORITY != STD_ON)
    if (Dem_Cfg_EventPriority(lCandidateInfo.EventId) < Dem_Cfg_EventPriority(lBestMatchInfo.EventId))
    { /* Never displace events with higher priority */
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }
    if (Dem_Cfg_EventPriority(lCandidateInfo.EventId) > Dem_Cfg_EventPriority(lBestMatchInfo.EventId))
    { /* always prefer an event with lowest priority */
      lBestMatchInfo = lCandidateInfo;
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }
# endif

# if (DEM_CFG_DISPLACEMENT_PREFER_PASSIVE == STD_ON)
# if ( (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON) \
    || (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON) \
    || (DEM_CFG_ISCONST_PRIORITY != STD_ON) )
    /* Compiler warning: condition is always false if no prior condition is enabled to set new best match */
    if (FALSE == DEM_ESM_TEST_UDS_STATUS_TF(lBestMatchInfo.DtcStatus))
    { /* If current best candidate is passive, it is a better match as it is older */
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }
#  endif
    if (FALSE == DEM_ESM_TEST_UDS_STATUS_TF(lCandidateInfo.DtcStatus))
    { /* did not find a passive event before, so candidate is a better match */
      lBestMatchInfo = lCandidateInfo;
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }
# endif

# if (DEM_CFG_DISPLACEMENT_TNCTOC_IS_PASSIVE == STD_ON)
    if ( (FALSE == DEM_ESM_TEST_UDS_STATUS_TNCTOC(lBestMatchInfo.DtcStatus))
      && (FALSE != DEM_ESM_TEST_UDS_STATUS_TNCTOC(lCandidateInfo.DtcStatus)) )
    {
      lBestMatchInfo = lCandidateInfo;
      continue;                                                                                                                  /* PRQA S 0770 */ /* MD_DEM_14.5 */
    }
# endif
  }
# if (DEM_CFG_DISPLACEMENT_FALLBACK_OLDEST == STD_ON)
  if (lBestMatchInfo.EventId == DisplacingEventId)
  { /* no match found - use fallback */
    /* The oldest event can be always displaced (could be DEM_MEM_INVALID_MEMORY_INDEX!) */
    lBestMatchInfo.MemoryIndex = Dem_Mem_MemoryGetChronology(0);
  }
#endif

  return lBestMatchInfo.MemoryIndex;
}                                                                                                                                /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
#endif

/* ****************************************************************************
 % Dem_Mem_MemoryAllocateIndex_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryAllocateIndex_Internal(
  DEM_MEM_MEMORYINFO_PARAMDEF_FIRST
  Dem_EventIdType  EventId
  )
{
  Dem_Cfg_MemoryIndexType lMemoryIndex;
  Dem_EventIdType lMasterEventId;

  lMasterEventId = Dem_Util_DtcGetMasterEvent(EventId);

  if (Dem_Mem_MemoryGetMaxSize() == Dem_Mem_MemoryGetCurrentSize())
  { /* Memory is filled up */
#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
    Dem_Mem_SetOverflow(Dem_Mem_MemoryId());
#endif

#if (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON)
    lMemoryIndex = Dem_Mem_SelectDisplacedIndex(DEM_MEM_MEMORYINFO_PARAM_FIRST EventId);
#else
    lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX; /* Always failed */
#endif

#if (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON)
    if (lMemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX)
    { /* a displaced DTC was identified, now remove that DTC */
      Dem_Mem_EntryPtrType lEntry;
      Dem_EventIdType lDisplacedEventId;

      lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);                                                                             /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
      lDisplacedEventId = Dem_Mem_EntryGetEventId(lEntry);

      Dem_Esm_EventDisplaced(lDisplacedEventId);
      Dem_Mem_MemoryFreeIndex(lMemoryIndex);

    }
    /* else: no adequate DTC found, the new entry cannot be added - return an invalid index */
#endif
  }
  else
  { /* primary memory is not full */
    /* Memory is not full -> Find first free entry */
    lMemoryIndex = Dem_Mem_MemoryFindIndex(DEM_EVENT_INVALID);
    /* if not found : lMemoryIndex == DEM_MEM_INVALID_MEMORY_INDEX */
  }

  if (lMemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX)
  {
    Dem_Mem_EntryPtrType lEntry;
    uint8 lMemorySize;

    lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);                                                                               /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
    lMemorySize = Dem_Mem_MemoryGetCurrentSize();

    /* At this point, the event memory is not completely filled */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
    if (lMemorySize >= Dem_Mem_MemoryGetMaxSize())
    {
      lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;
    }
    else
# endif
    {
      /* fill the chrono record with event id and lock the referenced PriMem slot */
      Dem_Mem_MemorySetChronology(lMemorySize, lMemoryIndex);                                                                    /* PRQA S 3689 */ /* MD_DEM_21.1 */

      Dem_Mem_EntrySetEventId(lEntry, lMasterEventId);                                                                           /* PRQA S 0505 */ /* MD_DEM_1.2 */
      Dem_Mem_EntrySetTimestamp(lEntry, Dem_Mem_CurrentTimestamp);

      Dem_Data_EntryInit(lEntry);
#if (DEM_FEATURE_NEED_DEBOUNCE == STD_ON)
# if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
#  if ((DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) && (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON))
      if (DEM_CFG_DEBOUNCETYPE_TIMER == Dem_Cfg_EventDebounceType(EventId))
#  endif
      {
#  if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
        Dem_Mem_EntrySetDebounceValueMax(lEntry, Dem_Cfg_EventFailedTime(EventId));
#  endif
      }
#  if ((DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON) && (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON))
      else
#  endif
      {
#  if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
        Dem_Mem_EntrySetDebounceValueMax(lEntry, 0);
#  endif
      }
# endif
#endif
      ++Dem_Mem_CurrentTimestamp;
      Dem_Mem_MemorySetCurrentSize((uint8)(lMemorySize + 1));
    }
  }

  return lMemoryIndex;
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

#if (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON) && (DEM_FEATURE_NEED_AGING_DELAYED == STD_ON)
/* ****************************************************************************
 % Dem_Mem_MemoryAllocateAging_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(Dem_Cfg_MemoryIndexType, DEM_CODE)
Dem_Mem_MemoryAllocateAging_Internal(
  DEM_MEM_MEMORYINFO_PARAMDEF_FIRST
  Dem_EventIdType  EventId
  )
{
  Dem_Cfg_MemoryIndexType lMemoryIndex;
  Dem_EventIdType lMasterEventId;

  lMasterEventId = Dem_Util_DtcGetMasterEvent(EventId);

  /* Find empty slot if possible, otherwise remove aged slot */
  if (Dem_Mem_MemoryGetMaxSize() == Dem_Mem_MemoryGetCurrentSize())
  { /* Memory is filled up -
     * Aged environmental data is not displaced, the remaining slots (if any)
     * are still used -> no chance to allocate an aging counter */
    lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;
  }
  else
  { /* Memory is not full -> Find first free entry */
    lMemoryIndex = Dem_Mem_MemoryFindIndex(DEM_EVENT_INVALID);
    /* if not found : lMemoryIndex == DEM_MEM_INVALID_MEMORY_INDEX */
  }

  if (lMemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX)
  {
    uint8 lMemorySize;
    Dem_Mem_EntryPtrType lMemoryEntry;

    lMemorySize = Dem_Mem_MemoryGetCurrentSize();
    lMemoryEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);                                                                         /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */

    /* At this point, the event memory is not completely filled */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
    if (lMemorySize >= Dem_Mem_MemoryGetMaxSize())
    {
      lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;
    }
    else
# endif
    {
      /* fill the chrono record with event id and lock the referenced PriMem slot */
      Dem_Mem_EntrySetTimestamp(lMemoryEntry, Dem_Mem_CurrentTimestamp);
      Dem_Mem_MemorySetChronology(lMemorySize, lMemoryIndex);                                                                    /* PRQA S 3689 */ /* MD_DEM_21.1 */

      Dem_Mem_EntrySetEventId(lMemoryEntry, lMasterEventId);                                                                     /* PRQA S 0505 */ /* MD_DEM_1.2 */

      /* Data */
      Dem_Data_EntryInit(lMemoryEntry);
      Dem_Mem_EntrySetState(lMemoryEntry, DEM_MEM_SET_AGING_ONLY(0));

      Dem_Mem_CurrentTimestamp = (uint32)(Dem_Mem_CurrentTimestamp + 1);
      Dem_Mem_MemorySetCurrentSize((uint8)(lMemorySize + 1));
    }
  }

  return lMemoryIndex;
}
#endif /* (DEM_FEATURE_NEED_AGING_REALLOCATION == STD_ON) */

/* ****************************************************************************
 % Dem_Mem_MemoryFreeIndex_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Mem_MemoryFreeIndex_Internal(
  DEM_MEM_MEMORYINFO_PARAMDEF_FIRST
  uint8  MemoryIndex
  )
{
  /* reduce count of used elements in the chrono stack */
  uint8 lChronoIterator;
  uint8 lTempChronoIndex;

  lChronoIterator = Dem_Mem_MemoryGetCurrentSize();
  --lChronoIterator;

  Dem_Mem_MemorySetCurrentSize(lChronoIterator);

  /* free the primary element */
  Dem_Mem_EntrySetEventId(Dem_Mem_MemoryGetEntry(MemoryIndex), DEM_EVENT_INVALID);                                               /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
  Dem_Mem_EntrySetTimestamp(Dem_Mem_MemoryGetEntry(MemoryIndex), 0);                                                             /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */

  /* go backwards through the chronological list and move down all entries, until the deleted element is overwritten */
  lTempChronoIndex = Dem_Mem_MemoryGetChronology(lChronoIterator);
  /* since we are guaranteed to find this entry somewhere, no need to check for chronoIter >= 0 */
  while (lTempChronoIndex != MemoryIndex)
  {
    uint8 lSwap;

    lSwap = lTempChronoIndex;

    --lChronoIterator;
    lTempChronoIndex = Dem_Mem_MemoryGetChronology(lChronoIterator);
    Dem_Mem_MemorySetChronology(lChronoIterator, lSwap);
  }
}

/* ****************************************************************************
 % Dem_Mem_MemoryFindIndex_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(uint8, DEM_CODE)
Dem_Mem_MemoryFindIndex_Internal(
  DEM_MEM_MEMORYINFO_PARAMDEF_FIRST
  Dem_EventIdType  EventId
  )
{
  Dem_EventIdType lMasterEventId;
  Dem_Cfg_MemoryIndexType lMemoryIndex;
  Dem_Cfg_MemoryIndexType lMemoryIndexEnd;

  lMasterEventId = Dem_Util_DtcGetMasterEvent(EventId);

  /* Iteration direction must be identical to Dem_Init! */

  lMemoryIndex = Dem_Mem_MemoryIndex_Begin();
  lMemoryIndexEnd = Dem_Mem_MemoryIndex_End();
  while ( (lMemoryIndex < lMemoryIndexEnd)
       && (Dem_Mem_EntryGetEventId(Dem_Mem_MemoryGetEntry(lMemoryIndex)) != lMasterEventId) )                                    /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
  {
    ++lMemoryIndex;
  }
  /* if not found, return DEM_MEM_INVALID_MEMORY_INDEX */
  if (lMemoryIndex >= lMemoryIndexEnd)
  {
    lMemoryIndex = DEM_MEM_INVALID_MEMORY_INDEX;
  }
  return lMemoryIndex;
}

                                               /* Event Status Manager [ESM] */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 % Dem_Esm_CounterBasedCalculate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_CounterBasedCalculate(
  Dem_DebounceInfoPtrType  DebounceInfo
  )
{
  boolean lReturnValue;
  boolean lEnableConditionsSatisfied;
# if (DEM_FEATURE_NEED_JUMPDOWN == STD_ON) || (DEM_FEATURE_NEED_JUMPUP == STD_ON)
  sint16 lJumpToValue;
# endif

  lEnableConditionsSatisfied = (boolean)
    ((Dem_CurrentEnableConditionStates & Dem_Cfg_EventEnableConditions(DebounceInfo->Common.EventId)) == Dem_Cfg_EventEnableConditions(DebounceInfo->Common.EventId));

# if (DEM_FEATURE_NEED_DEBOUNCEDISABLE == STD_ON)
  if ( (lEnableConditionsSatisfied == TRUE)
#  if (DEM_CFG_ISCONST_DEBOUNCECONTINUOUS == STD_OFF)
    || (Dem_Cfg_EventDebounceContinuous(DebounceInfo->Common.EventId) == TRUE)
#  endif
    )
# endif
  {
    DebounceInfo->Specific.CounterBased.OldDebounceValue = Dem_Mem_EventGetDebounceValue(DebounceInfo->Common.EventId);
# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
    DebounceInfo->Specific.CounterBased.OldInternalStatus = Dem_Mem_EventGetInternalStatus(DebounceInfo->Common.EventId);
    DebounceInfo->Specific.CounterBased.NewInternalStatus = DebounceInfo->Specific.CounterBased.OldInternalStatus;
# endif

    switch (DebounceInfo->Common.MonitorStatus)
    {
    case DEM_EVENT_STATUS_PREPASSED:
# if (DEM_FEATURE_NEED_JUMPDOWN == STD_ON)
      lJumpToValue = Dem_Cfg_EventJumpDownValue(DebounceInfo->Common.EventId);

      if ((DebounceInfo->Specific.CounterBased.OldDebounceValue > lJumpToValue)
#  if (DEM_FEATURE_NEED_EVENT_JUMPDOWN == STD_ON)
        && (FALSE != Dem_Cfg_EventSupportJumpDown(DebounceInfo->Common.EventId))
#  endif
        )
      {
        /* JumpDown */
        DebounceInfo->Specific.CounterBased.NewDebounceValue = lJumpToValue;
      }
      else
# endif /* (DEM_FEATURE_NEED_JUMPDOWN == STD_ON) */
      {
        DebounceInfo->Specific.CounterBased.NewDebounceValue = DebounceInfo->Specific.CounterBased.OldDebounceValue;
      }

      if (DebounceInfo->Specific.CounterBased.NewDebounceValue <=
        (Dem_Cfg_EventPassedTarget(DebounceInfo->Common.EventId) - Dem_Cfg_EventPrepassedStep(DebounceInfo->Common.EventId))) /* No overflow possible */
      {
        DebounceInfo->Specific.CounterBased.NewDebounceValue = Dem_Cfg_EventPassedTarget(DebounceInfo->Common.EventId);
# if (DEM_CFG_ISCONST_DEBOUNCECONTINUOUS == STD_OFF)
        if (lEnableConditionsSatisfied == TRUE)
# endif
        {
          /* qualified result, set result and final debounce counter */
          DebounceInfo->Common.MonitorStatus = DEM_EVENT_STATUS_PASSED;
        }
      }
      else
      {
        DebounceInfo->Specific.CounterBased.NewDebounceValue = (sint16)
          (DebounceInfo->Specific.CounterBased.NewDebounceValue + Dem_Cfg_EventPrepassedStep(DebounceInfo->Common.EventId)); /* No overflow possible */
      }
      break;

    case DEM_EVENT_STATUS_PASSED:
      /* Qualified result - directly load threshold debounce counter from configuration */
      /* This also reduces exceeded counter values to match the passed threshold exactly (latch at bottom) */
      DebounceInfo->Specific.CounterBased.NewDebounceValue = Dem_Cfg_EventPassedTarget(DebounceInfo->Common.EventId);
# if (DEM_CFG_ISCONST_DEBOUNCECONTINUOUS == STD_OFF)
      if (lEnableConditionsSatisfied == FALSE)
      {
        DebounceInfo->Common.MonitorStatus = DEM_EVENT_STATUS_PREPASSED;
      }
# endif
      break;

    case DEM_EVENT_STATUS_PREFAILED:
# if (DEM_FEATURE_NEED_JUMPUP == STD_ON)
      lJumpToValue = Dem_Cfg_EventJumpUpValue(DebounceInfo->Common.EventId);

      if ((DebounceInfo->Specific.CounterBased.OldDebounceValue < lJumpToValue)
#  if (DEM_FEATURE_NEED_EVENT_JUMPUP == STD_ON)
        && (FALSE != Dem_Cfg_EventSupportJumpUp(DebounceInfo->Common.EventId))
#  endif
        )
      {
        /* JumpUp */
        DebounceInfo->Specific.CounterBased.NewDebounceValue = lJumpToValue;
      }
      else
# endif /* (DEM_FEATURE_NEED_JUMPUP == STD_ON) */
      {
        DebounceInfo->Specific.CounterBased.NewDebounceValue = DebounceInfo->Specific.CounterBased.OldDebounceValue;
      }

      if (DebounceInfo->Specific.CounterBased.NewDebounceValue >=
        (Dem_Cfg_EventFailedTarget(DebounceInfo->Common.EventId) - Dem_Cfg_EventPrefailedStep(DebounceInfo->Common.EventId))) /* No overflow possible */
      {
        /* qualified result, set result and final debounce counter */
        DebounceInfo->Specific.CounterBased.NewDebounceValue = Dem_Cfg_EventFailedTarget(DebounceInfo->Common.EventId);
# if (DEM_CFG_ISCONST_DEBOUNCECONTINUOUS == STD_OFF)
        if (lEnableConditionsSatisfied == TRUE)
# endif
        {
          DebounceInfo->Common.MonitorStatus = DEM_EVENT_STATUS_FAILED;
        }
      }
      else
      {
        DebounceInfo->Specific.CounterBased.NewDebounceValue = (sint16)
          (DebounceInfo->Specific.CounterBased.NewDebounceValue + Dem_Cfg_EventPrefailedStep(DebounceInfo->Common.EventId));  /* No overflow possible */
      }
      break;

    case DEM_EVENT_STATUS_FAILED:
      /* Qualified result - directly load threshold debounce counter from configuration */
      /* This also reduces counter values to match the failed threshold exactly (latch at ceiling) */
      DebounceInfo->Specific.CounterBased.NewDebounceValue = Dem_Cfg_EventFailedTarget(DebounceInfo->Common.EventId);
# if (DEM_CFG_ISCONST_DEBOUNCECONTINUOUS == STD_OFF)
      if (lEnableConditionsSatisfied == FALSE)
      {
        DebounceInfo->Common.MonitorStatus = DEM_EVENT_STATUS_PREFAILED;
      }
# endif
      break;

    default:
      /* Satisfy Misra */
      break;
    }

#if (DEM_CFG_SUPPORT_RETRY_STORAGE == STD_ON)
    if ( (DebounceInfo->Common.MonitorStatus == DEM_EVENT_STATUS_FAILED)
      && (DEM_ESM_GET_STORED_STATUS(Dem_Util_DtcGetInternalStatus(DebounceInfo->Common.EventId)) == DEM_ESM_STORED_STATUS_NONE))
    {
      DebounceInfo->Common.DebouncingChanged = TRUE;
    }
    else
#endif
    {
      DebounceInfo->Common.DebouncingChanged =
        (boolean)(DebounceInfo->Specific.CounterBased.OldDebounceValue != DebounceInfo->Specific.CounterBased.NewDebounceValue);
    }

# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
    DebounceInfo->Common.RequestProcessing = FALSE;

#  if (DEM_CFG_STORAGE_AT_FDC == STD_ON) || (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
#   if (DEM_CFG_ISCONST_DEBOUNCECONTINUOUS == STD_OFF)
    if (lEnableConditionsSatisfied == TRUE)
#   endif
    {
#   if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
      if ( (DebounceInfo->Specific.CounterBased.NewDebounceValue >= Dem_Cfg_EventStorageTarget(DebounceInfo->Common.EventId))
        && (DebounceInfo->Specific.CounterBased.OldDebounceValue < Dem_Cfg_EventStorageTarget(DebounceInfo->Common.EventId)) )
      {
        DebounceInfo->Specific.CounterBased.NewInternalStatus = DEM_ESM_SET_FDC_TRIP(DebounceInfo->Specific.CounterBased.NewInternalStatus);
        DebounceInfo->Common.RequestProcessing = TRUE;
      }
#   endif
#   if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
      /* Possible update of SLC based on update of TOC */
      if (DebounceInfo->Specific.CounterBased.NewDebounceValue > Dem_Mem_EventGetDebounceValueMax(DebounceInfo->Common.EventId))
      {
        DebounceInfo->Specific.CounterBased.NewInternalStatus = DEM_ESM_SET_FDC_MAX(DebounceInfo->Specific.CounterBased.NewInternalStatus);
        DebounceInfo->Common.RequestProcessing = TRUE;
      }
#   endif
    }
#  endif
# endif
    lReturnValue = TRUE;
  } /* (lEnableConditionsSatisfied == TRUE) || (Dem_Cfg_EventDebounceContinuous(DebounceInfo->Common.EventId) == TRUE) */
  else
  {
    lReturnValue = FALSE;
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 % Dem_Esm_CounterBasedValidate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_CounterBasedValidate(
  Dem_DebounceInfoPtrType  DebounceInfo                                                                                          /* PRQA S 3673 */ /* MD_DEM_16.7_Internal */
  )
{
  return (boolean) (
      (DebounceInfo->Specific.CounterBased.OldDebounceValue == Dem_Mem_EventGetDebounceValue(DebounceInfo->Common.EventId))
#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
   && (DebounceInfo->Specific.CounterBased.OldInternalStatus == Dem_Mem_EventGetInternalStatus(DebounceInfo->Common.EventId))
#endif
  );
}
#endif /* (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON) */

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 % Dem_Esm_CounterBasedCommit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_CounterBasedCommit(
  Dem_DebounceInfoPtrType  DebounceInfo                                                                                          /* PRQA S 3673 */ /* MD_DEM_16.7_Internal */
  )
{
  Dem_Mem_EventSetDebounceValue(DebounceInfo->Common.EventId, DebounceInfo->Specific.CounterBased.NewDebounceValue);
# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  Dem_Mem_EventSetInternalStatus(DebounceInfo->Common.EventId, DebounceInfo->Specific.CounterBased.NewInternalStatus);
# endif
# if (DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE == STD_ON)
  /* Store a new max value */
  if (DebounceInfo->Specific.CounterBased.NewDebounceValue > Dem_Mem_EventGetDebounceValueMax(DebounceInfo->Common.EventId))
  {
    Dem_Mem_EventSetDebounceValueMax(DebounceInfo->Common.EventId, DebounceInfo->Specific.CounterBased.NewDebounceValue);
  }
# endif
}
#endif /* (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON) */

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 % Dem_Esm_CounterBasedFreeze
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_CounterBasedFreeze(
  Dem_DebounceInfoPtrType  DebounceInfo                                                                                          /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
  DEM_IGNORE_UNUSED_ARGUMENT(DebounceInfo)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
  /* No action necessary */
}
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
/* ****************************************************************************
 % Dem_Esm_CounterBasedReset
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_CounterBasedReset(
  Dem_DebounceInfoPtrType  DebounceInfo                                                                                          /* PRQA S 3673 */ /* MD_DEM_16.7_Internal */
  )
{
/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  Dem_Mem_EventSetDebounceValue(DebounceInfo->Common.EventId, 0);

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
}
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Esm_TimeBasedCalculate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_TimeBasedCalculate(
  Dem_DebounceInfoPtrType  DebounceInfo
  )
{
  boolean lReturnValue;
  boolean lEnableConditionsSatisfied;

  lEnableConditionsSatisfied = (boolean)
    ((Dem_CurrentEnableConditionStates & Dem_Cfg_EventEnableConditions(DebounceInfo->Common.EventId)) == Dem_Cfg_EventEnableConditions(DebounceInfo->Common.EventId));

# if (DEM_FEATURE_NEED_DEBOUNCEDISABLE == STD_ON)
  if ( (lEnableConditionsSatisfied == TRUE)
#  if (DEM_CFG_ISCONST_DEBOUNCECONTINUOUS == STD_OFF)
    || (Dem_Cfg_EventDebounceContinuous(DebounceInfo->Common.EventId) == TRUE)
#  endif
    )
# endif
  {
    DebounceInfo->Specific.TimeBased.OldInternalStatus = Dem_Mem_EventGetInternalStatus(DebounceInfo->Common.EventId);
    DebounceInfo->Specific.TimeBased.NewInternalStatus = DebounceInfo->Specific.TimeBased.OldInternalStatus;
# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
    DebounceInfo->Common.RequestProcessing = FALSE;
# endif

    switch (DebounceInfo->Common.MonitorStatus)
    {
    case DEM_EVENT_STATUS_PREPASSED:
      /* ignore action if timer is still running in direction of prepassed or event is qualified as passed */
      if ((DEM_ESM_DEBOUNCE_STATUS_NONE == DEM_ESM_GET_DEBOUNCE_STATUS(DebounceInfo->Specific.TimeBased.OldInternalStatus))
        || (DEM_ESM_DEBOUNCE_DIR_PASSED != DEM_ESM_TEST_DEBOUNCE_DIR(DebounceInfo->Specific.TimeBased.OldInternalStatus)))
      {
        DebounceInfo->Specific.TimeBased.NewInternalStatus =
          DEM_ESM_SET_DEBOUNCE_STATUS(DebounceInfo->Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_RESET_PASSED);
      }
      else
      if (DEM_ESM_DEBOUNCE_FREEZE_PASSED == DEM_ESM_GET_DEBOUNCE_STATUS(DebounceInfo->Specific.TimeBased.OldInternalStatus))
      {
        DebounceInfo->Specific.TimeBased.NewInternalStatus =
          DEM_ESM_SET_DEBOUNCE_STATUS(DebounceInfo->Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_COUNT_PASSED);
      }
      else
      { /* Nothing to do */
      }
      break;

    case DEM_EVENT_STATUS_PREFAILED:
      /* ignore action if timer is still running in direction of prefailed or event is still qualified as failed */
      /* Test for debounce status == none is redundant with test for last bit != 0. Test removed due to avoid compiler warning */
      if (DEM_ESM_DEBOUNCE_DIR_PASSED == DEM_ESM_TEST_DEBOUNCE_DIR(DebounceInfo->Specific.TimeBased.OldInternalStatus))
      {
        DebounceInfo->Specific.TimeBased.NewInternalStatus =
          DEM_ESM_SET_DEBOUNCE_STATUS(DebounceInfo->Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_RESET_FAILED);
      }
      else
      if (DEM_ESM_DEBOUNCE_FREEZE_FAILED == DEM_ESM_GET_DEBOUNCE_STATUS(DebounceInfo->Specific.TimeBased.OldInternalStatus))
      {
        DebounceInfo->Specific.TimeBased.NewInternalStatus =
          DEM_ESM_SET_DEBOUNCE_STATUS(DebounceInfo->Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_COUNT_FAILED);
      }
# if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
      else
      if (DEM_ESM_DEBOUNCE_FREEZE_FAILED_FDC == DEM_ESM_GET_DEBOUNCE_STATUS(DebounceInfo->Specific.TimeBased.OldInternalStatus))
      {
        DebounceInfo->Specific.TimeBased.NewInternalStatus =
          DEM_ESM_SET_DEBOUNCE_STATUS(DebounceInfo->Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_COUNT_FAILED_FDC);
      }
# endif
      else
      { /* Nothing to do */
      }
      break;

    case DEM_EVENT_STATUS_PASSED:
      DebounceInfo->Specific.TimeBased.NewInternalStatus =
        DEM_ESM_SET_DEBOUNCE_STATUS(DebounceInfo->Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_DONE_PASSED);
# if (DEM_CFG_ISCONST_DEBOUNCECONTINUOUS == STD_OFF)
      if (lEnableConditionsSatisfied == FALSE)
      {
        DebounceInfo->Common.MonitorStatus = DEM_EVENT_STATUS_PREPASSED;
      }
# endif
      break;

    case DEM_EVENT_STATUS_FAILED:
      DebounceInfo->Specific.TimeBased.NewInternalStatus =
        DEM_ESM_SET_DEBOUNCE_STATUS(DebounceInfo->Specific.TimeBased.NewInternalStatus, DEM_ESM_DEBOUNCE_DONE_FAILED);
# if (DEM_CFG_ISCONST_DEBOUNCECONTINUOUS == STD_OFF)
      if (lEnableConditionsSatisfied == FALSE)
      {
        DebounceInfo->Common.MonitorStatus = DEM_EVENT_STATUS_PREFAILED;
      }
      else
# endif
      {
# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
        if ( (DEM_ESM_DEBOUNCE_DIR_PASSED == DEM_ESM_TEST_DEBOUNCE_DIR(DebounceInfo->Specific.TimeBased.OldInternalStatus))
          || (DEM_ESM_DEBOUNCE_FREEZE_FAILED == DEM_ESM_GET_DEBOUNCE_STATUS(DebounceInfo->Specific.TimeBased.OldInternalStatus))
          || (DEM_ESM_DEBOUNCE_COUNT_FAILED == DEM_ESM_GET_DEBOUNCE_STATUS(DebounceInfo->Specific.TimeBased.OldInternalStatus)))
        {
#  if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
          DebounceInfo->Specific.TimeBased.NewInternalStatus = DEM_ESM_SET_FDC_TRIP(DebounceInfo->Specific.TimeBased.NewInternalStatus);
#  endif
#  if (DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE == STD_ON)
          DebounceInfo->Specific.TimeBased.NewInternalStatus = DEM_ESM_SET_FDC_MAX(DebounceInfo->Specific.TimeBased.NewInternalStatus);
#  endif
          DebounceInfo->Common.RequestProcessing = TRUE;
        }
# endif
      }
      break;

    default:
      /* Satisfy Misra */
      break;
    }

    DebounceInfo->Common.DebouncingChanged =
      (boolean)(DebounceInfo->Specific.TimeBased.OldInternalStatus != DebounceInfo->Specific.TimeBased.NewInternalStatus);

# if (DEM_CFG_SUPPORT_RETRY_STORAGE == STD_ON)
    if ( (DebounceInfo->Common.DebouncingChanged == FALSE)
#  if (DEM_CFG_ISCONST_DEBOUNCECONTINUOUS == STD_OFF)
      && (lEnableConditionsSatisfied == TRUE)
#  endif
      && (DEM_ESM_GET_DEBOUNCE_STATUS(DebounceInfo->Specific.TimeBased.OldInternalStatus) == DEM_ESM_DEBOUNCE_DONE_FAILED)
      && (DEM_ESM_GET_STORED_STATUS(Dem_Util_DtcGetInternalStatus(DebounceInfo->Common.EventId)) == DEM_ESM_STORED_STATUS_NONE) )
    {
      DebounceInfo->Common.MonitorStatus = DEM_EVENT_STATUS_FAILED;
      DebounceInfo->Common.DebouncingChanged = TRUE;
    }
# endif

    lReturnValue = TRUE;
  }
  else
  {
    lReturnValue = FALSE;
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Esm_TimeBasedValidate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_TimeBasedValidate(
  Dem_DebounceInfoPtrType  DebounceInfo                                                                                          /* PRQA S 3673 */ /* MD_DEM_16.7_Internal */
  )
{
  return (boolean)(DebounceInfo->Specific.TimeBased.OldInternalStatus == Dem_Mem_EventGetInternalStatus(DebounceInfo->Common.EventId));
}
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Esm_TimeBasedCommit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_TimeBasedCommit(
  Dem_DebounceInfoPtrType  DebounceInfo                                                                                          /* PRQA S 3673 */ /* MD_DEM_16.7_Internal */
  )
{
  Dem_Mem_EventSetInternalStatus(DebounceInfo->Common.EventId, DebounceInfo->Specific.TimeBased.NewInternalStatus);
# if (DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE == STD_ON)
  /* Store a new max value if the event was reported 'failed' immediately */
  if ( (DebounceInfo->Specific.TimeBased.NewInternalStatus != DebounceInfo->Specific.TimeBased.OldInternalStatus)
    && (FALSE != DEM_ESM_TEST_FDC_MAX(DebounceInfo->Specific.TimeBased.NewInternalStatus)) )
  {
    Dem_Mem_EventSetDebounceValueMax(DebounceInfo->Common.EventId, 0);
  }
# endif
}
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Esm_TimeBasedFreeze
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_TimeBasedFreeze(
  Dem_DebounceInfoPtrType  DebounceInfo                                                                                          /* PRQA S 3673 */ /* MD_DEM_16.7_Internal */
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lInternalStatus = Dem_Mem_EventGetInternalStatus(DebounceInfo->Common.EventId);

  switch (DEM_ESM_GET_DEBOUNCE_STATUS(lInternalStatus))
  {
  case DEM_ESM_DEBOUNCE_RESET_FAILED:
    Dem_Mem_EventSetDebounceValue(DebounceInfo->Common.EventId, Dem_Cfg_EventFailedTime(DebounceInfo->Common.EventId));
    lInternalStatus = DEM_ESM_SET_DEBOUNCE_STATUS(lInternalStatus, DEM_ESM_DEBOUNCE_FREEZE_FAILED);
    break;

  case DEM_ESM_DEBOUNCE_RESET_PASSED:
    Dem_Mem_EventSetDebounceValue(DebounceInfo->Common.EventId, Dem_Cfg_EventPassedTime(DebounceInfo->Common.EventId));
    lInternalStatus = DEM_ESM_SET_DEBOUNCE_STATUS(lInternalStatus, DEM_ESM_DEBOUNCE_FREEZE_PASSED);
    break;

  case DEM_ESM_DEBOUNCE_COUNT_FAILED:
    lInternalStatus = DEM_ESM_SET_DEBOUNCE_STATUS(lInternalStatus, DEM_ESM_DEBOUNCE_FREEZE_FAILED);
    break;

  case DEM_ESM_DEBOUNCE_COUNT_PASSED:
    lInternalStatus = DEM_ESM_SET_DEBOUNCE_STATUS(lInternalStatus, DEM_ESM_DEBOUNCE_FREEZE_PASSED);
    break;
# if (DEM_CFG_STORAGE_AT_FDC == STD_ON)
  case DEM_ESM_DEBOUNCE_COUNT_FAILED_FDC:
    lInternalStatus = DEM_ESM_SET_DEBOUNCE_STATUS(lInternalStatus, DEM_ESM_DEBOUNCE_FREEZE_FAILED_FDC);
    break;
# endif
  default:
    /* Nothing to do */
    break;
  }

  Dem_Mem_EventSetInternalStatus(DebounceInfo->Common.EventId, lInternalStatus);

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
}
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_Esm_TimeBasedReset
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_TimeBasedReset(
  Dem_DebounceInfoPtrType  DebounceInfo                                                                                          /* PRQA S 3673 */ /* MD_DEM_16.7_Internal */
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;

/* >>>> -------------------------------- Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lInternalStatus = Dem_Mem_EventGetInternalStatus(DebounceInfo->Common.EventId);
  lInternalStatus = DEM_ESM_SET_DEBOUNCE_STATUS(lInternalStatus, DEM_ESM_DEBOUNCE_STATUS_NONE);
  Dem_Mem_EventSetInternalStatus(DebounceInfo->Common.EventId, lInternalStatus);
  Dem_Mem_EventSetDebounceValue(DebounceInfo->Common.EventId, 0);

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<< -------------------------------- Leave Critical Section: DiagMonitor */
}
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
/* ****************************************************************************
 % Dem_Esm_MonitorInternalCalculate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_MonitorInternalCalculate(
  Dem_DebounceInfoPtrType  DebounceInfo
  )
{
  boolean lReturnValue;

# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  DebounceInfo->Common.RequestProcessing = FALSE;
# endif

  /* No debouncing for this event supported */
  if ( (DebounceInfo->Common.MonitorStatus == DEM_EVENT_STATUS_PREPASSED)
    || (DebounceInfo->Common.MonitorStatus == DEM_EVENT_STATUS_PREFAILED) )
  {
    Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_PARAM_DATA)

    DebounceInfo->Common.DebouncingChanged = FALSE;
    lReturnValue = FALSE;
  }
  else
  {
    lReturnValue = (boolean)
      ((Dem_CurrentEnableConditionStates & Dem_Cfg_EventEnableConditions(DebounceInfo->Common.EventId)) == Dem_Cfg_EventEnableConditions(DebounceInfo->Common.EventId));

    if (lReturnValue == TRUE)
    {
      DebounceInfo->Common.DebouncingChanged = TRUE;
    }
  }
  return lReturnValue;
}
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
/* ****************************************************************************
 % Dem_Esm_DebounceNoOpBoolean
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_DebounceNoOpBoolean(
  Dem_DebounceInfoPtrType  DebounceInfo                                                                                          /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
  DEM_IGNORE_UNUSED_ARGUMENT(DebounceInfo)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
  return TRUE;
}
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
/* ****************************************************************************
 % Dem_Esm_DebounceNoOpVoid
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_DebounceNoOpVoid(
  Dem_DebounceInfoPtrType  DebounceInfo                                                                                          /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
  DEM_IGNORE_UNUSED_ARGUMENT(DebounceInfo)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
}
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_INVALID == STD_ON)
/* ****************************************************************************
 % Dem_Esm_DebounceInvalidCalculate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_DebounceInvalidCalculate(
  Dem_DebounceInfoPtrType  DebounceInfo
  )
{
  DebounceInfo->Common.DebouncingChanged = FALSE;
# if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  DebounceInfo->Common.RequestProcessing = FALSE;
# endif
  Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_PARAM_CONFIG)
  return FALSE;
}
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_INVALID == STD_ON)
/* ****************************************************************************
 % Dem_Esm_DebounceInvalidBoolean
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Esm_DebounceInvalidBoolean(
  Dem_DebounceInfoPtrType  DebounceInfo                                                                                          /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
  DEM_IGNORE_UNUSED_ARGUMENT(DebounceInfo)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
  Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_PARAM_CONFIG)
  return TRUE;
}
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE_INVALID == STD_ON)
/* ****************************************************************************
 % Dem_Esm_DebounceInvalidVoid
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_DebounceInvalidVoid(
  Dem_DebounceInfoPtrType  DebounceInfo                                                                                          /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
  DEM_IGNORE_UNUSED_ARGUMENT(DebounceInfo)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
  Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_PARAM_CONFIG)
}
#endif

/* ****************************************************************************
 % Dem_Esm_EventFailed_Queued
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 *
 *
 *
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_Queued(
  Dem_EventIdType  EventId
  )
{
  uint8 lOldEventStatus;
  uint8 lNewEventStatus;
  uint8 lEventEffects;
  uint8 lDtcEffects;
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  uint8 lOldDtcStatus;
  uint8 lNewDtcStatus;
#endif

  lOldEventStatus = Dem_Mem_EventGetStatus(EventId);
  lNewEventStatus = lOldEventStatus;
  lEventEffects = DEM_CFG_TRIGGER_NONE;
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  lDtcEffects = DEM_CFG_TRIGGER_NONE;
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
  lOldDtcStatus = Dem_Util_DtcGetStatus(EventId);
#endif

  /* #010 Process the deferred 'asynchronous' status bit transitions for the event */
  lNewEventStatus = DEM_ESM_SET_UDS_STATUS_TFTOC(lNewEventStatus);
  lNewEventStatus = DEM_ESM_SET_UDS_STATUS_TF(lNewEventStatus);
#if (DEM_CFG_PROCESS_TFSLC_STOREDONLY == STD_OFF)
  lNewEventStatus = DEM_ESM_SET_UDS_STATUS_TFSLC(lNewEventStatus);
#endif
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCSLC(lNewEventStatus);
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCTOC(lNewEventStatus);

  Dem_Mem_EventSetStatus(EventId, lNewEventStatus);

  /* #020 Derive the triggers for the event from the changes of the status bits */
  if (FALSE == DEM_ESM_TEST_UDS_STATUS_TF(lOldEventStatus))
  {
    lEventEffects = (uint8)(lEventEffects | DEM_CFG_TRIGGER_TESTFAILED);
  }
  if (FALSE == DEM_ESM_TEST_UDS_STATUS_TFTOC(lOldEventStatus))
  {
    lEventEffects = (uint8)(lEventEffects | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE);
    lEventEffects = (uint8)(lEventEffects | DEM_CFG_TRIGGER_FIRSTTHISCYCLE);
  }

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  /* #030 For combined events, calculate the new DTC status and derive the
   *      triggers for the DTC from the changes of the DTC status bits */
  if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
  {
    lNewDtcStatus = Dem_Data_CombinedGroupGetStatus(lGroupId);

    if (FALSE == DEM_ESM_TEST_UDS_STATUS_TF(lOldDtcStatus))
    {
      lDtcEffects = (uint8)(lDtcEffects | DEM_CFG_TRIGGER_TESTFAILED);
    }
    if (FALSE == DEM_ESM_TEST_UDS_STATUS_TFTOC(lOldDtcStatus))
    {
      lDtcEffects = (uint8)(lDtcEffects | (DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE | DEM_CFG_TRIGGER_FIRSTTHISCYCLE));
    }

    Dem_Mem_CombinedGroupSetStatus(lGroupId, lNewDtcStatus);
  }
  else
#endif
  {
    lDtcEffects = lEventEffects;
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
    lNewDtcStatus = lNewEventStatus;
#endif
  }

  DEM_NVM_CHECK_DIRTY_STATUS(lOldEventStatus, lNewEventStatus)

  if (lOldEventStatus != lNewEventStatus)
  {
# if (DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON)
    Dem_Cbk_StatusChanged(EventId, lOldEventStatus, lNewEventStatus);
# endif
# if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
#  if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
    Dem_Cbk_DtcStatusChanged(EventId, lOldDtcStatus, lNewDtcStatus);
#  else
    Dem_Cbk_DtcStatusChanged(EventId, lOldEventStatus, lNewEventStatus);
#  endif
# endif

    /* #050 Process the remaining 'synchronous' status changes and effects */
    Dem_Esm_EventFailed_Immediate(EventId, lEventEffects, lDtcEffects);
  }
#if (DEM_CFG_SUPPORT_RETRY_STORAGE == STD_ON)
  else
  {
    Dem_Esm_EventFailed_Immediate(EventId,
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE),
        (uint8)(DEM_CFG_TRIGGER_TESTFAILED | DEM_CFG_TRIGGER_FIRSTTHISCYCLE | DEM_CFG_TRIGGER_TESTFAILEDTHISCYCLE));
  }
#endif
}

/* ****************************************************************************
 % Dem_Esm_EventFailed_Immediate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventFailed_Immediate(
  Dem_EventIdType  EventId,
  uint8  EventEffects,
  uint8  DtcEffects                                                                                                              /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  Dem_Esm_EventContextType lEventContext;
#if (DEM_FEATURE_NEED_NOTIFY == STD_ON)
  boolean lDataModified;
#endif

  lEventContext.EventId = EventId;
  lEventContext.OldEventStatus = Dem_Mem_EventGetStatus(EventId);
  lEventContext.NewEventStatus = lEventContext.OldEventStatus;
  lEventContext.EventEffects = EventEffects;
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  lEventContext.GroupId = Dem_Cfg_EventCombinedGroup(EventId);
  lEventContext.OldDtcStatus = Dem_Util_DtcGetStatus(EventId);
  lEventContext.NewDtcStatus = lEventContext.OldDtcStatus;
  lEventContext.DtcEffects = DtcEffects;
#else
  DEM_IGNORE_UNUSED_ARGUMENT(DtcEffects)                                                                                         /* PRQA S 3112 */ /* MD_DEM_14.2 */
#endif

  /* Process synchronous updates for externally visible events, if storage conditions are fulfilled */
  if ( (DEM_CFG_DTC_UDS_INVALID != Dem_Cfg_EventUdsDtc(EventId))
#if (DEM_CFG_SUPPORT_STORAGE_CONDITIONS == STD_ON)
    && ((Dem_StorageConditionStates & Dem_Cfg_EventStorageConditions(EventId)) == Dem_Cfg_EventStorageConditions(EventId))
#endif
    )
  {
    Dem_Esm_EventFailed_ProcessPending(&lEventContext);
    Dem_Esm_EventFailed_ProcessConfirmed(&lEventContext);

#if (DEM_FEATURE_NEED_NOTIFY == STD_ON)
    lDataModified = Dem_Esm_EventFailed_ProcessStorage(&lEventContext);
#else
    (void)Dem_Esm_EventFailed_ProcessStorage(&lEventContext);
#endif

    /* Commit changes to the event status to memory */
    if (DEM_CFG_TRIGGER_NONE != lEventContext.EventEffects)
    {
      Dem_Esm_EventFailed_CommitToMemory(&lEventContext);
    }

#if (DEM_FEATURE_NEED_NOTIFY == STD_ON)
    Dem_Esm_EventFailed_ProcessNotifications(&lEventContext, lDataModified);
#endif

    Dem_Data_EventFailed(EventId, Dem_Esm_SelectStorageEffects(&lEventContext));

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
    Dem_Esm_PrestorageDiscard();
#endif
    Dem_Mem_StatusSetBlockState(DEM_NVM_BLOCKSTATE_DIRTY);
  }
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Esm_CycleUpdate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_CycleUpdate(
  uint8  CycleId,
  uint8  CycleStatus
  )
{
  uint16 lCycleCounter;

  Dem_Mem_SetCycleStatus(CycleId, DEM_QUEUE_CYCLE_STOPPED);

  /* Tick the cycle if necessary */
  lCycleCounter = Dem_Mem_GetCycleCounter(CycleId);
  if ((CycleStatus & DEM_QUEUE_CYCLE_STARTED) != 0U)
  {
    lCycleCounter = Dem_Esm_AddCycleCount(lCycleCounter, 1U);
    Dem_Mem_SetCycleCounter(CycleId, lCycleCounter);

    /* Aging cycle start */
    Dem_Esm_CycleUpdateAging(CycleId, lCycleCounter);
  }

  /* Operation Cycle start / end */
  Dem_Esm_CycleUpdateReadiness(CycleId, CycleStatus);

  if ((CycleStatus & DEM_QUEUE_CYCLE_STARTED) != 0U)
  {
    Dem_Mem_SetCycleStatus(CycleId, DEM_QUEUE_CYCLE_STARTED);

  } /* (CycleStatus & DEM_QUEUE_CYCLE_STARTED) != 0U) */

}                                                                                                                                /* PRQA S 6010, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCAL */

#if (DEM_FEATURE_NEED_AGING_CYCLE_DISTANCE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_CycleCountDistance
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(uint16, DEM_CODE)
Dem_Esm_CycleCountDistance(
  uint16  CurrentCounter,
  uint16  TargetCounter
  )
{
  uint16 lReturnValue;

  if (TargetCounter < CurrentCounter)
  {
    lReturnValue = (uint16)((DEM_ESM_CYCLECOUNT_MAX - CurrentCounter) + TargetCounter);
  }
  else
  {
    lReturnValue = (uint16)(TargetCounter - CurrentCounter);
  }

  return lReturnValue;
}
#endif

/* ****************************************************************************
 % Dem_Esm_EventOpCycle_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventOpCycle_Internal(
  Dem_EventIdType  EventId,
  Dem_Util_ForEachCombinedArgPtrType  ArgPtr                                                                                     /* PRQA S 3673 */ /* MD_DEM_16.7_Internal */
)
{
  uint8 lOldStatus;
  uint8 lNewStatus;

  lOldStatus = Dem_Mem_EventGetStatus(EventId);

  if ((ArgPtr->Specific.EventOpCycle_Internal.CycleStatus & DEM_QUEUE_CYCLE_STOPPED) != 0U)
  {
    Dem_Esm_EventOpCycleEnd(EventId, ArgPtr->Common.OldDtcStatus);
  }
  if ((ArgPtr->Specific.EventOpCycle_Internal.CycleStatus & DEM_QUEUE_CYCLE_STARTED) != 0U)
  {
    Dem_Esm_EventOpCycleStart(EventId);
  }
  lNewStatus = Dem_Mem_EventGetStatus(EventId);

  DEM_NVM_CHECK_DIRTY_STATUS(lOldStatus, lNewStatus)

#if ((DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON) || (DEM_CFG_NOTIFY_INIT_MONITOR == STD_ON))
  if (Dem_InitState == DEM_INIT_INITIALIZED)
  {
# if (DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON)
    if (lOldStatus != lNewStatus)
    { /* Call notifications only if event status has changed */
      Dem_Cbk_StatusChanged(EventId, lOldStatus, lNewStatus);
    }
# endif
# if (DEM_CFG_NOTIFY_INIT_MONITOR == STD_ON)
    /* Call Init Monitor Callbacks */
    Dem_Cbk_InitMonitorForEvent(EventId, DEM_INIT_MONITOR_RESTART);
# endif
  }
#endif
}

/* ****************************************************************************
 % Dem_Esm_EventUpdateAsync_Queued
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventUpdateAsync_Queued(
  Dem_EventIdType  EventId,
  Dem_EventStatusType  EventStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_DebounceInfoType lDebounceInfo;

  lReturnValue = E_OK;
  Dem_Esm_DebounceInfoInit(EventId, &lDebounceInfo);

  /* Possible concurrent modification :
     ClearEvent
     ResetEventStatus
     Displacement
     Aging */

  for (;;)
  {
    /* Perform all calculations on the stack. Original values are preserved
      * to detect concurrent modification.*/
    lDebounceInfo.Common.MonitorStatus = EventStatus;
    if (FALSE == lDebounceInfo.Common.FunctionTable->Calculate(&lDebounceInfo))
    { /* Error, abort */
      lReturnValue = E_NOT_OK;
      break;                                                                                                                     /* PRQA S 0771 */ /* MD_DEM_14.6_err */
    }

    if (FALSE != lDebounceInfo.Common.DebouncingChanged)
    {
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
      Dem_EnterCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */

      /* Verify the 'old' status we had based the status calculations on is
       * still the same as before */
      if (FALSE == lDebounceInfo.Common.FunctionTable->Validate(&lDebounceInfo))
      {
        /* Concurrent modification requires to repeat all calculations with
          * the new up-to-date values */
        Dem_LeaveCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
        continue;                                                                                                                /* PRQA S 0770 */ /* MD_DEM_14.5 */
      }

      lReturnValue = Dem_Esm_EventQueueAsync_Queued(EventId, &lDebounceInfo);

      if (E_OK != lReturnValue)
      {
        /* Event update must be discarded due to queue overflow */
        Dem_LeaveCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
        break;                                                                                                                   /* PRQA S 0771 */ /* MD_DEM_14.6_err */
      }
      else
      {
        lDebounceInfo.Common.FunctionTable->Commit(&lDebounceInfo);
      }

      Dem_LeaveCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */
    }

    break;                                                                                                                       /* PRQA S 0771 */ /* MD_DEM_14.6_opt */
  } /* for (;;) */
  return lReturnValue;
}                                                                                                                                /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_Esm_EventUpdateAsync_Immediate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventUpdateAsync_Immediate(
  Dem_EventIdType  EventId,
  Dem_EventStatusType  EventStatus
  )
{
  Std_ReturnType lReturnValue;
  uint8 lOldEventStatus;
  uint8 lNewEventStatus;
  Dem_DebounceInfoType lDebounceInfo;

  lReturnValue = E_OK;
  Dem_Esm_DebounceInfoInit(EventId, &lDebounceInfo);

  /* Possible concurrent modification :
     ClearEvent
     ResetEventStatus
     Displacement
     Aging */
  for (;;)
  {
    /* Perform all calculations on the stack. Original values are preserved
     * to detect concurrent modification.*/
    lOldEventStatus = Dem_Mem_EventGetStatus(EventId);
    lNewEventStatus = lOldEventStatus;

    lDebounceInfo.Common.MonitorStatus = EventStatus;
    if (FALSE == lDebounceInfo.Common.FunctionTable->Calculate(&lDebounceInfo))
    {
      lReturnValue = E_NOT_OK;
      break;                                                                                                                     /* PRQA S 0771 */ /* MD_DEM_14.6_err */
    }

    if (FALSE != lDebounceInfo.Common.DebouncingChanged)
    {
      if (lDebounceInfo.Common.MonitorStatus == DEM_EVENT_STATUS_PASSED)
      {
        lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TF(lNewEventStatus);
        lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCSLC(lNewEventStatus);
        lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCTOC(lNewEventStatus);
      }
      else
      if (lDebounceInfo.Common.MonitorStatus == DEM_EVENT_STATUS_FAILED)
      {
        lNewEventStatus = DEM_ESM_SET_UDS_STATUS_TFTOC(lNewEventStatus);
        lNewEventStatus = DEM_ESM_SET_UDS_STATUS_TF(lNewEventStatus);
#if (DEM_CFG_PROCESS_TFSLC_STOREDONLY == STD_OFF)
        lNewEventStatus = DEM_ESM_SET_UDS_STATUS_TFSLC(lNewEventStatus);
#endif
        lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCSLC(lNewEventStatus);
        lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TNCTOC(lNewEventStatus);
      }
      else
      { /* MISRA */ }

      {
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
        Dem_EnterCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */

        /* Verify the 'old' status we had based the status calculations on is
         * still the same as before */
        if ( (lOldEventStatus != Dem_Mem_EventGetStatus(EventId))                                                                /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
          || (FALSE == lDebounceInfo.Common.FunctionTable->Validate(&lDebounceInfo)) )
        {
          /* Concurrent modification requires to repeat all calculations with
           * the new up-to-date values */
          Dem_LeaveCritical_DiagMonitor();                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */
          continue;                                                                                                              /* PRQA S 0770 */ /* MD_DEM_14.5 */
        }

        lReturnValue = Dem_Esm_EventQueueAsync_Immediate(EventId, &lDebounceInfo);

        if (E_OK != lReturnValue)
        {
          /* Event update must be discarded due to queue overflow */
          Dem_LeaveCritical_DiagMonitor();                                                                                       /* PRQA S 3109 */ /* MD_MSR_14.3 */
          break;                                                                                                                 /* PRQA S 0771 */ /* MD_DEM_14.6_err */
        }
        else
        {
          /* Commit the new values we calculated */
          Dem_Mem_EventSetStatus(EventId, lNewEventStatus);                                                                      /* PRQA S 3689 */ /* MD_DEM_21.1 */
          lDebounceInfo.Common.FunctionTable->Commit(&lDebounceInfo);
        }

        Dem_LeaveCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */
      }
    }
    break;                                                                                                                       /* PRQA S 0771 */ /* MD_DEM_14.6_opt */
  } /* for (;;) */

  if (E_OK == lReturnValue)
  { /* No combined events at this point, so the DTC update is correct */
    DEM_NVM_CHECK_DIRTY_STATUS(lOldEventStatus, lNewEventStatus)

#if ((DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON) || (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON))
    if (lOldEventStatus != lNewEventStatus)
#endif
    { /* Call notifications only if event status has changed */
#if (DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON)
      Dem_Cbk_StatusChanged(EventId, lOldEventStatus, lNewEventStatus);
#endif
#if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
      Dem_Cbk_DtcStatusChanged(EventId, lOldEventStatus, lNewEventStatus);
#endif
    }
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL_Dem_Esm_EventUpdateAsync_Immediate */

/* ****************************************************************************
 % Dem_Esm_EventReset_Async
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventReset_Async(
  Dem_EventIdType  EventId
  )
{
  Std_ReturnType lReturnValue;
  uint8 lOldEventStatus;
  uint8 lNewEventStatus;
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
# if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
  uint8 lOldDtcStatus;
# endif
  uint8 lNewDtcStatus;
  Dem_Cfg_CombinedGroupIndexType lGroupId;
#endif

  lOldEventStatus = Dem_Mem_EventGetStatus(EventId);
  if (FALSE == DEM_ESM_TEST_UDS_STATUS_TNCTOC(lOldEventStatus))
  {
    lReturnValue = E_NOT_OK;
  }
  else
  {
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
    Dem_EnterCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */

    lOldEventStatus = Dem_Mem_EventGetStatus(EventId);
    lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TF(lOldEventStatus);

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
    lGroupId = Dem_Cfg_EventCombinedGroup(EventId);

    if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
    { /* Update DTC status for combined events. */
# if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
      lOldDtcStatus = Dem_Mem_CombinedGroupGetStatus(lGroupId);
# endif
      lNewDtcStatus = Dem_Data_CombinedGroupGetStatus(lGroupId);
      Dem_Mem_CombinedGroupSetStatus(lGroupId, lNewDtcStatus);
    }
# if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
    else
    {
      lOldDtcStatus = lOldEventStatus;
      lNewDtcStatus = lNewEventStatus;
    }
# endif
#endif

    Dem_Mem_EventSetStatus(EventId, lNewEventStatus);

# if ( (DEM_CFG_SUPPORT_DEBOUNCE_TIME == STD_ON) \
    || (DEM_FEATURE_NEED_FDC_TRIP == STD_ON) \
    || (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON) \
    || (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON) )
    {
      Dem_Cfg_EventInternalStatusType lInternalStatus;

      lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
#  if (DEM_CFG_SUPPORT_DEBOUNCE_TIME == STD_ON)
      lInternalStatus = DEM_ESM_SET_DEBOUNCE_STATUS(lInternalStatus, DEM_ESM_DEBOUNCE_STATUS_NONE);
#  endif
#  if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
      lInternalStatus = DEM_ESM_RESET_FDC_TRIP(lInternalStatus);
#  endif
#  if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
      lInternalStatus = DEM_ESM_RESET_FDC_MAX(lInternalStatus);
#  endif
#  if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON)
      lInternalStatus = DEM_ESM_RESET_FDC_TOC(lInternalStatus);
#  endif
      Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);
    }
# endif

    Dem_LeaveCritical_DiagMonitor();                                                                                             /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Leave Critical Section: DiagMonitor */

    DEM_NVM_CHECK_DIRTY_STATUS(lOldEventStatus, lNewEventStatus)

#if (DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON)
    if (lOldEventStatus != lNewEventStatus)
    { /* Call notifications only if event status has changed */
      Dem_Cbk_StatusChanged(EventId, lOldEventStatus, lNewEventStatus);
    }
#endif
#if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
    if (lOldDtcStatus != lNewDtcStatus)
    {
      Dem_Cbk_DtcStatusChanged(EventId, lOldDtcStatus, lNewDtcStatus);
    }
# else
    if (lOldEventStatus != lNewEventStatus)
    {
      Dem_Cbk_DtcStatusChanged(EventId, lOldEventStatus, lNewEventStatus);
    }
# endif
#endif

    lReturnValue = E_OK;
  }

  return lReturnValue;
}

#if (DEM_FEATURE_NEED_AGING_AGE == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventAged_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventAged_Internal(
  Dem_EventIdType  EventId,
  Dem_Util_ForEachCombinedArgPtrType  ArgPtr                                                                                     /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
  uint8 lOldEventStatus;
  uint8 lNewEventStatus;
  Dem_Cfg_EventInternalStatusType lInternalStatus;

  DEM_IGNORE_UNUSED_ARGUMENT(ArgPtr)                                                                                             /* PRQA S 3112 */ /* MD_DEM_14.2 */

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lOldEventStatus = Dem_Mem_EventGetStatus(EventId);
  lNewEventStatus = lOldEventStatus;

  /* remove the aged event from the primary memory */
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_CDTC(lNewEventStatus);
# if (DEM_FEATURE_NEED_AGING_IMMEDIATE == STD_ON)
#  if (DEM_FEATURE_NEED_AGING_DELAYED == STD_ON)
  if (Dem_Cfg_EventAgingTarget(EventId) == 0)
#  endif
  {
#if (DEM_FEATURE_NEED_MULTIHEAL == STD_ON)
    if (FALSE != DEM_ESM_TEST_UDS_STATUS_PDTC(lOldEventStatus))
    {
      Dem_Mem_EventSetTripCount(EventId, Dem_Cfg_EventHealingTarget(EventId));
    }
#endif
    lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_PDTC(lNewEventStatus);
    lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TFTOC(lNewEventStatus);
  }
# endif
# if (DEM_CFG_PROCESS_TFSLC_CLEARONLY != STD_ON)
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TFSLC(lNewEventStatus);
# endif
  Dem_Mem_EventSetStatus(EventId, lNewEventStatus);

  lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
# if (DEM_CFG_AGING_RETAIN_MEMORY_ENTRY == STD_ON)
  lInternalStatus = DEM_ESM_SET_STORED_STATUS(lInternalStatus, DEM_ESM_STORED_STATUS_AGED);
# else
  lInternalStatus = DEM_ESM_SET_STORED_STATUS(lInternalStatus, DEM_ESM_STORED_STATUS_NONE);
# endif
  Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */

  DEM_NVM_CHECK_DIRTY_STATUS(lOldEventStatus, lNewEventStatus)

# if (DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON)
  if (lOldEventStatus != lNewEventStatus)
  {
    Dem_Cbk_StatusChanged(EventId, lOldEventStatus, lNewEventStatus);
  }
# endif
}
#endif

/* ****************************************************************************
 % Dem_Esm_EventClearState
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventClearState(
  Dem_EventIdType  EventId,
  Dem_Util_ForEachCombinedArgPtrType  ArgPtr                                                                                     /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;
#if ( (DEM_FEATURE_NEED_INDICATORS == STD_ON)    \
   || (DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON)  \
   || (DEM_FEATURE_NEED_OBD == STD_ON) )
  uint8 lOldEventStatus;
#endif

  DEM_IGNORE_UNUSED_ARGUMENT(ArgPtr)                                                                                             /* PRQA S 3112 */ /* MD_DEM_14.2 */

  lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
#if ((DEM_FEATURE_NEED_INDICATORS == STD_ON) || (DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON))
  lOldEventStatus = Dem_Mem_EventGetStatus(EventId);
#endif

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lInternalStatus = DEM_ESM_SET_STORED_STATUS(lInternalStatus, DEM_ESM_STORED_STATUS_NONE);
#if (DEM_CFG_SUPPORT_DEBOUNCE_TIME == STD_ON)
  lInternalStatus = DEM_ESM_SET_DEBOUNCE_STATUS(lInternalStatus, DEM_ESM_DEBOUNCE_STATUS_NONE);
#endif
#if (DEM_FEATURE_NEED_FDC_TRIP == STD_ON)
  lInternalStatus = DEM_ESM_RESET_FDC_TRIP(lInternalStatus);
#endif
#if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
  lInternalStatus = DEM_ESM_RESET_FDC_MAX(lInternalStatus);
#endif
#if (DEM_CFG_SUPPORT_TRIGGER_FDC_FIRST_IN_CYCLE == STD_ON)
  lInternalStatus = DEM_ESM_RESET_FDC_TOC(lInternalStatus);
#endif

#if (DEM_FEATURE_NEED_DEBOUNCE == STD_ON)
  Dem_Esm_EventResetDebounceValues(EventId);
#endif
  Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);
  /* Reset status byte */
  Dem_Mem_EventSetStatus(EventId, DEM_UDS_STATUS_INITIALIZE);
  /* EventStatus is marked modified by the caller to reduce runtime overhead */

  /* remove queued actions for this event */
  Dem_Queue_ResetPendingEvent(EventId);

#if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
  if (FALSE != DEM_ESM_TEST_UDS_STATUS_WIR(lOldEventStatus))
  {
    {
# if (DEM_FEATURE_NEED_USER_INDICATORS == STD_ON)
      Dem_Esm_UserIndicatorDisable(EventId);
# endif
    }
  }
#endif /* (DEM_FEATURE_NEED_INDICATORS == STD_ON) */
#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
  if (DEM_MEM_INVALID_PRESTORAGE_REF != Dem_Cfg_EventPrestorageIndex(EventId))
  {
    (void)Dem_Esm_EventPrestorageClear(EventId);
  }
#endif

  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */

#if (DEM_FEATURE_NEED_MULTITRIP == STD_ON)
  Dem_Mem_EventSetTripCount(EventId, 0);
#endif

#if (DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON)
  /* Call status changed notifications if there is a change */
  if (lOldEventStatus != DEM_UDS_STATUS_INITIALIZE)
  {
    Dem_Cbk_StatusChanged(EventId, lOldEventStatus, DEM_UDS_STATUS_INITIALIZE);
  }
#endif
}                                                                                                                                /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Esm_EventCleared_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventCleared_Internal(
  Dem_EventIdType  EventId
  )
{
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  Dem_Cfg_CombinedGroupIndexType lGroupId;
  lGroupId = Dem_Cfg_EventCombinedGroup(EventId);
#endif

  {
    Dem_Cfg_EventInternalStatusType lInternalStatus;
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
    if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
    {
      lInternalStatus = Dem_Mem_CombinedGroupGetInternalStatus(lGroupId);
    }
    else
#endif
    {
      lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
    }

    if (DEM_ESM_STORED_STATUS_NONE != DEM_ESM_GET_STORED_STATUS(lInternalStatus))
    {
      DEM_MEM_MEMORYINFO_PARAM_VARDEF
      Dem_Cfg_MemoryIndexType lMemoryIndex;
      DEM_MEM_MEMORYINFO_PARAM_INIT(Dem_Cfg_EventDestination(EventId))

      /* remove the event from the primary memory */
      lMemoryIndex = Dem_Mem_MemoryFindIndex(EventId);
      Dem_Mem_MemoryFreeIndex(lMemoryIndex);
      Dem_Mem_MemorySetBlockState(lMemoryIndex, DEM_NVM_BLOCKSTATE_DIRTYCLEAREDIMMEDIATE);
    }

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
    if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
    {
      Dem_Mem_CombinedGroupSetInternalStatus(lGroupId, DEM_ESM_SET_STORED_STATUS(lInternalStatus, DEM_ESM_STORED_STATUS_NONE));
    }
#endif
  }

  {
    Dem_Util_ForEachCombinedArgType lArgs;
#if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
    uint8 lOldDtcStatus;
#endif

#if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
    lOldDtcStatus = Dem_Util_DtcApplyExternalOnlyStatus(EventId, Dem_Util_DtcGetStatus(EventId));
#endif

    Dem_Util_ForEachCombinedEvent(EventId, Dem_Esm_EventClearState, &lArgs);

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
    if (DEM_CFG_COMBINED_GROUP_INVALID != lGroupId)
    {
      Dem_Mem_CombinedGroupSetStatus(lGroupId, DEM_UDS_STATUS_INITIALIZE);
    }
#endif
#if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
    /* Call status changed notifications if there is a change */
    if (lArgs.Common.OldDtcStatus != DEM_UDS_STATUS_INITIALIZE)
    {
      Dem_Cbk_DtcStatusChanged_Internal(EventId, lOldDtcStatus, DEM_UDS_STATUS_INITIALIZE);
    }
#endif
  }
}                                                                                                                                /* PRQA S 6010, 6030, 6050 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STCAL */

#if (DEM_CFG_SUPPORT_DISPLACEMENT == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventDisplaced_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Esm_EventDisplaced_Internal(
  Dem_EventIdType  EventId,
  Dem_Util_ForEachCombinedArgPtrType  ArgPtr                                                                                     /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7_Internal */
  )
{
  Dem_Cfg_EventInternalStatusType lInternalStatus;
# if (DEM_FEATURE_NEED_STOREDONLY_BITS == STD_ON) || (DEM_FEATURE_NEED_OBD == STD_ON)
  uint8 lOldEventStatus;
# endif
# if (DEM_FEATURE_NEED_STOREDONLY_BITS == STD_ON)
  uint8 lNewEventStatus;
# endif

  DEM_IGNORE_UNUSED_ARGUMENT(ArgPtr)                                                                                             /* PRQA S 3112 */ /* MD_DEM_14.2 */

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
  Dem_EnterCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */

  lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
  lInternalStatus = DEM_ESM_SET_STORED_STATUS(lInternalStatus, DEM_ESM_STORED_STATUS_NONE);
  Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);

# if (DEM_FEATURE_NEED_STOREDONLY_BITS == STD_ON) || (DEM_FEATURE_NEED_OBD == STD_ON)
  lOldEventStatus = Dem_Mem_EventGetStatus(EventId);
# endif
# if (DEM_FEATURE_NEED_STOREDONLY_BITS == STD_ON)
  lNewEventStatus = lOldEventStatus;
# endif
  /* Update the status bit */
# if (DEM_CFG_PROCESS_PDTC_STOREDONLY == STD_ON)
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_PDTC(lNewEventStatus);
#  endif
# if (DEM_CFG_PROCESS_CDTC_STOREDONLY == STD_ON)
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_CDTC(lNewEventStatus);
# endif
# if (DEM_CFG_PROCESS_TFSLC_STOREDONLY == STD_ON)
  lNewEventStatus = DEM_ESM_RESET_UDS_STATUS_TFSLC(lNewEventStatus);
# endif
# if (DEM_FEATURE_NEED_STOREDONLY_BITS == STD_ON)
  Dem_Mem_EventSetStatus(EventId, lNewEventStatus);
# endif
  /* Displacement follows an event status change. No need to mark Nv modification again. */
  Dem_LeaveCritical_DiagMonitor();                                                                                               /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */
# if (DEM_FEATURE_NEED_STOREDONLY_BITS == STD_ON)
#  if (DEM_FEATURE_NEED_NOTIFY_EVENT == STD_ON)
  if (lNewEventStatus != lOldEventStatus)
  {
    /* DtcStatus has changed, call notifications */
    Dem_Cbk_StatusChanged(EventId, lOldEventStatus, lNewEventStatus);
  }
#  endif
# endif
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_Esm_EventPrestorageClear
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Esm_EventPrestorageClear(
  Dem_EventIdType  EventId
  )
{
  Std_ReturnType lReturnValue;
  Dem_Cfg_PrestorageIndexType lPrestorageIndex;

  lReturnValue = E_NOT_OK;
  lPrestorageIndex = Dem_Mem_PrestorageFindEntry(EventId);

  if (DEM_MEM_INVALID_PRESTORAGE_INDEX != lPrestorageIndex)
  { /* there already is an entry allocated to this event */
    Dem_Mem_PrestoredEntryPtrType lPrestoredEntry;
    lPrestoredEntry = Dem_Mem_PrestorageGetEntry(lPrestorageIndex);
    if (DEM_ESM_PRESTORED_STATUS_LOCKED != Dem_Mem_PrestoredEntryGetState(lPrestoredEntry))
    {
      Dem_Mem_PrestoredEntrySetState(lPrestoredEntry, DEM_ESM_PRESTORED_STATUS_FREE);
      Dem_Mem_PrestorageFreeEntry(lPrestorageIndex);
      lReturnValue = E_OK;
    }
  }

  return lReturnValue;
}
#endif

                                                                    /* Queue */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Queue_ProcessClearDtcGroup
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Queue_ProcessClearDtcGroup(
  uint16  FirstEventId,
  uint16  LastEventId
  )
{
  if (FirstEventId != DEM_EVENT_INVALID)
  {
    uint8 lGroupMask;
    uint16 lEventIterator;

    lGroupMask = Dem_Queue_GetClearGroup();
    lEventIterator = LastEventId;

    while (FirstEventId <= lEventIterator)
    { /* Event must match the group */
      if ( ( (lGroupMask == DEM_CFG_GROUPMASK_ALLDTCS)                                                                           /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
#if (DEM_CFG_CLEAR_GROUP_DTCS == STD_ON)
          || ((Dem_Cfg_EventGroupMask(lEventIterator) & lGroupMask) != 0)
#endif
          )
      /* Do not test for suppression: suppressed DTCs are not exempt from ClearGroupOfDTC */
#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
        && (FALSE != Dem_Util_DtcAvailableInVariant(lEventIterator))
#endif
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
        && (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Util_DtcGetInternalStatus(lEventIterator)))
#endif
        )

      { /* For combined events, only clear each event once */
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
        if (Dem_Util_DtcGetMasterEvent(lEventIterator) == lEventIterator)
#endif
        {
#if (DEM_CFG_NOTIFY_CLEAR_ALLOWED == STD_ON)
          (void)Dem_Esm_EventCleared_Optional(lEventIterator);
#else
          Dem_Esm_EventCleared_Always(lEventIterator);
#endif
        }
      }
      --lEventIterator;
    }
  }
}

                                                        /* Data Provisioning */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 % Dem_Data_CombinedGroupGetFDC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Data_CombinedGroupGetFDC(
  Dem_Cfg_CombinedGroupIndexType  GroupId,                                                                                       /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(sint8, AUTOMATIC, DEM_APPL_DATA)  FaultDetectionCounter
  )
{
  Std_ReturnType lReturnValue;
  sint8 lMaxFdc;
  Dem_Cfg_CombinedGroupIterType lCombinedIter;

  /* In rare cases GroupId is not required */
  DEM_IGNORE_UNUSED_ARGUMENT(GroupId)                                                                                            /* PRQA S 3112 */ /* MD_DEM_14.2 */

  lReturnValue = E_OK;
  lMaxFdc = -128;
  Dem_Cfg_CombinedGroupIterInit(GroupId, &lCombinedIter);                                                                        /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */

  while ( (FALSE != Dem_Cfg_CombinedGroupIterExists(GroupId, &lCombinedIter))
       && (lReturnValue == E_OK) )
  {
    Dem_EventIdType lSubEventId;
    lSubEventId = Dem_Cfg_CombinedGroupIterGet(GroupId, &lCombinedIter);

# if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
    if (FALSE != Dem_Cfg_EventAvailableInVariant(lSubEventId))
# endif
    {
# if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
      if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(lSubEventId)))
# endif
      {
        sint8 lFdc;
        lReturnValue = Dem_GetFaultDetectionCounter(lSubEventId, &lFdc);
        if ((lReturnValue == E_OK) && (lMaxFdc < lFdc))
        {
          lMaxFdc = lFdc;
        }
      }
    }
    Dem_Cfg_CombinedGroupIterNext(GroupId, &lCombinedIter);
  }

  if (lReturnValue == E_OK)
  {
    *FaultDetectionCounter = lMaxFdc;
  }

  return lReturnValue;
}
#endif

#if ((DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON) && (DEM_FEATURE_NEED_MAX_DEBOUNCE_VALUE == STD_ON))
/* ****************************************************************************
 % Dem_Data_CombinedGroupGetFDCMax
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(sint8, DEM_CODE)
Dem_Data_CombinedGroupGetFDCMax(
  Dem_Cfg_CombinedGroupIndexType  GroupId                                                                                        /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  sint8 lMaxFdc;
  Dem_Cfg_CombinedGroupIterType lCombinedIter;

  /* In rare cases GroupId is not required */
  DEM_IGNORE_UNUSED_ARGUMENT(GroupId)                                                                                            /* PRQA S 3112 */ /* MD_DEM_14.2 */

  lMaxFdc = 0;
  for (Dem_Cfg_CombinedGroupIterInit(GroupId, &lCombinedIter);                                                                   /* PRQA S 3198, 3418 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
       (FALSE != Dem_Cfg_CombinedGroupIterExists(GroupId, &lCombinedIter));
       Dem_Cfg_CombinedGroupIterNext(GroupId, &lCombinedIter))
  {
    Dem_EventIdType lSubEventId;
    lSubEventId = Dem_Cfg_CombinedGroupIterGet(GroupId, &lCombinedIter);
# if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
    if (FALSE != Dem_Cfg_EventAvailableInVariant(lSubEventId))
# endif
    {
# if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
      if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(lSubEventId)))
# endif
      {
        sint8 lFdc;
        lFdc = Dem_Data_EventGetFDCMax(lSubEventId);
        if (lMaxFdc < lFdc)
        {
          lMaxFdc = lFdc;
        }
      }
    }
  }

  return lMaxFdc;
}
#endif

#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
/* ****************************************************************************
 % Dem_Data_CombinedGroupGetStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(uint8, DEM_CODE)
Dem_Data_CombinedGroupGetStatus(
  Dem_Cfg_CombinedGroupIndexType  GroupId                                                                                        /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  uint8 lReturnValue;
  Dem_Cfg_CombinedGroupIterType lCombinedIter;

  /* In rare cases GroupId is not required */
  DEM_IGNORE_UNUSED_ARGUMENT(GroupId)                                                                                            /* PRQA S 3112 */ /* MD_DEM_14.2 */

  lReturnValue = 0x00u;

  for (Dem_Cfg_CombinedGroupIterInit(GroupId, &lCombinedIter);                                                                   /* PRQA S 3198, 3418 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
       (FALSE != Dem_Cfg_CombinedGroupIterExists(GroupId, &lCombinedIter));
       Dem_Cfg_CombinedGroupIterNext(GroupId, &lCombinedIter))
  {
    Dem_EventIdType lSubEventId;

    lSubEventId = Dem_Cfg_CombinedGroupIterGet(GroupId, &lCombinedIter);
# if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
    if (FALSE != Dem_Cfg_EventAvailableInVariant(lSubEventId))
# endif
    {
# if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
      if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(lSubEventId)))
# endif
      {
        lReturnValue = (uint8)(lReturnValue | Dem_Mem_EventGetStatus(lSubEventId));
      }
    }
  }

  return lReturnValue;
}
#endif

#if ( (DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_OBDII == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_WWHOBD == STD_ON) )
/* ****************************************************************************
 % Dem_Data_CollectDid
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Data_CollectDid(
  Dem_Data_CollectDidInfoPtrType  CollectDidInfoPtr,
  Dem_Cfg_DidIndexType  DidIndex
  )
{
  Dem_Cfg_DidDataIterType lDataIter;

  /* Each DID consists of 1-* data elements. */
  Dem_Cfg_DidDataIterInit(DidIndex, &lDataIter);                                                                                 /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
  while (FALSE != Dem_Cfg_DidDataIterExists(DidIndex, &lDataIter))
  {
    Dem_Cfg_DataIndexType lDataIndex;

    lDataIndex = Dem_Cfg_DidDataIterGet(DidIndex, &lDataIter);
    Dem_Cfg_DidDataIterNext(DidIndex, &lDataIter);

    switch (Dem_Cfg_DataCallbackType(lDataIndex))
    {
    case DEM_CFG_DATA_FROM_CBK_STORED:
      if (E_OK != (*((Dem_ReadDataStandardFPtrType)Dem_Cfg_DataCbkRead(lDataIndex)))(CollectDidInfoPtr->DestinationBuffer))      /* PRQA S 0313 */ /* MD_DEM_11.1 */
      { /* In case the function failed, fill with padding bytes */
        Dem_MemSet(CollectDidInfoPtr->DestinationBuffer, 0xffU, Dem_Cfg_DataSize(lDataIndex));                                   /* PRQA S 0602, 3109 */ /* MD_DEM_20.2, MD_MSR_14.3 */
      }
      CollectDidInfoPtr->DestinationBuffer = &(CollectDidInfoPtr->DestinationBuffer[Dem_Cfg_DataSize(lDataIndex)]);
      break;

    case DEM_CFG_DATA_FROM_CBK_STORED_WITH_EVENTID:
      if (E_OK != (*((Dem_ReadDataExtendedFPtrType)Dem_Cfg_DataCbkRead(lDataIndex)))(CollectDidInfoPtr->EventId, CollectDidInfoPtr->DestinationBuffer))  /* PRQA S 0313 */ /* MD_DEM_11.1 */
      { /* In case the function failed, fill with padding bytes */
        Dem_MemSet(CollectDidInfoPtr->DestinationBuffer, 0xffU, Dem_Cfg_DataSize(lDataIndex));                                   /* PRQA S 0602, 3109 */ /* MD_DEM_20.2, MD_MSR_14.3 */
      }
      CollectDidInfoPtr->DestinationBuffer = &(CollectDidInfoPtr->DestinationBuffer[Dem_Cfg_DataSize(lDataIndex)]);
      break;

# if (DEM_CFG_DATA_ROOTCAUSE_EVENTID == STD_ON)
    case DEM_CFG_DATA_FROM_ROOTCAUSE_EVENTID:
      /* ROOTCAUSE_EVENTID: store configuration element in environmental data array */
      CollectDidInfoPtr->DestinationBuffer[0] = Dem_GetHiByte(CollectDidInfoPtr->EventId);
      CollectDidInfoPtr->DestinationBuffer[1] = Dem_GetLoByte(CollectDidInfoPtr->EventId);
      CollectDidInfoPtr->DestinationBuffer = &(CollectDidInfoPtr->DestinationBuffer[2]);
      break;
# endif

    default:
      /* Do not store (skip) statistical data */
      break;
    } /* switch (Dem_Cfg_DataCallbackType(lDataIndex)) */
  } /* (FALSE != Dem_Cfg_DidDataIterExists(DidIndex, &lDataIter)) */
}
#endif /* ( (DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON) ) */

#if (DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_OBDII == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_WWHOBD == STD_ON)
/* ****************************************************************************
 % Dem_Data_CopyDid
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(boolean, DEM_CODE)
Dem_Data_CopyDid(
  Dem_Data_CopyDidInfoPtrType  CopyDidInfoPtr,
  Dem_Cfg_DidIndexType  DidIndex
  )
{
  boolean lReturnValue;
  Dem_Cfg_DidDataIterType lDataIter;

  lReturnValue = TRUE;
  Dem_Cfg_DidDataIterInit(DidIndex, &lDataIter);                                                                                 /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
  while (FALSE != Dem_Cfg_DidDataIterExists(DidIndex, &lDataIter))
  {
    Dem_Cfg_DataIndexType lDataIndex;

    lDataIndex = Dem_Cfg_DidDataIterGet(DidIndex, &lDataIter);
    Dem_Cfg_DidDataIterNext(DidIndex, &lDataIter);

    switch (Dem_Cfg_DataCallbackType(lDataIndex))
    {
# if (DEM_CFG_DATA_AGINGCTR == STD_ON)
    case DEM_CFG_DATA_FROM_AGINGCTR:
      lReturnValue = (boolean)((Dem_Data_CopyUpwardsAgingCounter(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

# if (DEM_CFG_DATA_OCCCTR == STD_ON)
    case DEM_CFG_DATA_FROM_OCCCTR:
      lReturnValue = (boolean)((Dem_Data_Copy1ByteOccurrenceCounter(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

# if (DEM_CFG_DATA_OCCCTR_2BYTE == STD_ON)
    case DEM_CFG_DATA_FROM_OCCCTR_2BYTE:
      lReturnValue = (boolean)((Dem_Data_Copy2ByteOccurrenceCounter(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

# if (DEM_CFG_DATA_OVFLIND == STD_ON)
    case DEM_CFG_DATA_FROM_OVFLIND:
      lReturnValue = (boolean)((Dem_Data_CopyOverflowIndication(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

# if (DEM_CFG_DATA_SIGNIFICANCE == STD_ON)
    case DEM_CFG_DATA_FROM_SIGNIFICANCE:
      lReturnValue = (boolean)((Dem_Data_CopyEventSignificance(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

# if (DEM_CFG_DATA_PRIORITY == STD_ON)
    case DEM_CFG_DATA_FROM_PRIORITY:
      lReturnValue = (boolean)((Dem_Data_CopyEventPriority(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

# if (DEM_CFG_DATA_AGINGCTR_INVERTED == STD_ON)
    case DEM_CFG_DATA_FROM_AGINGCTR_INVERTED:
      lReturnValue = (boolean)((Dem_Data_CopyDownwardsAgingCounter(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

# if (DEM_CFG_DATA_MAX_FDC_SINCE_LAST_CLEAR == STD_ON)
    case DEM_CFG_DATA_FROM_MAX_FDC_SINCE_LAST_CLEAR:
      lReturnValue = (boolean)((Dem_Data_CopyMaxFdcSinceLastClear(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

# if (DEM_CFG_DATA_MAX_FDC_DURING_CURRENT_CYCLE == STD_ON)
    case DEM_CFG_DATA_FROM_MAX_FDC_DURING_CURRENT_CYCLE:
      lReturnValue = (boolean)((Dem_Data_CopyMaxFdcThisCycle(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

# if (DEM_CFG_DATA_CYCLES_SINCE_LAST_FAILED == STD_ON)
    case DEM_CFG_DATA_FROM_CYCLES_SINCE_LAST_FAILED:
      lReturnValue = (boolean)((Dem_Data_CopyCyclesSinceLastFailed(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

# if (DEM_CFG_DATA_CYCLES_SINCE_FIRST_FAILED == STD_ON)
    case DEM_CFG_DATA_FROM_CYCLES_SINCE_FIRST_FAILED:
      lReturnValue = (boolean)((Dem_Data_CopyCyclesSinceFirstFailed(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

# if (DEM_CFG_DATA_FAILED_CYCLES == STD_ON)
    case DEM_CFG_DATA_FROM_FAILED_CYCLES:
      lReturnValue = (boolean)((Dem_Data_CopyFailedCycles(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

# if (DEM_CFG_DATA_CONSECUTIVE_FAILED_CYCLES == STD_ON)
    case DEM_CFG_DATA_FROM_CONSECUTIVE_FAILED_CYCLES:
      lReturnValue = (boolean)((Dem_Data_CopyConsecutiveFailedCycles(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

# if (DEM_CFG_DATA_CYCLES_TESTED_SINCE_FIRST_FAILED == STD_ON)
    case DEM_CFG_DATA_FROM_CYCLES_TESTED_SINCE_FIRST_FAILED:
      lReturnValue = (boolean)((Dem_Data_CopyCyclesTestedSinceFirstFailed(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

# if (DEM_CFG_DATA_ROOTCAUSE_EVENTID == STD_ON)
    case DEM_CFG_DATA_FROM_ROOTCAUSE_EVENTID:
      lReturnValue = (boolean)((Dem_Data_CopyRootCauseEventId(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

# if (DEM_CFG_DATA_OBDDTC == STD_ON)
    case DEM_CFG_DATA_FROM_OBDDTC:
      lReturnValue = (boolean)((Dem_Data_CopyEventObdDtc(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

# if (DEM_CFG_DATA_OBDDTC_3BYTE == STD_ON)
    case DEM_CFG_DATA_FROM_OBDDTC_3BYTE:
      lReturnValue = (boolean)((Dem_Data_CopyEventObdDtc_3Byte(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

# if (DEM_CFG_DATA_CURRENT_FDC == STD_ON)
    case DEM_CFG_DATA_FROM_CURRENT_FDC:
      lReturnValue = (boolean)((Dem_Data_CopyCurrentFdc(CopyDidInfoPtr)) & lReturnValue);
      break;
# endif

    case DEM_CFG_DATA_FROM_CBK_STORED:
    case DEM_CFG_DATA_FROM_CBK_STORED_WITH_EVENTID:
      Dem_Internal_AssertReturnValue(CopyDidInfoPtr->SourceBuffer != NULL_PTR, DEM_E_INCONSISTENT_STATE, FALSE)

      Dem_MemCpy(CopyDidInfoPtr->DestinationBuffer, CopyDidInfoPtr->SourceBuffer, Dem_Cfg_DataSize(lDataIndex));                 /* PRQA S 0311, 0602, 3109 */ /* MD_DEM_11.5, MD_DEM_20.2, MD_MSR_14.3 */
      CopyDidInfoPtr->SourceBuffer = &CopyDidInfoPtr->SourceBuffer[Dem_Cfg_DataSize(lDataIndex)];
      break;

    case DEM_CFG_DATA_FROM_CBK_CURRENT:
      if (E_OK != (*((Dem_ReadDataStandardFPtrType)Dem_Cfg_DataCbkRead(lDataIndex)))(CopyDidInfoPtr->DestinationBuffer))         /* PRQA S 0313 */ /* MD_DEM_11.1 */
      { /* In case the function failed, fill with padding bytes */
        Dem_MemSet(CopyDidInfoPtr->DestinationBuffer, 0xffU, Dem_Cfg_DataSize(lDataIndex));                                      /* PRQA S 0602, 3109 */ /* MD_DEM_20.2, MD_MSR_14.3 */
      }
      break;

    case DEM_CFG_DATA_FROM_CBK_CURRENT_WITH_EVENTID:
      if (E_OK != (*((Dem_ReadDataExtendedFPtrType)Dem_Cfg_DataCbkRead(lDataIndex)))(CopyDidInfoPtr->EventId, CopyDidInfoPtr->DestinationBuffer))  /* PRQA S 0313 */ /* MD_DEM_11.1 */
      { /* In case the function failed, fill with padding bytes */
        Dem_MemSet(CopyDidInfoPtr->DestinationBuffer, 0xffU, Dem_Cfg_DataSize(lDataIndex));                                      /* PRQA S 0602, 3109 */ /* MD_DEM_20.2, MD_MSR_14.3 */
      }
      break;

    default:
      lReturnValue = FALSE;
      break;
    }
    CopyDidInfoPtr->DestinationBuffer = &CopyDidInfoPtr->DestinationBuffer[Dem_Cfg_DataSize(lDataIndex)];
  }

  return (boolean)(lReturnValue == TRUE);
}                                                                                                                                /* PRQA S 6030, 6050 */ /* MD_MSR_STCYC, MD_MSR_STCAL */
#endif /* ( (DEM_CFG_SUPPORT_ERECS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON) ) */

                                                            /* Nv Management */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
/* ****************************************************************************
 % Dem_Nvm_SetBlockStateImmediate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(void, DEM_CODE)
Dem_Nvm_SetBlockStateImmediate(
  Dem_Cfg_MemoryIndexType  MemoryIndex,
  uint8  BlockState
  )
{
  Dem_Internal_AssertReturnVoid((MemoryIndex != DEM_MEM_INVALID_MEMORY_INDEX), DEM_E_INCONSISTENT_STATE);

# if (DEM_FEATURE_NEED_NVM_WRITELIMIT == STD_ON)
  if ( (Dem_Mem_IsMemoryEntryIndex(MemoryIndex))
    && (DEM_NVM_BLOCKSTATE_DIRTYIMMEDIATE == BlockState) )
  { /* downgrade immediate update when occurrence limit is reached */
    Dem_Mem_EntryPtrType lMemoryEntry;
    lMemoryEntry = Dem_Mem_MemoryGetEntry(MemoryIndex);                                                                          /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */

    if (Dem_Mem_EntryGetOccurrenceCount(lMemoryEntry) >= Dem_Cfg_GlobalNvStorageLimit())
    {
      BlockState = DEM_NVM_BLOCKSTATE_DIRTY;
    }
  }
# endif

  if ( (0 == (DEM_NVM_BLOCKSTATE_IMMEDIATEFLAG & Dem_Nvm_GetBlockState(MemoryIndex)))                                            /* PRQA S 3689 */ /* MD_DEM_21.1 */
    && (0 != (DEM_NVM_BLOCKSTATE_IMMEDIATEFLAG & BlockState)) )
  {
    Dem_Nvm_CommitData.PendingCount = (uint8)(Dem_Nvm_CommitData.PendingCount + 1);
  }

# if (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON)
  if ( (0 == (DEM_NVM_BLOCKSTATE_CLEARFLAG & Dem_Nvm_GetBlockState(MemoryIndex)))                                                /* PRQA S 3689 */ /* MD_DEM_21.1 */
    && (0 != (DEM_NVM_BLOCKSTATE_CLEARFLAG & BlockState)) )
  { /* Only if clear flag is being set, not if it is already set */
    Dem_Nvm_CommitData.PendingClearCount = (uint8)(Dem_Nvm_CommitData.PendingClearCount + 1);
  }
# endif /* (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON) */

  if (Dem_Nvm_GetBlockState(MemoryIndex) < BlockState)                                                                           /* PRQA S 3689 */ /* MD_DEM_21.1 */
  { /* Only if no information is lost (e.g. clear replaced by dirty) */
    Dem_Nvm_SetBlockState(MemoryIndex, BlockState);                                                                              /* PRQA S 3689 */ /* MD_DEM_21.1 */
  }
}                                                                                                                                /* PRQA S 6010, 6030 */ /* MD_MSR_STPTH, MD_MSR_STCYC */
#endif /* (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON) */

                                                            /* DCM Interface */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_Dcm_ClearDtc_TestForAllDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_TestForAllDtc(
  uint32  DTC,
  P2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest
  )
{
  Dem_ReturnClearDTCType lReturnValue;

  Dem_Internal_AssertReturnValue((ClearRequest->ClearFormat == DEM_DTC_FORMAT_OBD) || (ClearRequest->ClearFormat == DEM_DTC_FORMAT_UDS),
                                  DEM_E_PARAM_DATA,
                                  DEM_CLEAR_WRONG_DTC)

  if ( (DEM_DTC_GROUP_ALL_DTCS == DTC)
    )
  {
    ClearRequest->ClearGroup = DEM_CFG_GROUPMASK_ALLDTCS;
    ClearRequest->ClearEventId = DEM_EVENT_INVALID;
    lReturnValue = DEM_CLEAR_OK;
  }
  else
  {
    lReturnValue = DEM_CLEAR_WRONG_DTC;
  }
  return lReturnValue;
}

#if (DEM_CFG_CLEAR_GROUP_DTCS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_ClearDtc_TestForGroupDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_TestForGroupDtc(
  uint32  DTC,
  P2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest
  )
{
  Dem_ReturnClearDTCType lReturnValue;
  Dem_Internal_AssertReturnValue(ClearRequest->ClearFormat == DEM_DTC_FORMAT_UDS,
                                 DEM_E_PARAM_DATA,
                                 DEM_CLEAR_WRONG_DTC)

  {
    uint8 lGroupMask;
    lGroupMask = Dem_Cfg_FindGroupMaskFromUdsDtc(DTC);
    if (DEM_CFG_GROUPMASK_NONE != lGroupMask)
    {
      ClearRequest->ClearGroup = lGroupMask;
      ClearRequest->ClearEventId = DEM_EVENT_INVALID;
      lReturnValue = DEM_CLEAR_OK;
    }
    else
    {
      lReturnValue = DEM_CLEAR_WRONG_DTC;
    }
  }
  return lReturnValue;
}
#endif

#if (DEM_CFG_CLEAR_SINGLE_DTCS == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_ClearDtc_TestForSingleDtc
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_TestForSingleDtc(
  uint32  DTC,
  P2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest
  )
{
  Dem_ReturnClearDTCType lReturnValue;
  Dem_Internal_AssertReturnValue(ClearRequest->ClearFormat == DEM_DTC_FORMAT_UDS,
                                 DEM_E_PARAM_DATA,
                                 DEM_CLEAR_WRONG_DTC)

  {
    Dem_EventIdType lEventId;

    if ( (DEM_CFG_DTC_UDS_INVALID == DTC)
      || (0 == DTC) )
    {
      lEventId = DEM_EVENT_INVALID;
    }
    else
    {
      lEventId = Dem_Dcm_FindEventFromUdsDtc(DTC, ClearRequest->ClearMemoryId, ClearRequest->ClearClient);
    }

    if ( (DEM_EVENT_INVALID != lEventId)                                                                                         /* PRQA S 3415 */ /* MD_DEM_12.4_m */
# if (DEM_CFG_ISCONST_DESTINATION != STD_ON)
      && (ClearRequest->ClearMemoryId == Dem_Cfg_EventDestination(lEventId))
# endif
# if (DEM_FEATURE_NEED_TESTSUPPRESSION == STD_ON)
      && (FALSE == Dem_Esm_TestDtcSuppressed(lEventId))                                                                          /* PRQA S 3415 */ /* MD_DEM_12.4_m */
# endif
      )
    { /* Event does belong to the requested origin */
      ClearRequest->ClearGroup = DEM_CFG_GROUPMASK_NONE;
      ClearRequest->ClearEventId = lEventId;
      lReturnValue = DEM_CLEAR_OK;
    }
    else
    {
      lReturnValue = DEM_CLEAR_WRONG_DTC;
    }
  }
  return lReturnValue;
}
#endif

/* ****************************************************************************
 % Dem_Dcm_ClearDtc_Internal
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_Dcm_ClearDtc_Internal(
  uint32  DTC,
  P2VAR(Dem_Queue_ClearRequestType, AUTOMATIC, DEM_VAR_NOINIT)  ClearRequest
  )
{
  Dem_ReturnClearDTCType lReturnValue;
  Dem_Dcm_ClearDtc_TestPtrType lClearDtcTest;

  lReturnValue = DEM_CLEAR_WRONG_DTC;
  /* Validate the combination of parameters */
  switch (ClearRequest->ClearMemoryId)
  {
  case DEM_CFG_MEMORYID_PRIMARY:
    lClearDtcTest = Dem_Dcm_ClearDtc_TestPrimary[ClearRequest->ClearFormat];
    break;

#if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
  case DEM_CFG_MEMORYID_SECONDARY:
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
    if ((ClearRequest->ClearFormat == DEM_DTC_FORMAT_OBD) || (ClearRequest->ClearFormat == DEM_DTC_FORMAT_J1939))
    {
      Dem_Det_ReportError(DEM_INTERNAL_APIID, DEM_E_PARAM_DATA)
      lClearDtcTest = Dem_Dcm_ClearDtc_TestFail;
      lReturnValue = DEM_CLEAR_WRONG_DTCORIGIN;
    }
    else
# endif
    {
      lClearDtcTest = Dem_Dcm_ClearDtc_TestSecondary[ClearRequest->ClearFormat];
    }
    break;
#endif

  default:
    lReturnValue = DEM_CLEAR_WRONG_DTCORIGIN;
    lClearDtcTest = Dem_Dcm_ClearDtc_TestFail;
    break;
  }

  while ( (DEM_CLEAR_WRONG_DTC == lReturnValue)
       && (NULL_PTR != *lClearDtcTest) )
  {
    lReturnValue = (*lClearDtcTest)(DTC, ClearRequest);
    lClearDtcTest = &lClearDtcTest[1];
  }

  if (DEM_CLEAR_OK == lReturnValue)
  { /* The requested DTC or DTC group exists, as well as the requested memory.
     * Test if there is another clear operation ongoing at the moment */
    uint8 lClearState;

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DcmApi */
    Dem_EnterCritical_DcmApi();                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
    lClearState = Dem_Queue_GetClearState();

    if ( (lClearState == DEM_QUEUE_CLEARSTATE_IDLE)
      || ( (FALSE != DEM_QUEUE_TESTCLEARSTATE_CANCEL(lClearState))
        && (FALSE != DEM_QUEUE_TESTCLEARSTATE_DONE(lClearState)) ) )
    { /* Set up new request if no old request is pending (idle), or the last
       * request has finished and was cancelled in the process */
      /* Remember the arguments of a new request, it will be processed on the
       * task level of Dem */
      Dem_Queue_SetClearMemory(ClearRequest->ClearMemoryId);
      Dem_Queue_SetClearFormat(ClearRequest->ClearFormat);
      Dem_Queue_SetClearGroup(ClearRequest->ClearGroup);
      Dem_Queue_SetClearEvent(ClearRequest->ClearEventId);
      Dem_Queue_SetClearClient(ClearRequest->ClearClient);
      lClearState = DEM_QUEUE_CLEARSTATE_IDLE;
      lClearState = DEM_QUEUE_SETCLEARSTATE_PENDING(lClearState);
      Dem_Queue_SetClearState(lClearState);

      lReturnValue = DEM_CLEAR_PENDING;
    }

    if (DEM_CLEAR_OK == lReturnValue)
    { /* Not the case if a new request was started above */
      if (FALSE != DEM_QUEUE_TESTCLEARSTATE_CANCEL(lClearState))
      { /* Canceled requests return failed until completion */
        lReturnValue = DEM_CLEAR_FAILED;
      }
      else
      if ( (Dem_Queue_GetClearMemory() == ClearRequest->ClearMemoryId)
        && (Dem_Queue_GetClearFormat() == ClearRequest->ClearFormat)
        && (Dem_Queue_GetClearGroup() == ClearRequest->ClearGroup)
        && (Dem_Queue_GetClearEvent() == ClearRequest->ClearEventId)
        && (Dem_Queue_GetClearClient() == ClearRequest->ClearClient)
        )
      { /* The same request, poll for the result */
#if ((DEM_CFG_USE_NVM == STD_ON) && (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON))
        if (FALSE == Dem_Nvm_GetPendingClear())
#endif
        {
          if (FALSE != DEM_QUEUE_TESTCLEARSTATE_DONE(lClearState))
          {
            if (FALSE != DEM_QUEUE_TESTCLEARSTATE_FAILED(lClearState))
            {
              lReturnValue = DEM_CLEAR_FAILED;
            }
#if ((DEM_CFG_USE_NVM == STD_ON) && (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON))
            else if (FALSE != DEM_QUEUE_TESTCLEARSTATE_NVFAILED(lClearState))
            {
# if (DEM_CFG_SUPPORT_API_VERSION_4_2_1 == STD_ON)
              lReturnValue = DEM_CLEAR_MEMORY_ERROR;
# else
              lReturnValue = DEM_CLEAR_OK;
# endif
            }
#endif
            else
            {
              lReturnValue = DEM_CLEAR_OK;
            }
            Dem_Queue_SetClearState(DEM_QUEUE_CLEARSTATE_IDLE);
          }
          else
          {
            lReturnValue = DEM_CLEAR_PENDING;
          }
        }
#if ((DEM_CFG_USE_NVM == STD_ON) && (DEM_CFG_CLEAR_NV_END_RESPONSE == STD_ON))
        else
        { /* A request still in the process of being committed to NV blocks */
          lReturnValue = DEM_CLEAR_PENDING;
        }
#endif
      }
      else
      { /* A different request has to wait until the previous clear has completed */
        lReturnValue = DEM_CLEAR_BUSY;
      }
    }

    Dem_LeaveCritical_DcmApi();                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DcmApi */
  }

  return lReturnValue;
}                                                                                                                                /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_FilterNumberMemory
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(uint16, DEM_CODE)
Dem_Dcm_FilterNumberMemory(
  void
  )
{
  uint16          lNumberOfEvents;
  Dem_EventIdType lEventIdStart;
  Dem_EventIdType lEventIdEnd;
  Dem_EventIdType lEventId;
# if (DEM_CFG_SUPPORT_SEVERITY != STD_ON) || (DEM_FEATURE_NEED_OBD != STD_ON)
  uint8           lFilterCriteria;
# endif

# if (DEM_CFG_ISCONST_DESTINATION != STD_ON)
  if (Dem_Dcm_FilterDtcGetMemoryId() == DEM_CFG_MEMORYID_PRIMARY)
# endif
  {
    lEventIdStart = Dem_Cfg_GlobalPrimaryFirst();
    lEventIdEnd   = Dem_Cfg_GlobalPrimaryLast();
  }
# if (DEM_CFG_ISCONST_DESTINATION != STD_ON)
  else
# endif
  {
# if (DEM_FEATURE_NEED_SECONDARY == STD_ON)
    lEventIdStart  = Dem_Cfg_GlobalSecondaryFirst();
    lEventIdEnd    = Dem_Cfg_GlobalSecondaryLast();
# endif
  }

  lNumberOfEvents = 0;
# if (DEM_CFG_SUPPORT_SEVERITY != STD_ON) || (DEM_FEATURE_NEED_OBD != STD_ON)
  lFilterCriteria = Dem_Dcm_FilterGetCriteria();
# endif

# if (DEM_CFG_SUPPORT_SEVERITY != STD_ON)
  if (FALSE != DEM_DCM_TEST_FILTER_USESEVERITY(lFilterCriteria))
  { /* No DTC can match the filter */
    lEventIdStart = DEM_EVENT_INVALID;
  }
# endif
# if (DEM_FEATURE_NEED_OBD != STD_ON)
  if ( (FALSE != DEM_DCM_TEST_FILTER_DTCKIND_EMISSION(lFilterCriteria))
#  if (DEM_CFG_SUPPORT_OBDII != STD_ON)
    || (FALSE != DEM_DCM_TEST_FILTER_DTCFORMAT_OBD(lFilterCriteria))
#  endif
    )
  { /* No DTC can match the filter */
    lEventIdStart = DEM_EVENT_INVALID;
  }
# endif

  /* valid start value, so at least one event is available which may match the filter criteria */
  if (DEM_EVENT_INVALID != lEventIdStart)                                                                                        /* PRQA S 3355, 3358 */ /* MD_DEM_13.7, MD_DEM_13.7 */
  {
    for (lEventId = lEventIdStart; lEventId <= lEventIdEnd; lEventId++)
    {
      if (DEM_CFG_DTC_UDS_INVALID != Dem_Cfg_EventUdsDtc(lEventId))
      {
        if (E_NOT_OK != Dem_Dcm_FilterForEventMatch(lEventId))
        {
          ++lNumberOfEvents;
        }
      }
    }
  }
  return lNumberOfEvents;
}                                                                                                                                /* PRQA S 6010, 6030, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF*/
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_FilterPrimaryByEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FilterPrimaryByEvent(
  void
  )
{
  Dem_EventIdType lEventId;
  Dem_EventIdType lReturnValue;

  lEventId     = Dem_Dcm_FilterDtcGetEventIndex();
  lReturnValue = DEM_EVENT_INVALID;

  /* if last EventId is not valid or was still analyzed skip the filtering */
  if (lEventId != DEM_EVENT_INVALID)
  {
    Dem_EventIdType lEventIdLast;
# if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
    uint16 lFilterMarkerIndex;
    uint8 lFilterMarkerMask;
    uint8 lFilterMarkerValues;
# endif

    lEventIdLast = Dem_Cfg_GlobalPrimaryLast();
# if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
    /* calculate current marker index and mask */
    lFilterMarkerIndex  = DEM_DCM_FILTER_CALC_MARKER_INDEX(lEventId);
    lFilterMarkerMask   = DEM_DCM_FILTER_CALC_MARKER_MASK(lEventId);
    lFilterMarkerValues = Dem_Dcm_FilterGetReportedEvents(lFilterMarkerIndex);
# endif
    /* iterate through the EventIds and check filter criteria */
    for (; lEventId <= lEventIdLast; lEventId++)
    {
# if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
      /* take event into account if it was not reported before */
      if (0 == DEM_DCM_GET_FILTER_EVENT_MARKER(lFilterMarkerValues, lFilterMarkerMask))
# endif
      {
        /* EventId was not reported before, proceed */
        if (DEM_CFG_DTC_UDS_INVALID != Dem_Cfg_EventUdsDtc(lEventId))
        {
          if (E_NOT_OK != Dem_Dcm_FilterForEventMatch(lEventId))
          {
            /* identified an Event which matches the filter criteria */
            lReturnValue = lEventId;
            lEventId++;                                                                                                          /* PRQA S 2469 */ /* MD_DEM_13.6 */

            break;
          }
        }
      }
# if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)

      /* shift filter mask and raise marker index and get marker values from index if mask has a overflow */
      Dem_LROT1_ADD_ACTION_Byte(lFilterMarkerIndex,
                                lFilterMarkerValues = Dem_Dcm_FilterGetReportedEvents(lFilterMarkerIndex),
                                lFilterMarkerMask)
# endif
    }

    if (lEventId > lEventIdLast)
    { /* last EventId has been processed */
      Dem_Dcm_FilterDtcSetEventIndex(DEM_EVENT_INVALID);
    }
    else
    { /* write back the EventId ( which was raised by 1 for the next repetition) */
      Dem_Dcm_FilterDtcSetEventIndex(lEventId);
    }
  }
  /* else lReturnValue = DEM_EVENT_INVALID initially set */

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_FEATURE_NEED_SECONDARY == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_FilterSecondaryByEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FilterSecondaryByEvent(
  void
  )
{
  Dem_EventIdType lEventId;
  Dem_EventIdType lReturnValue;

  lEventId     = Dem_Dcm_FilterDtcGetEventIndex();
  lReturnValue = DEM_EVENT_INVALID;

  /* if last EventId is not valid or was still analysed skip the filtering */
  if (lEventId != DEM_EVENT_INVALID)
  {
    Dem_EventIdType lEventIdLast;
# if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
    uint16 lFilterMarkerIndex;
    uint8 lFilterMarkerMask;
    uint8 lFilterMarkerValues;
# endif
    lEventIdLast = Dem_Cfg_GlobalSecondaryLast();

# if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
    /* calculate current marker index and mask */
    lFilterMarkerIndex  = DEM_DCM_FILTER_CALC_MARKER_INDEX(lEventId);
    lFilterMarkerMask   = DEM_DCM_FILTER_CALC_MARKER_MASK(lEventId);
    lFilterMarkerValues = Dem_Dcm_FilterGetReportedEvents(lFilterMarkerIndex);
# endif
    /* iterate through the EventIds and check filter criteria */
    for (; lEventId <= lEventIdLast; lEventId++)
    {
# if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
      /* take event into account if it was not reported before */
      if (0 == DEM_DCM_GET_FILTER_EVENT_MARKER(lFilterMarkerValues, lFilterMarkerMask))
# endif
      {
        /* EventId was not reported before, proceed */
        if (DEM_CFG_DTC_UDS_INVALID != Dem_Cfg_EventUdsDtc(lEventId))
        {
          if (E_NOT_OK != Dem_Dcm_FilterForEventMatch(lEventId))
          {
            /* identified an Event which matches the filter criteria */
            lReturnValue = lEventId;
            lEventId++;                                                                                                          /* PRQA S 2469 */ /* MD_DEM_13.6 */

            break;
          }
        }
      }
# if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
      /* shift filter mask and raise marker index and get marker values from index if mask has a overflow */
      Dem_LROT1_ADD_ACTION_Byte(lFilterMarkerIndex,
                                lFilterMarkerValues = Dem_Dcm_FilterGetReportedEvents(lFilterMarkerIndex),
                                lFilterMarkerMask)
# endif
    }

    if (lEventId > lEventIdLast)
    { /* last EventId has been processed */
      Dem_Dcm_FilterDtcSetEventIndex(DEM_EVENT_INVALID);
    }
    else
    { /* write back the EventId ( which was raised by 1 for the next repetition) */
      Dem_Dcm_FilterDtcSetEventIndex(lEventId);
    }
  }
  /* else lReturnValue = DEM_EVENT_INVALID initially set */

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SECONDARY == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_FilterPrimaryChrono
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FilterPrimaryChrono(
  void
  )
{
  Dem_EventIdType lEventId;
  Dem_EventIdType lChronoIndex;

  lChronoIndex = Dem_Dcm_FilterDtcGetEventIndex();
  lEventId     = DEM_EVENT_INVALID;

  /* index set to 0 indicates that the filter was reset */
  if (lChronoIndex == 0)
  {
    lChronoIndex = Dem_Mem_PrimaryCurrentCount;
  }
  /* else */ /* last stored index initially loaded */

  while (lChronoIndex != 0)
  {
    uint16 lFilterMarkerIndex;
    uint8 lFilterMarkerValues;
    uint8 lFilterMarkerMask;

    lChronoIndex--;

    /* Get EventId for current index and marker if event was reported before */
    lEventId = Dem_Mem_EntryGetEventId(Dem_Mem_MemoryGetEntry(Dem_Mem_PrimaryGetChronology(lChronoIndex)));                      /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */

    /* verify that a valid EventId was returned */
    if (DEM_EVENT_INVALID != lEventId)
    {
      lFilterMarkerIndex  = DEM_DCM_FILTER_CALC_MARKER_INDEX(lEventId);
      lFilterMarkerMask   = DEM_DCM_FILTER_CALC_MARKER_MASK(lEventId);
      lFilterMarkerValues = Dem_Dcm_FilterGetReportedEvents(lFilterMarkerIndex);

      /* Check if EventId was reported before */
      if (DEM_DCM_GET_FILTER_EVENT_MARKER(lFilterMarkerValues, lFilterMarkerMask) == 0)
      {
        /* EventId was not reported before, proceed */
        if (E_NOT_OK != Dem_Dcm_FilterForEventMatch(lEventId))
        {
          /* identified an Event which matches the filter criteria, mark event as reported */
          lFilterMarkerValues = DEM_DCM_SET_FILTER_EVENT_MARKER(lFilterMarkerValues, lFilterMarkerMask);
          Dem_Dcm_FilterSetReportedEvents(lFilterMarkerIndex, lFilterMarkerValues);
          /* lEventId holds the valid EventId */

          break;
        }
        else
        { /* No filter match, continue with loop */
          lEventId = DEM_EVENT_INVALID;
        }
      }
      else
      { /* EventId was reported before, continue with loop */
        lEventId = DEM_EVENT_INVALID;
      }
    }
  }

  /* If end of chrono stack is reached, switch to filter by event id */
  if (lChronoIndex == 0)
  {
    Dem_Dcm_FilterDtcSetEventIndex(Dem_Cfg_GlobalPrimaryFirst());
    Dem_Dcm_FilterDtcSetFunctionPtr(Dem_Dcm_FilterPrimaryByEvent);

    if (DEM_EVENT_INVALID == lEventId)
    { /* no valid match, proceed with filtering by EventId */
      lEventId = Dem_Dcm_FilterPrimaryByEvent();
    }
  }
  else
  {
    /* store current position of chrono stack */
    Dem_Dcm_FilterDtcSetEventIndex(lChronoIndex);
  }

  return lEventId;
}
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_FEATURE_NEED_SECONDARY == STD_ON) && (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_FilterSecondaryChrono
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FilterSecondaryChrono(
  void
  )
{
  Dem_EventIdType lEventId;
  Dem_EventIdType lChronoIndex;

  lChronoIndex    = Dem_Dcm_FilterDtcGetEventIndex();
  lEventId        = DEM_EVENT_INVALID;

  /* index set to 0 indicates that the filter was reset */
  if (lChronoIndex == 0)
  {
    /* Initial call, set index to newest entry in Primary Memory */
    lChronoIndex = Dem_Mem_SecondaryCurrentCount;
  }
  /* else */ /* last stored index initially loaded */

  while(lChronoIndex != 0)
  {
    uint16 lFilterMarkerIndex;
    uint8 lFilterMarkerValues;
    uint8 lFilterMarkerMask;

    lChronoIndex--;

    /* Get EventId for current index and marker if event was reported before */
    lEventId = Dem_Mem_EntryGetEventId(Dem_Mem_MemoryGetEntry(Dem_Mem_SecondaryGetChronology(lChronoIndex)));                    /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */

    /* verify that a valid EventId was returned */
    if (DEM_EVENT_INVALID != lEventId)
    {
      lFilterMarkerIndex  = DEM_DCM_FILTER_CALC_MARKER_INDEX(lEventId);
      lFilterMarkerMask   = DEM_DCM_FILTER_CALC_MARKER_MASK(lEventId);
      lFilterMarkerValues = Dem_Dcm_FilterGetReportedEvents(lFilterMarkerIndex);

      /* Check if EventId was reported before */
      if (DEM_DCM_GET_FILTER_EVENT_MARKER(lFilterMarkerValues, lFilterMarkerMask) == 0)
      {
        /* EventId was not reported before, proceed */
        if (E_NOT_OK != Dem_Dcm_FilterForEventMatch(lEventId))
        {
          /* identified an Event which matches the filter criteria, mark event as reported */
          lFilterMarkerValues = DEM_DCM_SET_FILTER_EVENT_MARKER(lFilterMarkerValues, lFilterMarkerMask);
          Dem_Dcm_FilterSetReportedEvents(lFilterMarkerIndex, lFilterMarkerValues);
          /* lEventId holds the valid EventId */

          break;
        }
        else
        { /* No filter match, continue with loop */
          lEventId = DEM_EVENT_INVALID;
        }
      }
      else
      { /* EventId was reported before, continue with loop */
        lEventId = DEM_EVENT_INVALID;
      }
    }
  }

  /* If end of chrono stack is reached, switch to filter by event id */
  if (lChronoIndex == 0)
  {
    Dem_Dcm_FilterDtcSetEventIndex(Dem_Cfg_GlobalSecondaryFirst());
    Dem_Dcm_FilterDtcSetFunctionPtr(Dem_Dcm_FilterSecondaryByEvent);

    if (DEM_EVENT_INVALID == lEventId)
    { /* no valid match, proceed with filtering by EventId */
      lEventId = Dem_Dcm_FilterSecondaryByEvent();
    }
  }
  else
  {
    /* store current position of chrono stack */
    Dem_Dcm_FilterDtcSetEventIndex(lChronoIndex);
  }

  return lEventId;
}
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) && (DEM_CFG_SUPPORT_SECONDARY == STD_ON) && (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_FilterForEventMatch
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(Std_ReturnType, DEM_CODE)
Dem_Dcm_FilterForEventMatch(
  Dem_EventIdType  EventId
  )
{
  uint8    lEventStatus;
  uint8    lFilterCriteria;
  lFilterCriteria = Dem_Dcm_FilterGetCriteria();

# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
  if (Dem_Util_DtcGetMasterEvent(EventId) != EventId)
  {
    return E_NOT_OK;
  }
# endif

# if (DEM_FEATURE_NEED_TESTSUPPRESSION == STD_ON)
  if (FALSE != Dem_Esm_TestDtcSuppressed(EventId))
  { /* Suppressed DTCs are skipped */
    return E_NOT_OK;
  }
# endif

  lEventStatus = Dem_Util_DtcApplyExternalOnlyStatus(EventId, Dem_Util_DtcGetStatus(EventId));

  if ( (FALSE != DEM_DCM_TEST_FILTER_USESTATUSMASK(lFilterCriteria))
    && ((Dem_Dcm_FilterDtcGetStatusMask() & lEventStatus) == 0) )
  { /* Skip DTCs not matching the requested status mask */
    return E_NOT_OK;
  }

# if (DEM_CFG_SUPPORT_SEVERITY == STD_ON)
  if ( (FALSE != DEM_DCM_TEST_FILTER_USESEVERITY(lFilterCriteria))
    && ((Dem_Dcm_FilterDtcGetSeverityMask() & Dem_Cfg_EventSeverity(EventId)) == 0) )
  { /* Skip DTCs not matching the requested severity */
    return E_NOT_OK;
  }
# endif

  if (FALSE != DEM_DCM_TEST_FILTER_USEFDC(lFilterCriteria))
  {
    Std_ReturnType lGetFdcReturnValue;
    sint8 lFdc;

    lGetFdcReturnValue = Dem_Util_DtcGetFaultDetectionCounter(EventId, &lFdc);

    if (lGetFdcReturnValue != E_OK)
    { /* If FDC cannot be retrieved, the DTC does not match */
      return E_NOT_OK;
    }

    /* returned fault detection counter is valid, store it for later */
    Dem_Dcm_FilterDtcSetFdc(lFdc);

    if ( (lFdc <= 0)
      || (lFdc == 0x7f) )
    { /* skip passed, passing and qualified failed DTCs */
      return E_NOT_OK;
    }
  }

  /* If all tests pass, keep this DTC for processing */
  return E_OK;
}                                                                                                                                /* PRQA S 2006, 6010, 6030, 6080 */ /* MD_DEM_14.7, MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_DCM == STD_ON) */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_Dcm_FindEventByDTCAndOrigin
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_LOCAL FUNC(Dem_EventIdType, DEM_CODE)
Dem_Dcm_FindEventByDTCAndOrigin(
  uint32 DTC,
  Dem_DTCOriginType  DTCOrigin,
  P2VAR(uint8, AUTOMATIC, AUTOMATIC)  MemoryId
)
{
  Dem_EventIdType lEventId;

  lEventId = DEM_EVENT_INVALID;
  switch (DTCOrigin)
  {
  case DEM_DTC_ORIGIN_PRIMARY_MEMORY:
    *MemoryId = DEM_CFG_MEMORYID_PRIMARY;
    break;
# if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
  case DEM_DTC_ORIGIN_SECONDARY_MEMORY:
    *MemoryId = DEM_CFG_MEMORYID_SECONDARY;
    break;
# endif
# if (DEM_CFG_SUPPORT_MIRROR == STD_ON)
    case DEM_DTC_ORIGIN_MIRROR:
#  error "Not implemented"
      break;
# endif
  default:
    *MemoryId = DEM_CFG_MEMORYID_INVALID;
    break;
  }

  if (DEM_CFG_MEMORYID_INVALID != *MemoryId)
  {
    lEventId = Dem_Dcm_FindEventFromUdsDtc(DTC, *MemoryId, DEM_DCM_CLIENT_DCM);
# if (DEM_FEATURE_NEED_TESTSUPPRESSION == STD_ON)
    if (DEM_EVENT_INVALID != lEventId)
    {
      if (FALSE != Dem_Esm_TestDtcSuppressed(lEventId))
      {
        lEventId = DEM_EVENT_INVALID;
      }
    }
# endif
  }

  return lEventId;
}
#endif

#define DEM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/* ********************************************************************************************************************
 *  GLOBAL FUNCTIONS                                                                                              [API]
 *********************************************************************************************************************/

#define DEM_START_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

                                                                /* Callbacks */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_NvM_InitAdminData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_NvM_InitAdminData(
  void
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON) || (DEM_CFG_USE_DEFENSIVE_BEHAVIOR == STD_ON)
  if (Dem_InitState >= DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
#endif
  {
    uint8 lCycleIterator;

    /* ----- Implementation ------------------------------------------------ */
    Dem_Cfg_AdminData.ImplementationVersion = DIAG_ASR4DEM_VERSION;
    Dem_Cfg_AdminData.ConfigurationId = Dem_Cfg_GlobalConfigurationId();

    for (lCycleIterator = 0U; lCycleIterator < Dem_Cfg_GlobalCycleCount(); ++lCycleIterator)
    {
      Dem_Cfg_AdminData.CycleCounter[lCycleIterator] = 0U;
    }
#if (DEM_FEATURE_NEED_OVFLIND == STD_ON)
    Dem_Cfg_AdminData.MemoryOverflow = 0U;
#endif

#if (DEM_CFG_SUPPORT_OPCYCLE_STORAGE == STD_ON)
    Dem_Cfg_AdminData.CycleState = 0x00U;
#endif
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_NVMINIT_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
  /* The DEM expects that the NVM by itself marks the NVRAM block as dirty */
  return E_OK;
}

/* ****************************************************************************
 % Dem_NvM_InitStatusData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_NvM_InitStatusData(
  void
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState >= DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
#endif
  {
    Dem_EventIdType lEventId;

    /* ----- Implementation ------------------------------------------------ */
    for (lEventId = DEM_EVENT_FIRST; lEventId < Dem_Cfg_GlobalEventCount(); ++lEventId)
    {
      Dem_Mem_EventSetStatus(lEventId, DEM_UDS_STATUS_INITIALIZE);
#if (DEM_FEATURE_NEED_TRIPCOUNTER == STD_ON)
      Dem_Mem_EventSetTripCount(lEventId, 0);
#endif
    }

    Dem_Mem_SetFirstFailedEvent(DEM_EVENT_INVALID);
    Dem_Mem_SetFirstConfirmedEvent(DEM_EVENT_INVALID);
    Dem_Mem_SetMostRecentFailedEvent(DEM_EVENT_INVALID);
    Dem_Mem_SetMostRecentConfmdEvent(DEM_EVENT_INVALID);
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_NVMINIT_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  /* The DEM expects that the NVM by itself marks the NVRAM block as dirty */
  return E_OK;
}

#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
/* ****************************************************************************
 % Dem_NvM_InitDebounceData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_NvM_InitDebounceData(
  void
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState >= DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    Dem_MemSet(Dem_Cfg_DebounceData, 0x00, Dem_Cfg_GlobalDebounceStorageEventCount()*sizeof(uint16));                            /* PRQA S 0310 */ /* MD_DEM_11.4_cpy */
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_NVMINIT_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  /* The DEM expects that the NVM by itself marks the NVRAM block as dirty */
  return E_OK;
}
#endif

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
/* ****************************************************************************
 % Dem_NvM_InitEventAvailableData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_NvM_InitEventAvailableData(
  void
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState >= DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    Dem_MemSet(Dem_Cfg_EventAvailableData, 0x00, ((Dem_Cfg_GlobalEventCount() + 7) / 8));                                        /* PRQA S 0310 */ /* MD_DEM_11.4_cpy */
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_NVMINIT_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  /* The DEM expects that the NVM by itself marks the NVRAM block as dirty */
  return E_OK;
}
#endif

#if ((DEM_CFG_USE_NVM == STD_ON) && (DEM_CFG_SUPPORT_NVM_POLLING != STD_ON))
/* ****************************************************************************
 % Dem_NvM_JobFinished
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_NvM_JobFinished(
  uint8  ServiceId,                                                                                                              /* PRQA S 3206 */ /* MD_DEM_3206 */
  NvM_RequestResultType  JobResult                                                                                               /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  DEM_IGNORE_UNUSED_ARGUMENT(ServiceId)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */
# if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
  if (Dem_Nvm_CommitData.WriteState == DEM_NVM_COMMIT_WRITING)
  {
    if (JobResult != NVM_REQ_OK)
    { /* Write request aborted or otherwise failed. */
      Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_FAILED;
    }
    else
    {
      /* Continue with next block */
      Dem_Nvm_CommitData.WriteState = DEM_NVM_COMMIT_FINISHED;
    }
  }
  /* else: the NvM has finished with some job,  e.g. restoring a block
     during ReadAll.
     We must ignore these notifications, since the value passed as
     ServiceId is not specified. */
# else
  DEM_IGNORE_UNUSED_ARGUMENT(JobResult)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */
# endif
  return E_OK;
}
#endif /* ((DEM_CFG_USE_NVM == STD_ON) && (DEM_CFG_SUPPORT_NVM_POLLING != STD_ON )) */

                                                             /* Version Info */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_VERSION_INFO == STD_ON)
/* ****************************************************************************
 % Dem_GetVersionInfo
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_GetVersionInfo(
  P2VAR(Std_VersionInfoType, AUTOMATIC, DEM_APPL_DATA)  versioninfo
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (versioninfo == NULL_PTR)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    versioninfo->vendorID = DEM_VENDOR_ID;
    versioninfo->moduleID = DEM_MODULE_ID;
    versioninfo->sw_major_version = DEM_SW_MAJOR_VERSION;
    versioninfo->sw_minor_version = DEM_SW_MINOR_VERSION;
    versioninfo->sw_patch_version = DEM_SW_PATCH_VERSION;
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETVERSIONINFO_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
}
#endif /* (DEM_CFG_SUPPORT_VERSION_INFO == STD_ON) */

                                                   /* Interface EcuM <-> Dem */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_InitMemory
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_InitMemory(
  void
  )
{
  Dem_InitState = DEM_INIT_UNINITIALIZED;
}

/* ****************************************************************************
 % Dem_PreInit
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_PreInit(
  P2CONST(Dem_ConfigType, AUTOMATIC, DEM_INIT_DATA)  ConfigPtr                                                                   /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState != DEM_INIT_UNINITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
#endif
  {
#if (DEM_CFG_USE_INIT_POINTER == STD_ON)
    if (ConfigPtr == NULL_PTR)
    {
      Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
# if (DEM_CFG_VARIANT_POSTBUILD_LOADABLE == STD_ON)
      EcuM_BswErrorHook((uint16) DEM_MODULE_ID, (uint8) ECUM_BSWERROR_NULLPTR);
# endif
    }
    else
# if (DEM_CFG_VARIANT_POSTBUILD_LOADABLE == STD_ON)
    if (Dem_Cfg_InitPtrFinalMagicNumber(ConfigPtr) != DEM_CFG_FINAL_MAGIC_NUMBER)
    {
      EcuM_BswErrorHook((uint16) DEM_MODULE_ID, (uint8) ECUM_BSWERROR_MAGICNUMBER);
    }
    else
    if (Dem_Cfg_InitPtrCompatibilityVersion(ConfigPtr) != DEM_CFG_GEN_COMPATIBILITY_VERSION)
    {
      EcuM_BswErrorHook((uint16) DEM_MODULE_ID, (uint8) ECUM_BSWERROR_COMPATIBILITYVERSION);
    }
    else
# endif
#endif
    {
      /* ----- Implementation ---------------------------------------------- */
#if (DEM_CFG_USE_INIT_POINTER == STD_ON)
      Dem_GlobalConfigPtr = ConfigPtr;
#else
      DEM_IGNORE_UNUSED_ARGUMENT(ConfigPtr)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */
#endif

      Dem_Queue_PreInit();
      Dem_Mem_PreInit();
      Dem_Esm_PreInit();

      /* Initialize enable and storage conditions (all enabled due to init phase) */
      Dem_CurrentEnableConditionStates = 0xffffffffU;
#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
      Dem_NextEnableConditionStates = Dem_CurrentEnableConditionStates;
#endif

#if (DEM_CFG_SUPPORT_STORAGE_CONDITIONS == STD_ON)
      Dem_StorageConditionStates = 0xffffffffU;
#endif

      /* At this point:
       - BSW error reporting is enabled (Dem_ReportErrorStatus)
       - NvM has write access to RAM buffers (Dem may not access them!) */
      Dem_InitState = DEM_INIT_PREINITIALIZED;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_PREINIT_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
}

/* ****************************************************************************
 % Dem_Init
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_Init(
  P2CONST(Dem_ConfigType, AUTOMATIC, DEM_INIT_DATA)  ConfigPtr                                                                   /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if ((Dem_InitState != DEM_INIT_PREINITIALIZED) && (Dem_InitState != DEM_INIT_SHUTDOWN))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
#if (DEM_CFG_USE_INIT_POINTER == STD_ON)
    if (ConfigPtr != NULL_PTR)
    {
# if (DEM_CFG_VARIANT_POSTBUILD_LOADABLE == STD_ON)
      if (Dem_Cfg_InitPtrFinalMagicNumber(ConfigPtr) != DEM_CFG_FINAL_MAGIC_NUMBER)
      {
        EcuM_BswErrorHook((uint16) DEM_MODULE_ID, (uint8) ECUM_BSWERROR_MAGICNUMBER);
      }
      else
      if (Dem_Cfg_InitPtrCompatibilityVersion(ConfigPtr) != DEM_CFG_GEN_COMPATIBILITY_VERSION)
      {
        EcuM_BswErrorHook((uint16) DEM_MODULE_ID, (uint8) ECUM_BSWERROR_COMPATIBILITYVERSION);
      }
      else
# endif
      {
        /* Replace preliminary with final configuration */
        Dem_GlobalConfigPtr = ConfigPtr;
      }
    }
#else
    DEM_IGNORE_UNUSED_ARGUMENT(ConfigPtr)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */
#endif

  /* Initialize enable and storage conditions (based on configuration) */
    Dem_CurrentEnableConditionStates = Dem_Cfg_GlobalEnableCondInit();
#if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
    Dem_NextEnableConditionStates = Dem_CurrentEnableConditionStates;
#endif
#if (DEM_CFG_SUPPORT_STORAGE_CONDITIONS == STD_ON)
    Dem_StorageConditionStates = Dem_Cfg_GlobalStorageCondInit();
#endif
    Dem_Queue_Init();
#if (DEM_CFG_USE_NVM == STD_ON)
    Dem_Nvm_Init();
#endif
    Dem_Mem_Init();
    Dem_Esm_Init();
    Dem_Dcm_Init();

    Dem_InitState = DEM_INIT_INITIALIZED;
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_INIT_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
}                                                                                                                                /* PRQA S 6050 */ /* MD_MSR_STCAL */

/* ****************************************************************************
 % Dem_Shutdown
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_Shutdown(
  void
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */

#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
    boolean lPostRunRequested;
    lPostRunRequested = FALSE;
    (void)Dem_PostRunRequested(&lPostRunRequested);
    if (FALSE != lPostRunRequested)
    { /* Only set the error, but perform the shutdown. We are not going to stop
       * the shutdown anyway, so rescue as much state as possible */
      Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
    }
#endif

    Dem_InitState = DEM_INIT_SHUTDOWN;

#if (DEM_CFG_SUPPORT_OPCYCLE_STORAGE == STD_ON)
    /* copy back cycle state for NVRAM storage */
    Dem_Cfg_AdminData.CycleState = Dem_Mem_CurrentCycleState;
#endif

#if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
    /* copy debounce values from debounce array to nvram mirror */
    Dem_Mem_CopyDataDebounceNv();
    Dem_Mem_DebounceSetBlockState(DEM_NVM_BLOCKSTATE_DIRTY);
#endif

    Dem_Queue_Shutdown();

#if (DEM_CFG_SUPPORT_OPCYCLE_STORAGE != STD_ON) || (DEM_CFG_SUPPORT_OPCYCLE_AUTOMATIC_END == STD_ON)
    Dem_Esm_Shutdown();
#endif

#if (DEM_CFG_USE_NVM == STD_ON)
    Dem_Nvm_Shutdown();
#endif
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SHUTDOWN_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
}

                                                              /* Cyclic task */
/* ------------------------------------------------------------------------- */

#if (DEM_FEATURE_NEED_ENGINE_RUN_TIME == STD_ON) || (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
/* ****************************************************************************
 % Dem_MainFunctionTimer
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_MAINFUNC_LINKAGE FUNC(void, DEM_CODE)
Dem_MainFunctionTimer(
  void
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState <= DEM_INIT_PREINITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if (Dem_InitState == DEM_INIT_INITIALIZED)
    {
# if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
      Dem_Esm_MainFunction();
# endif
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_MAINFUNCTION_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
}
#endif

/* ****************************************************************************
 % Dem_MainFunctionWorker
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
DEM_MAINFUNC_LINKAGE FUNC(void, DEM_CODE)
Dem_MainFunctionWorker(
  void
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState <= DEM_INIT_PREINITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if (Dem_InitState == DEM_INIT_INITIALIZED)
    {
      Dem_Queue_MainFunction();
#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
      Dem_Nvm_MainFunction();
#endif
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_MAINFUNCTION_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
}

#if (DEM_CFG_SUPPORT_SPLIT_TASKS != STD_ON)
/* ****************************************************************************
 % Dem_MainFunction
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_MainFunction(
  void
  )
{
#if (DEM_FEATURE_NEED_ENGINE_RUN_TIME == STD_ON) || (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
  Dem_MainFunctionTimer();
#endif
  Dem_MainFunctionWorker();
}
#endif

                                        /* Interface BSW/Cdd monitor <-> Dem */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_ReportErrorStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_ReportErrorStatus(
  Dem_EventIdType  EventId,
  Dem_EventStatusType  EventStatus
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState < DEM_INIT_PREINITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (DEM_CFG_EVENT_KIND_BSW != Dem_Cfg_EventKind(EventId))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventStatus >= DEM_EVENT_STATUS_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# if (DEM_FEATURE_NEED_DEBOUNCE != STD_ON)
  if ((EventStatus != DEM_EVENT_STATUS_FAILED) && (EventStatus != DEM_EVENT_STATUS_PASSED))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
# if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
  if ((Dem_Cfg_EventSupportDebounceNv(EventId) != FALSE) && (Dem_InitState != DEM_INIT_INITIALIZED))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
# endif
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ( (Dem_Mem_GetCycleStatus(Dem_Cfg_EventOperationCycle(EventId)) == DEM_QUEUE_CYCLE_STARTED)                               /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
      && (FALSE != Dem_Cfg_EventAvailableInVariant(EventId))
#endif
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
      && (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(EventId)))
#endif
     )
    {
#if (DEM_FEATURE_NEED_LATCHTESTFAILED == STD_ON)
      if ( (Dem_InitState != DEM_INIT_INITIALIZED)                                                                               /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
        || (FALSE == Dem_Esm_TestLatchedTestFailed(EventId)))
#endif
      {
        (void)Dem_Esm_EventUpdateAsync_Queued(EventId, EventStatus);
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_REPORTERRORSTATUS_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

                                      /* Service Interface DiagnosticMonitor */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_SetEventStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetEventStatus(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  Dem_EventStatusType  EventStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (DEM_CFG_EVENT_KIND_SWC != Dem_Cfg_EventKind(EventId))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventStatus >= DEM_EVENT_STATUS_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# if (DEM_FEATURE_NEED_DEBOUNCE != STD_ON)
  if ((EventStatus != DEM_EVENT_STATUS_FAILED) && (EventStatus != DEM_EVENT_STATUS_PASSED))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ( (Dem_Mem_GetCycleStatus(Dem_Cfg_EventOperationCycle(EventId)) == DEM_QUEUE_CYCLE_STARTED)                               /* PRQA S 3415 */ /* MD_DEM_12.4_cf */
#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
      && (FALSE != Dem_Cfg_EventAvailableInVariant(EventId))
#endif
#if (DEM_FEATURE_NEED_LATCHTESTFAILED == STD_ON)
      && (FALSE == Dem_Esm_TestLatchedTestFailed(EventId))
#endif
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
      && (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(EventId)))
#endif
      )
    {
#if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON) || (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
      if (
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON)
        (DEM_CFG_COMBINED_GROUP_INVALID != Dem_Cfg_EventCombinedGroup(EventId))
# endif
# if (DEM_FEATURE_NEED_TYPE1_COMBINATION == STD_ON) && (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
        ||
# endif
# if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
        (DEM_CFG_DEBOUNCETYPE_TIMER == Dem_Cfg_EventDebounceType(EventId))
# endif
        )
      { /* Process Combined Events on task level */
        lReturnValue = Dem_Esm_EventUpdateAsync_Queued(EventId, EventStatus);
      }
      else
#endif
      {
        lReturnValue = Dem_Esm_EventUpdateAsync_Immediate(EventId, EventStatus);
      }
    }
    /* else: event status change ignored, notify by returning E_NOT_OK */
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETEVENTSTATUS_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_ResetEventStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_ResetEventStatus(
  Dem_EventIdType  EventId                                                                                                       /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if (FALSE != DEM_ESM_TEST_ENABLECONDITION(Dem_CurrentEnableConditionStates, DEM_ENABLECONDITION_CONTROLDTCSETTING))
    { /* DTC setting is enabled, proceed */
      {
#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
        if (FALSE != Dem_Cfg_EventAvailableInVariant(EventId))
#endif
        {
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
          if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(EventId)))
#endif
          {
            lReturnValue = Dem_Esm_EventReset_Async(EventId);
          }
        }
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_RESETEVENTSTATUS_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_MIF */

/* ****************************************************************************
 % Dem_ResetEventDebounceStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_ResetEventDebounceStatus(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  Dem_DebounceResetStatusType  DebounceResetStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState < DEM_INIT_PREINITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if ((EventId >= Dem_Cfg_GlobalEventCount()) || (EventId == DEM_EVENT_INVALID))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (DebounceResetStatus >= DEM_DEBOUNCE_STATUS_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# if (DEM_CFG_SUPPORT_DEBOUNCE_NV == STD_ON)
  if ((Dem_Cfg_EventSupportDebounceNv(EventId) != FALSE) && (Dem_InitState != DEM_INIT_INITIALIZED))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
  }
  else
# endif
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
    if (FALSE != Dem_Cfg_EventAvailableInVariant(EventId))
#endif
    {
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
      if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(EventId)))
#endif
      {
        Dem_Esm_EventResetDebounceState(EventId, DebounceResetStatus);
        lReturnValue = E_OK;
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_RESETEVENTDEBOUNCESTATUS_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_PrestoreFreezeFrame
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_PrestoreFreezeFrame(
  Dem_EventIdType  EventId                                                                                                       /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ( (DEM_CFG_DTC_UDS_INVALID != Dem_Cfg_EventUdsDtc(EventId))
      && (DEM_MEM_INVALID_PRESTORAGE_REF != Dem_Cfg_EventPrestorageIndex(EventId))
#  if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
      && (FALSE != Dem_Cfg_EventAvailableInVariant(EventId))
#  endif
#  if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
      && (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(EventId)))
#  endif
      )
    { /* Only pre-store for externally visible Events that support prestorage */
      lReturnValue = Dem_Esm_EventPrestorageUpdate(EventId);
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_PRESTOREFREEZEFRAME_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}
#endif

#if (DEM_CFG_SUPPORT_PRESTORED_FF == STD_ON)
/* ****************************************************************************
 % Dem_ClearPrestoredFreezeFrame
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_ClearPrestoredFreezeFrame(
  Dem_EventIdType  EventId                                                                                                       /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ( (DEM_MEM_INVALID_PRESTORAGE_REF != Dem_Cfg_EventPrestorageIndex(EventId))
# if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
      && (FALSE != Dem_Cfg_EventAvailableInVariant(EventId))
# endif
# if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
      && (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(EventId)))
# endif
      )
    {
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
      Dem_EnterCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */

      lReturnValue = Dem_Esm_EventPrestorageClear(EventId);

      Dem_LeaveCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_CLEARPRESTOREDFREEZEFRAME_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}
#endif

                                         /* Service Interface DiagnosticInfo */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_GetEventStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetEventStatus(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  P2VAR(Dem_EventStatusExtendedType, AUTOMATIC, DEM_APPL_DATA)  EventStatusExtended
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

#if (DEM_CFG_USE_DEFENSIVE_BEHAVIOR == STD_ON) \
  || (DEM_CFG_USE_DET == STD_ON) \
  || (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON) \
  || (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
  lReturnValue = E_NOT_OK;
#endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == EventStatusExtended)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
    if (FALSE != Dem_Cfg_EventAvailableInVariant(EventId))
#endif
    {
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
      if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(EventId)))
#endif
      {
        *EventStatusExtended = Dem_Mem_EventGetStatus(EventId);

        lReturnValue = E_OK;
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETEVENTSTATUS_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_GetEventFailed
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetEventFailed(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA)  EventFailed
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

#if (DEM_CFG_USE_DEFENSIVE_BEHAVIOR == STD_ON) \
  || (DEM_CFG_USE_DET == STD_ON) \
  || (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON) \
  || (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
  lReturnValue = E_NOT_OK;
#endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == EventFailed)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
    if (FALSE != Dem_Cfg_EventAvailableInVariant(EventId))
#endif
    {
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
      if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(EventId)))
#endif
      {
        if (FALSE != DEM_ESM_TEST_UDS_STATUS_TF(Dem_Mem_EventGetStatus(EventId)))
        {
          *EventFailed = TRUE;
        }
        else
        {
          *EventFailed = FALSE;
        }
        lReturnValue = E_OK;
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETEVENTFAILED_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_GetEventTested
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetEventTested(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA)  EventTested
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == EventTested)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ( (Dem_Mem_GetCycleStatus(Dem_Cfg_EventOperationCycle(EventId)) == DEM_QUEUE_CYCLE_STARTED)
#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
      && (FALSE != Dem_Cfg_EventAvailableInVariant(EventId))
#endif
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
      && (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(EventId)))
#endif
      )
    {
      if (FALSE == DEM_ESM_TEST_UDS_STATUS_TNCTOC(Dem_Mem_EventGetStatus(EventId)))
      {
        *EventTested = TRUE;
      }
      else
      {
        *EventTested = FALSE;
      }
      lReturnValue = E_OK;
    }
    /* else: with stopped cycle the bit value is undecided */
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETEVENTTESTED_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_GetDTCOfEvent
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetDTCOfEvent(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  Dem_DTCFormatType  DTCFormat,
  P2VAR(uint32, AUTOMATIC, DEM_APPL_DATA)  DTCOfEvent
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (DTCFormat >= DEM_DTC_FORMAT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == DTCOfEvent)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    uint32 lDtc;

    /* ----- Implementation ------------------------------------------------ */
#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
    if (FALSE != Dem_Cfg_EventAvailableInVariant(EventId))
#endif
    {
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
      if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(EventId)))
#endif
      {
        /* Dispatch requested DTC format */
        switch (DTCFormat)
        {
        case DEM_DTC_FORMAT_UDS:
          lDtc = Dem_Cfg_EventUdsDtc(EventId);
          if (DEM_CFG_DTC_UDS_INVALID != lDtc)
          {
            *DTCOfEvent = lDtc;
            lReturnValue = E_OK;
          }
          else
          {
            lReturnValue = DEM_E_NO_DTC_AVAILABLE;
          }
          break;

        default:                                                                                                                 /* PRQA S 2018 */ /* MD_DEM_14.1 */
          /* MISRA case */
          break;
        }
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETDTCOFEVENT_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_GetFaultDetectionCounter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetFaultDetectionCounter(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  P2VAR(sint8, AUTOMATIC, DEM_APPL_DATA)  FaultDetectionCounter
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == FaultDetectionCounter)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
    if (FALSE != Dem_Cfg_EventAvailableInVariant(EventId))
#endif
    {
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
      if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(EventId)))
#endif
      {
        switch (Dem_Cfg_EventDebounceType(EventId))
        {
#if (DEM_CFG_SUPPORT_DEBOUNCE_COUNTER == STD_ON)
        case DEM_CFG_DEBOUNCETYPE_COUNTER:
          *FaultDetectionCounter = Dem_Data_CalculateFDC_CounterBased(EventId,
                                                                      Dem_Mem_EventGetDebounceValue(EventId));
          lReturnValue = E_OK;
          break;
#endif
#if (DEM_FEATURE_NEED_DEBOUNCE_TIME == STD_ON)
        case DEM_CFG_DEBOUNCETYPE_TIMER:
          *FaultDetectionCounter = Dem_Data_CalculateFDC_TimeBased(EventId,
                                                                   Dem_Mem_EventGetDebounceValue(EventId),
                                                                   (uint8)DEM_ESM_GET_DEBOUNCE_STATUS(Dem_Mem_EventGetInternalStatus(EventId)));
          lReturnValue = E_OK;
          break;
#endif
#if (DEM_CFG_SUPPORT_DEBOUNCE_MONITORINTERNAL == STD_ON)
        case DEM_CFG_DEBOUNCETYPE_EXTERNAL:
          if (NULL_PTR != Dem_Cfg_EventCbkGetFDC(EventId))
          {
            sint8 lFdc;
            lReturnValue = (*Dem_Cfg_EventCbkGetFDC(EventId))(&lFdc);
            if (E_OK == lReturnValue)
            {
              *FaultDetectionCounter = lFdc;
            }
          }
          else
          {
            lReturnValue = DEM_E_NO_FDC_AVAILABLE;
          }
          break;
#endif
        default:
          break;
        }
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETFAULTDETECTIONCOUNTER_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_GetEventFreezeFrameData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetEventFreezeFrameData(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330, 3206 */ /* MD_DEM_16.4_rte, MD_DEM_3206 */
  uint8  RecordNumber,                                                                                                           /* PRQA S 3206 */ /* MD_DEM_3206 */
  boolean  ReportTotalRecord,                                                                                                    /* PRQA S 3206 */ /* MD_DEM_3206 */
  uint16  DataId,                                                                                                                /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer                                                                             /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == DestBuffer)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
#if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
    if (FALSE != Dem_Cfg_EventAvailableInVariant(EventId))
#endif
    {
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
      if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(EventId)))
#endif
      {
        if (RecordNumber == 0x00)
        {
          lReturnValue = DEM_E_WRONG_RECORDNUMBER;
        }
#if (DEM_CFG_SUPPORT_SRECS == STD_ON)
        else
        {
          Dem_EventIdType lMasterEventId;

          lMasterEventId = Dem_Util_DtcGetMasterEvent(EventId);
          lReturnValue = Dem_Dcm_CopyDidFromSRec(lMasterEventId, RecordNumber, ReportTotalRecord, DataId, DestBuffer);
        }
#else
        DEM_IGNORE_UNUSED_ARGUMENT(EventId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */
        DEM_IGNORE_UNUSED_ARGUMENT(RecordNumber)                                                                                 /* PRQA S 3112 */ /* MD_DEM_14.2 */
        DEM_IGNORE_UNUSED_ARGUMENT(ReportTotalRecord)                                                                            /* PRQA S 3112 */ /* MD_DEM_14.2 */
        DEM_IGNORE_UNUSED_ARGUMENT(DataId)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
        DEM_IGNORE_UNUSED_ARGUMENT(DestBuffer)                                                                                   /* PRQA S 3112 */ /* MD_DEM_14.2 */
#endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) */
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETEVENTFREEZEFRAMEDATA_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif
  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

/* ****************************************************************************
 % Dem_GetEventExtendedDataRecord
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetEventExtendedDataRecord(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330, 3206 */ /* MD_DEM_16.4_rte, MD_DEM_3206 */
  uint8  RecordNumber,                                                                                                           /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  DestBuffer                                                                             /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

#if (DEM_CFG_USE_DEFENSIVE_BEHAVIOR == STD_ON) \
  || (DEM_CFG_USE_DET == STD_ON) \
  || ((DEM_CFG_SUPPORT_ERECS == STD_ON) && (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)) \
  || ((DEM_CFG_SUPPORT_ERECS == STD_ON) && (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON))
  lReturnValue = E_NOT_OK;
#endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (Dem_InitState != DEM_INIT_INITIALIZED)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (EventId >= Dem_Cfg_GlobalEventCount())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (EventId == DEM_EVENT_INVALID)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == DestBuffer)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
#if (DEM_CFG_SUPPORT_ERECS == STD_ON)
# if (DEM_CFG_ISCONST_AVAILABLEINVARIANT != STD_ON)
    if (FALSE != Dem_Cfg_EventAvailableInVariant(EventId))
# endif
    {
# if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
      if (FALSE == DEM_ESM_TEST_EVENT_DISCONNECTED(Dem_Mem_EventGetInternalStatus(EventId)))
# endif
      {
        /* Find the Record number */
        Dem_EventIdType lMasterEventId;
        lMasterEventId = Dem_Util_DtcGetMasterEvent(EventId);
        lReturnValue = Dem_Dcm_CopyERecs(lMasterEventId, RecordNumber, DestBuffer);
      }
    }
#else /* (DEM_CFG_SUPPORT_ERECS == STD_ON) */
    DEM_IGNORE_UNUSED_ARGUMENT(EventId)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(RecordNumber)                                                                                     /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DestBuffer)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
    lReturnValue = E_NOT_OK;
#endif
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETEVENTEXTENDEDDATARECORD_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

                                         /* Service Interface DTCSuppression */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DTCSUPPRESSION == STD_ON)
/* ****************************************************************************
 % Dem_SetDTCSuppression
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetDTCSuppression(
  uint32  DTC,
  Dem_DTCFormatType  DTCFormat,
  boolean  SuppressionStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_DTC_FORMAT_INVALID <= DTCFormat)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (TRUE < SuppressionStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if ((DEM_DTC_FORMAT_UDS == DTCFormat) && (DEM_CFG_DTC_UDS_INVALID == DTC))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    uint16 lEventId;

    /* ----- Implementation ------------------------------------------------ */
    if (DEM_DTC_FORMAT_UDS == DTCFormat)
    {
      lEventId = Dem_Cfg_FindEventFromUdsDtc(DTC, DEM_CFG_MEMORYID_PRIMARY);
# if (DEM_FEATURE_NEED_SECONDARY == STD_ON)
      if (DEM_EVENT_INVALID == lEventId)
      {
        lEventId = Dem_Cfg_FindEventFromUdsDtc(DTC, DEM_CFG_MEMORYID_SECONDARY);
      }
# endif
    }
    else
    {
      lEventId = DEM_EVENT_INVALID;
    }

    if (DEM_EVENT_INVALID != lEventId)
    {
      if (FALSE != SuppressionStatus)
      {
        Dem_Esm_EventSetDtcSuppression(lEventId);
      }
      else
      {
        Dem_Esm_EventResetDtcSuppression(lEventId);
      }
      lReturnValue = E_OK;
    }
    /* else: DTC not supported */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETDTCSUPPRESSION_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif

                                       /* Service Interface EventSuppression */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_SUPPORT_EVENTSUPPRESSION == STD_ON)
/* ****************************************************************************
 % Dem_SetEventSuppression
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetEventSuppression(
  uint16  EventId,
  boolean  SuppressionStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_PREINITIALIZED > Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_EVENT_INVALID == EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (Dem_Cfg_GlobalEventCount() <= EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (TRUE < SuppressionStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if (FALSE != SuppressionStatus)
    {
      Dem_Esm_EventSetSuppression(EventId);
    }
    else
    {
      Dem_Esm_EventResetSuppression(EventId);
    }
    lReturnValue = E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETEVENTSUPPRESSION_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

                                         /* Service Interface EventAvailable */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 % Dem_SetEventAvailable
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetEventAvailable(
  uint16  EventId,
  boolean  AvailableStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
#  if (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
#  else
  if (DEM_INIT_PREINITIALIZED > Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
#  endif
  else
  if (DEM_EVENT_INVALID == EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (Dem_Cfg_GlobalEventCount() <= EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (TRUE < AvailableStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if (FALSE != AvailableStatus)
    {
      Dem_Esm_EventReconnect(EventId);
      lReturnValue = E_OK;
    }
    else
    {
      lReturnValue = Dem_Esm_EventDisconnect(EventId);
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETEVENTAVAILABLE_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) */

#if (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON)
/* ****************************************************************************
 % Dem_GetEventAvailable
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetEventAvailable(
  uint16  EventId,                                                                                                               /* PRQA S 1330, 3206 */ /* MD_DEM_16.4_rte, MD_DEM_3206 */
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA)  AvailableStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
#  if (DEM_CFG_SUPPORT_EVENTAVAILABLE_NV == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
#  else
  if (DEM_INIT_PREINITIALIZED > Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
#  endif
  else
  if (DEM_EVENT_INVALID == EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (Dem_Cfg_GlobalEventCount() <= EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == AvailableStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    Dem_Cfg_EventInternalStatusType lInternalStatus;

    /* ----- Implementation ------------------------------------------------ */
    lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
    *AvailableStatus = (boolean)(DEM_ESM_TEST_EVENT_DISCONNECTED(lInternalStatus) == FALSE);
    lReturnValue = E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETEVENTAVAILABLE_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_EVENTAVAILABLE == STD_ON) */

                                         /* Service Interface OperationCycle */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_SetOperationCycleState
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetOperationCycleState(
  uint8  OperationCycleId,                                                                                                       /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  Dem_OperationCycleStateType  CycleState
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
    lReturnValue = E_NOT_OK;
  }
  else
  if (Dem_Cfg_GlobalCycleCount() <= OperationCycleId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = E_NOT_OK;
  }
  else
  if (DEM_CYCLE_STATE_INVALID <= CycleState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = E_NOT_OK;
  }
  else
#endif
  {
    boolean lOldCycleStatus;

    /* ----- Implementation ------------------------------------------------ */
    lOldCycleStatus = Dem_Mem_GetCycleStatus(OperationCycleId);

    {
      if ( (lOldCycleStatus != DEM_QUEUE_CYCLE_STOPPED)
        || (CycleState != DEM_CYCLE_STATE_END) )
      {
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: StateManager */
        Dem_EnterCritical_StateManager();                                                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */

        if (FALSE != Dem_Queue_IsPendingCycle(OperationCycleId))
        {
          boolean lPendingCycleStatus;

          lPendingCycleStatus = Dem_Queue_GetPendingCycle(OperationCycleId);

          if (DEM_QUEUE_CYCLE_STOPPED == lPendingCycleStatus)
          { /* START->END, END->START through two calls to the function is accepted and queued */
            if (CycleState == DEM_CYCLE_STATE_START)
            { /* START->END, END->START through two calls to the function is accepted and queued */                              /* PRQA S 0715 */ /* MD_MSR_1.1_715 */
              Dem_Queue_SetPendingCycle(OperationCycleId, DEM_QUEUE_CYCLE_STARTED);
            }
          }
        }
        else
        {
          Dem_Queue_SetPendingCycle(OperationCycleId,
            ( (CycleState == DEM_CYCLE_STATE_START)
              ?DEM_QUEUE_CYCLE_STARTED
              :DEM_QUEUE_CYCLE_STOPPED)
            );
        }

        Dem_LeaveCritical_StateManager();                                                                                        /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: StateManager */
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETOPERATIONCYCLESTATE_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */

                                             /* Service Interface AgingCycle */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_AGINGCYCLE_STATE_API == STD_ON)
/* ****************************************************************************
 % Dem_SetAgingCycleState
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetAgingCycleState(
  uint8  AgingCycleId                                                                                                            /* PRQA S 1330, 3206 */ /* MD_DEM_16.4_rte, MD_DEM_3206 */
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    DEM_IGNORE_UNUSED_ARGUMENT(AgingCycleId)                                                                                     /* PRQA S 3112 */ /* MD_DEM_14.2 */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETAGINGCYCLESTATE_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return E_NOT_OK;
}
#endif

                                     /* Service Interface ExternalAgingCycle */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_AGINGCYCLE_COUNTER_API == STD_ON)
/* ****************************************************************************
 % Dem_SetAgingCycleCounterValue
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetAgingCycleCounterValue(
  uint8  CounterValue                                                                                                            /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    DEM_IGNORE_UNUSED_ARGUMENT(CounterValue)                                                                                     /* PRQA S 3112 */ /* MD_DEM_14.2 */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETAGINGCYCLECOUNTERVALUE_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return E_NOT_OK;
}
#endif

                                                  /* Service Interface CddIf */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_ClearDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_ClearDTC(
  uint32  DTC,
  Dem_DTCFormatType  DTCFormat,
  Dem_DTCOriginType  DTCOrigin
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    lReturnValue = DEM_CLEAR_FAILED;
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_DTC_FORMAT_INVALID <= DTCFormat)
  {
    lReturnValue = DEM_CLEAR_WRONG_DTC;
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if ((0 == DTCOrigin) || (DEM_DTC_ORIGIN_INVALID <= DTCOrigin))
  {
    lReturnValue = DEM_CLEAR_WRONG_DTCORIGIN;
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
    Dem_Queue_ClearRequestType lClearRequest;

    lClearRequest.ClearFormat = DTCFormat;
    lClearRequest.ClearMemoryId = Dem_Dcm_MemoryIdFromOrigin(DTCOrigin);
    lClearRequest.ClearClient = DEM_DCM_CLIENT_APPLICATION;
    lReturnValue = Dem_Dcm_ClearDtc_Internal(DTC, &lClearRequest);
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_CLEARDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}

                                        /* Service Interface EnableCondition */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_ENABLE_CONDITIONS == STD_ON)
/* ****************************************************************************
 % Dem_SetEnableCondition
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetEnableCondition(
  uint8  EnableCondition,                                                                                                        /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  boolean  ConditionFulfilled
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if ( (DEM_ENABLECONDITION_CONTROLDTCSETTING == EnableCondition)
    || (Dem_Cfg_GlobalEnableCondCount() < EnableCondition) )
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: StateManager */
    Dem_EnterCritical_StateManager();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* Map the given enable condition state to bit array */
    if (FALSE == ConditionFulfilled)
    { /* clear enable condition */
# if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
      Dem_NextEnableConditionStates = DEM_ESM_RESET_ENABLECONDITION(Dem_NextEnableConditionStates, EnableCondition);
# endif
      Dem_CurrentEnableConditionStates = DEM_ESM_RESET_ENABLECONDITION(Dem_CurrentEnableConditionStates, EnableCondition);
    }
    else
    { /* set enable condition */
# if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
      Dem_NextEnableConditionStates = DEM_ESM_SET_ENABLECONDITION(Dem_NextEnableConditionStates, EnableCondition);
# else
      Dem_CurrentEnableConditionStates = DEM_ESM_SET_ENABLECONDITION(Dem_CurrentEnableConditionStates, EnableCondition);
# endif
    }

    Dem_LeaveCritical_StateManager();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: StateManager */

    lReturnValue = E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETENABLECONDITION_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif /* (DEM_CFG_SUPPORT_ENABLE_CONDITIONS == STD_ON) */

#if (DEM_CFG_SUPPORT_ENABLE_CONDITIONS == STD_ON)
/* ****************************************************************************
 % Dem_GetEventEnableCondition
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetEventEnableCondition(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 1330, 3206 */ /* MD_DEM_16.4_rte, MD_DEM_3206 */
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA)  ConditionFulfilled
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if ((DEM_EVENT_INVALID == EventId) || (Dem_Cfg_GlobalEventCount() <= EventId))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == ConditionFulfilled)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */

    /* Depeding on configuration, EventId is not used to select enable conditions */
    DEM_IGNORE_UNUSED_ARGUMENT(EventId)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */

    if (((Dem_CurrentEnableConditionStates | ((uint32)0x01U)) & Dem_Cfg_EventEnableConditions(EventId)) != Dem_Cfg_EventEnableConditions(EventId))
    { /* enable condition is not fulfilled (ignoring DTC setting) */
      *ConditionFulfilled = FALSE;
    }
    else
    {
      *ConditionFulfilled = TRUE;
    }
    lReturnValue = E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETENABLECONDITION_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif /* (DEM_CFG_SUPPORT_ENABLE_CONDITIONS == STD_ON) */

                                       /* Service Interface StorageCondition */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_SUPPORT_STORAGE_CONDITIONS == STD_ON)
/* ****************************************************************************
 % Dem_SetStorageCondition
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetStorageCondition(
  uint8  StorageCondition,                                                                                                       /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  boolean  ConditionFulfilled
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  lReturnValue = E_NOT_OK;
#endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (Dem_Cfg_GlobalStorageCondCount() <= StorageCondition)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (TRUE < ConditionFulfilled)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: StateManager */
    Dem_EnterCritical_StateManager();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */

    /* Map the given enable condition state to bit array */
    if (FALSE == ConditionFulfilled)
    { /* clear enable condition */
      Dem_StorageConditionStates = Dem_StorageConditionStates & ((uint32)(~( (uint32)(((uint32)1u) << StorageCondition) )));
    }
    else
    { /* set enable condition */
      Dem_StorageConditionStates = Dem_StorageConditionStates | (uint32)( ((uint32)1u) << StorageCondition );
    }

    Dem_LeaveCritical_StateManager();                                                                                            /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: StateManager */

    lReturnValue = E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETSTORAGECONDITION_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif /* (DEM_CFG_SUPPORT_STORAGE_CONDITIONS == STD_ON) */

                                        /* Service Interface IndicatorStatus */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_GetIndicatorStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetIndicatorStatus(
  uint8  IndicatorId,                                                                                                            /* PRQA S 1330, 3206 */ /* MD_DEM_16.4_rte, MD_DEM_3206 */
  P2VAR(Dem_IndicatorStatusType, AUTOMATIC, DEM_APPL_DATA)  IndicatorStatus                                                      /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON) || (DEM_FEATURE_NEED_INDICATORS != STD_ON)
  lReturnValue = E_NOT_OK;
#endif
#if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)
#else
  /* There are no valid Indicator Ids with which to call this function */
  Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
#endif

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
# if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
  if (Dem_Cfg_GlobalIndicatorCount() <= IndicatorId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == IndicatorStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
#if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
    {
      Dem_IndicatorStatusType lIndicatorStatus;

      lIndicatorStatus = DEM_INDICATOR_OFF;

/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
      Dem_EnterCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
      {
        {
          if (Dem_Cfg_IndicatorContinuous[IndicatorId][DEM_J1939_NODE_ID] > 0)                                                   /* PRQA S 3685 */ /* MD_DEM_21.1 */
          {
            lIndicatorStatus = (uint8)(lIndicatorStatus | DEM_INDICATOR_CONTINUOUS);
          }
          if (Dem_Cfg_IndicatorBlinking[IndicatorId][DEM_J1939_NODE_ID] > 0)                                                     /* PRQA S 3685 */ /* MD_DEM_21.1 */
          {
            lIndicatorStatus = (uint8)(lIndicatorStatus | DEM_INDICATOR_BLINKING);
          }
        }
      }

      Dem_LeaveCritical_DiagMonitor();                                                                                           /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */

      *IndicatorStatus = lIndicatorStatus;
    }
    lReturnValue = E_OK;
#else
    DEM_IGNORE_UNUSED_ARGUMENT(IndicatorId)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(IndicatorStatus)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */
#endif
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
# if (DEM_FEATURE_NEED_INDICATORS == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
# endif
  {
    Dem_Det_ReportError(DEM_GETINDICATORSTATUS_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */

                                            /* Service Interface EventStatus */
/* ------------------------------------------------------------------------- */
#if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON)
/* ****************************************************************************
 % Dem_SetWIRStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_SetWIRStatus(
  Dem_EventIdType EventId,                                                                                                       /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  boolean WIRStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_EVENT_INVALID == EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (Dem_Cfg_GlobalEventCount() <= EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (TRUE < WIRStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    Dem_Cfg_EventInternalStatusType lInternalStatus;

    if (FALSE != DEM_ESM_TEST_ENABLECONDITION(Dem_CurrentEnableConditionStates, DEM_ENABLECONDITION_CONTROLDTCSETTING))
    {
      /* DTC setting is enabled, proceed */
      if (WIRStatus != DEM_ESM_TEST_USER_CONTROLLED_WIR(Dem_Mem_EventGetInternalStatus(EventId)))
      {
# if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
        uint8 lOldDtcStatus;
        uint8 lNewDtcStatus;
        /* override status has to be changed */
        lNewDtcStatus = Dem_Util_DtcGetStatus(EventId);
        lOldDtcStatus = Dem_Util_DtcApplyExternalOnlyStatus(EventId, lNewDtcStatus);
# endif
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DiagMonitor */
        Dem_EnterCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */

        /* update internal status bit */
        lInternalStatus = Dem_Mem_EventGetInternalStatus(EventId);
        if (FALSE == WIRStatus)
        {
          lInternalStatus = DEM_ESM_RESET_USER_CONTROLLED_WIR(lInternalStatus);
        }
        else
        {
          lInternalStatus = DEM_ESM_SET_USER_CONTROLLED_WIR(lInternalStatus);
        }
        Dem_Mem_EventSetInternalStatus(EventId, lInternalStatus);

        Dem_LeaveCritical_DiagMonitor();                                                                                         /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DiagMonitor */

# if (DEM_FEATURE_NEED_NOTIFY_DTC == STD_ON)
        lNewDtcStatus = Dem_Util_DtcApplyExternalOnlyStatus(EventId, lNewDtcStatus);
        Dem_Cbk_DtcStatusChanged_Internal(EventId, lOldDtcStatus, lNewDtcStatus);
# endif
      }

      lReturnValue = E_OK;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_SETWIRSTATUS_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) */

#if (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON)
/* ****************************************************************************
 % Dem_GetWIRStatus
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetWIRStatus(
  Dem_EventIdType EventId,                                                                                                       /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA) WIRStatus
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_EVENT_INVALID == EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (Dem_Cfg_GlobalEventCount() <= EventId)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == WIRStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    *WIRStatus = (boolean)(DEM_ESM_TEST_USER_CONTROLLED_WIR(Dem_Mem_EventGetInternalStatus(EventId)));
    lReturnValue = E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETWIRSTATUS_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif /* (DEM_CFG_SUPPORT_USER_CONTROLLED_WIR == STD_ON) */

                                /* Service Interface EvMemOverflowIndication */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_OVFLIND_API == STD_ON)
/* ****************************************************************************
 % Dem_GetEventMemoryOverflow
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetEventMemoryOverflow(
  Dem_DTCOriginType  DTCOrigin,                                                                                                  /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA)  OverflowIndication
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (0 == DTCOrigin)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (DEM_DTC_ORIGIN_INVALID <= DTCOrigin)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == OverflowIndication)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    switch (DTCOrigin)
    {
    case DEM_DTC_ORIGIN_PRIMARY_MEMORY:
      *OverflowIndication = Dem_Mem_GetOverflow(DEM_CFG_MEMORYID_PRIMARY);
      lReturnValue = E_OK;
      break;

    case DEM_DTC_ORIGIN_SECONDARY_MEMORY:
# if (DEM_FEATURE_NEED_SECONDARY == STD_ON)
      *OverflowIndication = Dem_Mem_GetOverflow(DEM_CFG_MEMORYID_SECONDARY);
# else
      *OverflowIndication = FALSE;
# endif
      lReturnValue = E_OK;
      break;

# if (DEM_CFG_SUPPORT_MIRROR == STD_ON)
    case DEM_DTC_ORIGIN_MIRROR_MEMORY:
#  error "Not implemented"
      break;
# endif

    default:
      /* E_NOT_OK */
      break;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETEVENTMEMORYOVERFLOW_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_OVFLIND_API == STD_ON) */

#if (DEM_CFG_SUPPORT_OVFLIND_API == STD_ON)
/* ****************************************************************************
 % Dem_GetNumberOfEventMemoryEntries
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_GetNumberOfEventMemoryEntries(
  Dem_DTCOriginType  DTCOrigin,                                                                                                  /* PRQA S 1330 */ /* MD_DEM_16.4_rte */
  P2VAR(uint8, AUTOMATIC, DEM_APPL_DATA)  NumberOfEventMemoryEntries
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (0 == DTCOrigin)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (DEM_DTC_ORIGIN_INVALID <= DTCOrigin)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == NumberOfEventMemoryEntries)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    switch (DTCOrigin)
    {
    case DEM_DTC_ORIGIN_PRIMARY_MEMORY:
      *NumberOfEventMemoryEntries = Dem_Mem_PrimaryCurrentCount;
      lReturnValue = E_OK;
      break;

# if (DEM_CFG_SUPPORT_SECONDARY == STD_ON)
    case DEM_DTC_ORIGIN_SECONDARY_MEMORY:
#  if (DEM_FEATURE_NEED_SECONDARY == STD_ON)
      *NumberOfEventMemoryEntries = Dem_Mem_SecondaryCurrentCount;
#  else
      *NumberOfEventMemoryEntries = 0;
#  endif
      lReturnValue = E_OK;
      break;
# endif

# if (DEM_CFG_SUPPORT_MIRROR == STD_ON)
    case DEM_DTC_ORIGIN_MIRROR_MEMORY:
#  error "Not implemented"
      break;
# endif

    default:
      /* E_NOT_OK */
      break;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_GETNUMBEROFEVENTMEMORYENTRIES_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif /* (DEM_CFG_SUPPORT_OVFLIND_API == STD_ON) */

                                         /* Dcm <-> Dem : Generic properties */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetTranslationType
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_DTCTranslationFormatType, DEM_CODE)
Dem_DcmGetTranslationType(
  void
  )
{
  Dem_DTCTranslationFormatType lTranslationFormat;
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    lTranslationFormat = Dem_Cfg_GlobalDtcFormat();
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETTRANSLATIONTYPE_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lTranslationFormat;
}
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetDTCStatusAvailabilityMask
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_DcmGetDTCStatusAvailabilityMask(
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DTCStatusMask
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == DTCStatusMask)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    *DTCStatusMask = Dem_Cfg_GlobalStatusMask();
    lReturnValue = E_OK;
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETDTCSTATUSAVAILABILITYMASK_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif
                                             /* Dcm <-> Dem : DTC properties */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetStatusOfDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnGetStatusOfDTCType, DEM_CODE)
Dem_DcmGetStatusOfDTC(
  uint32  DTC,
  Dem_DTCOriginType  DTCOrigin,
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DTCStatus
  )
{
  Dem_ReturnGetStatusOfDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
    lReturnValue = DEM_STATUS_FAILED;
  }
  else
  if (0 == DTCOrigin)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_STATUS_WRONG_DTCORIGIN;
  }
  else
  if (DEM_DTC_ORIGIN_INVALID <= DTCOrigin)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_STATUS_WRONG_DTCORIGIN;
  }
  else
  if (NULL_PTR == DTCStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
    lReturnValue = DEM_STATUS_FAILED;
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    Dem_EventIdType lEventId;
    uint8 lMemoryId;

    lEventId = Dem_Dcm_FindEventByDTCAndOrigin(DTC, DTCOrigin, &lMemoryId);
    if (DEM_CFG_MEMORYID_INVALID == lMemoryId)
    {
      lReturnValue = DEM_STATUS_WRONG_DTCORIGIN;
    }
    else
    if (DEM_EVENT_INVALID == lEventId)
    {
      lReturnValue = DEM_STATUS_WRONG_DTC;
    }
    else
    {
      uint8 lEventStatus;
      lEventStatus = Dem_Util_DtcApplyExternalOnlyStatus(lEventId, Dem_Util_DtcGetStatus(lEventId));

      /* apply status availability mask */
      *DTCStatus = (uint8)(lEventStatus & Dem_Cfg_GlobalStatusMask());
      lReturnValue = DEM_STATUS_OK;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETSTATUSOFDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetSeverityOfDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnGetSeverityOfDTCType, DEM_CODE)
Dem_DcmGetSeverityOfDTC(
  uint32  DTC,
  P2VAR(Dem_DTCSeverityType, AUTOMATIC, DEM_DCM_DATA)  DTCSeverity                                                               /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Dem_ReturnGetSeverityOfDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  lReturnValue = DEM_GET_SEVERITYOFDTC_NOSEVERITY;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == DTCSeverity)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    Dem_EventIdType lEventId;

    lEventId = Dem_Dcm_FindEventFromUdsDtc(DTC, DEM_CFG_MEMORYID_PRIMARY, DEM_DCM_CLIENT_DCM);
    if (DEM_EVENT_INVALID == lEventId)
    {
      lReturnValue = DEM_GET_SEVERITYOFDTC_WRONG_DTC;
    }
    else
    {
# if (DEM_FEATURE_NEED_TESTSUPPRESSION == STD_ON)
      if (FALSE != Dem_Esm_TestDtcSuppressed(lEventId))
      {
        lReturnValue = DEM_GET_SEVERITYOFDTC_WRONG_DTC;
      }
      else
# endif
# if (DEM_CFG_SUPPORT_SEVERITY == STD_ON)
      {
        {
          *DTCSeverity = Dem_Cfg_EventSeverity(lEventId);
          lReturnValue = DEM_GET_SEVERITYOFDTC_OK;
        }
      }
# else
      {
        DEM_IGNORE_UNUSED_ARGUMENT(DTCSeverity)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */
        lReturnValue = DEM_GET_SEVERITYOFDTC_NOSEVERITY;
      }
# endif
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETSEVERITYOFDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetFunctionalUnitOfDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnGetFunctionalUnitOfDTCType, DEM_CODE)
Dem_DcmGetFunctionalUnitOfDTC(
  uint32  DTC,
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DTCFunctionalUnit
  )
{
  Dem_ReturnGetFunctionalUnitOfDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_GET_FUNCTIONALUNITOFDTC_WRONG_DTC;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == DTCFunctionalUnit)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    Dem_EventIdType lEventId;

    lEventId = Dem_Dcm_FindEventFromUdsDtc(DTC, DEM_CFG_MEMORYID_PRIMARY, DEM_DCM_CLIENT_DCM);
    if (DEM_EVENT_INVALID != lEventId)
    {
# if (DEM_FEATURE_NEED_TESTSUPPRESSION == STD_ON)
      if (FALSE == Dem_Esm_TestDtcSuppressed(lEventId))
# endif
      {
        {
          *DTCFunctionalUnit = Dem_Cfg_EventFunctionalUnit(lEventId);
          lReturnValue = DEM_GET_FUNCTIONALUNITOFDTC_OK;
        }
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETFUNCTIONALUNITOFDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif
                                                 /* Dcm <-> Dem : DTC filter */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmSetDTCFilter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnSetFilterType, DEM_CODE)
Dem_DcmSetDTCFilter(
  uint8  DTCStatusMask,
  Dem_DTCKindType  DTCKind,
  Dem_DTCFormatType  DTCFormat,                                                                                                  /* PRQA S 3206 */ /* MD_DEM_3206 */
  Dem_DTCOriginType  DTCOrigin,
  Dem_FilterWithSeverityType  FilterWithSeverity,                                                                                /* PRQA S 3206 */ /* MD_DEM_3206 */
  Dem_DTCSeverityType  DTCSeverityMask,                                                                                          /* PRQA S 3206 */ /* MD_DEM_3206 */
  Dem_FilterForFDCType  FilterForFaultDetectionCounter
  )
{
  Dem_ReturnSetFilterType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON) || (DEM_FEATURE_NEED_OBD != STD_ON)
  lReturnValue = DEM_WRONG_FILTER;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_DTC_KIND_INVALID <= DTCKind)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if ((DEM_DTC_FORMAT_UDS != DTCFormat) && (DEM_DTC_FORMAT_OBD != DTCFormat))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if ((0 == DTCOrigin) || (DEM_DTC_ORIGIN_INVALID <= DTCOrigin))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (DEM_FILTER_WITH_SEVERITY_INVALID <= FilterWithSeverity)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (DEM_FILTER_FOR_FDC_INVALID <= FilterForFaultDetectionCounter)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_SUPPORT_SEVERITY != STD_ON)
    DEM_IGNORE_UNUSED_ARGUMENT(DTCSeverityMask)                                                                                  /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(FilterWithSeverity)                                                                               /* PRQA S 3112 */ /* MD_DEM_14.2 */
# endif

    if ( (DTCKind != DEM_DTC_KIND_EMISSION_REL_DTCS)
      && (DTCFormat != DEM_DTC_FORMAT_OBD)
      && (DTCOrigin != DEM_DTC_ORIGIN_PERMANENT_MEMORY) )
    {
      uint8 lFilterCriteria;

      lFilterCriteria = 0;
      lReturnValue = DEM_FILTER_ACCEPTED;

# if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
      /* Clear list of identified and reported events */
      {
        uint16 lIter;
        uint16 lIterEnd;

        lIterEnd = DEM_DCM_FILTER_CALC_MARKER_SIZE(Dem_Cfg_GlobalEventCount());

        for(lIter = 0; lIter < lIterEnd; lIter++)
        {
          Dem_Dcm_FilterSetReportedEvents(lIter, 0 );
        }
      }
# endif

      /* Dispatch the Event target */
      switch (DTCOrigin)
      {
      case DEM_DTC_ORIGIN_PRIMARY_MEMORY:
        Dem_Dcm_FilterDtcSetMemoryId(DEM_CFG_MEMORYID_PRIMARY);
# if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
        if ( (DTCStatusMask == 0x04)
          || (DTCStatusMask == 0x08)
          || (DTCStatusMask == 0x0C) )
        { /* reporting shall be in chronological order */
          Dem_Dcm_FilterDtcSetEventIndex(DEM_EVENT_INVALID);
          Dem_Dcm_FilterDtcSetFunctionPtr(Dem_Dcm_FilterPrimaryChrono);
        }
        else
# endif
        { /* report by event id, set first event index */
          Dem_Dcm_FilterDtcSetEventIndex(Dem_Cfg_GlobalPrimaryFirst());
          Dem_Dcm_FilterDtcSetFunctionPtr(Dem_Dcm_FilterPrimaryByEvent);
        }
        break;

# if (DEM_FEATURE_NEED_SECONDARY == STD_ON)
      case DEM_DTC_ORIGIN_SECONDARY_MEMORY:
        Dem_Dcm_FilterDtcSetMemoryId(DEM_CFG_MEMORYID_SECONDARY);
#  if (DEM_FEATURE_NEED_REPORT_CHRONOLOGICALLY == STD_ON)
        if ( (DTCStatusMask == 0x04)
          || (DTCStatusMask == 0x08)
          || (DTCStatusMask == 0x0C) )
        { /* reporting shall be in chronological order */
          Dem_Dcm_FilterDtcSetEventIndex(DEM_EVENT_INVALID);
          Dem_Dcm_FilterDtcSetFunctionPtr(Dem_Dcm_FilterSecondaryChrono);
        }
        else
#  endif
        { /* report by event id, set first event index */
          Dem_Dcm_FilterDtcSetEventIndex(Dem_Cfg_GlobalSecondaryFirst());
          Dem_Dcm_FilterDtcSetFunctionPtr(Dem_Dcm_FilterSecondaryByEvent);
        }
        break;
# endif

# if ( DEM_CFG_SUPPORT_MIRROR == STD_ON )
      case DEM_DTC_ORIGIN_MIRROR_MEMORY:
#  error "Not implemented"
        break;
# endif

      default:
        lReturnValue = DEM_WRONG_FILTER;
        break;
      }

      /* Check if filter shall ignore Dtc status or not */
      if (DTCStatusMask == 0x00)
      { /* status mask shall be ignored */
        lFilterCriteria = DEM_DCM_RESET_FILTER_USESTATUSMASK(lFilterCriteria);
      }
      else
      { /* status mask shall be taken into account, "AND" status mask with status availability mask */
        Dem_Dcm_FilterDtcSetStatusMask((uint8)(DTCStatusMask & Dem_Cfg_GlobalStatusMask()));
        lFilterCriteria = DEM_DCM_SET_FILTER_USESTATUSMASK(lFilterCriteria);
      }

      /* Check if filter shall use severity */
      if (DEM_FILTER_WITH_SEVERITY_YES == FilterWithSeverity)
      {
# if ( DEM_CFG_SUPPORT_SEVERITY == STD_ON )
        lFilterCriteria = DEM_DCM_SET_FILTER_USESEVERITY(lFilterCriteria);
        Dem_Dcm_FilterDtcSetSeverityMask(DTCSeverityMask & Dem_Cfg_GlobalSeverityMask());
# else
        lReturnValue = DEM_WRONG_FILTER;
# endif
      }
      else
      {
        lFilterCriteria = DEM_DCM_RESET_FILTER_USESEVERITY(lFilterCriteria);
      }

      /* Check if filter shall use fault detection counter */
      if (DEM_FILTER_FOR_FDC_YES == FilterForFaultDetectionCounter)
      {
        lFilterCriteria = DEM_DCM_SET_FILTER_USEFDC(lFilterCriteria);
      }
      else
      {
        lFilterCriteria = DEM_DCM_RESET_FILTER_USEFDC(lFilterCriteria);
      }

      Dem_Dcm_FilterSetCriteria(lFilterCriteria);
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMSETDTCFILTER_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6010, 6030, 6060, 6080 */ /* MD_MSR_STPTH, MD_MSR_STCYC, MD_MSR_STPAR, MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmSetFreezeFrameRecordFilter
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnSetFilterType, DEM_CODE)
Dem_DcmSetFreezeFrameRecordFilter(
  Dem_DTCFormatType  DTCFormat,                                                                                                  /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint16, AUTOMATIC, DEM_DCM_DATA)  NumberOfFilteredRecords
  )
{
  Dem_ReturnSetFilterType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON) || (DEM_CFG_SUPPORT_SRECS == STD_ON)
  lReturnValue = DEM_WRONG_FILTER;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if ((DEM_DTC_FORMAT_UDS != DTCFormat) && (DEM_DTC_FORMAT_OBD != DTCFormat))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == NumberOfFilteredRecords)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_SUPPORT_SRECS == STD_ON)
    uint8 lFilterCriteria;

    lFilterCriteria = 0;
    if (DEM_DTC_FORMAT_OBD != DTCFormat)
    { /* Set filter for output format of DTCs to UDS */
      lFilterCriteria = DEM_DCM_RESET_FILTER_DTCFORMAT_OBD(lFilterCriteria);
      lReturnValue = DEM_FILTER_ACCEPTED;
    }

    if (DEM_FILTER_ACCEPTED == lReturnValue)
    {
      DEM_MEM_MEMORYINFO_PARAM_VARDEF
      Dem_Cfg_MemoryIndexType lMemoryIndex;
      Dem_Cfg_MemoryIndexType lMemoryIndexEnd;
      uint16 lRecordCount;

      /* Count stored snapshot records in primary memory to prevent concurrent modification
         of the chrono index to have an effect on the iteration */
      DEM_MEM_MEMORYINFO_PRIMARY_INIT
      lMemoryIndex = Dem_Mem_MemoryIndex_Begin();
      lMemoryIndexEnd = Dem_Mem_MemoryIndex_End();
      lRecordCount = 0;

      while (lMemoryIndex < lMemoryIndexEnd)
      {
        Dem_EventIdType lEventId;

        lEventId = Dem_Mem_EntryGetEventId(Dem_Mem_MemoryGetEntry(lMemoryIndex));                                                /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */

        if (DEM_EVENT_INVALID != lEventId)
        {
          {
            /* Occupied entry */
            lRecordCount = (uint16)(lRecordCount + Dem_Data_SRecCount(Dem_Mem_MemoryGetEntry(lMemoryIndex)));                    /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
          }
        }

        ++lMemoryIndex;
      }

      Dem_Dcm_FilterSetCriteria(lFilterCriteria);
      Dem_Dcm_FilterRecordSetMemIndex(Dem_Mem_MemoryIndex_Begin());
      Dem_Dcm_FilterRecordSetSRecIndex(0);

      *NumberOfFilteredRecords = lRecordCount;
    }
# else
    DEM_IGNORE_UNUSED_ARGUMENT(DTCFormat)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */
    *NumberOfFilteredRecords = 0;

    lReturnValue = DEM_FILTER_ACCEPTED;
# endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMSETFREEZEFRAMERECORDFILTER_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetNumberOfFilteredDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnGetNumberOfFilteredDTCType, DEM_CODE)
Dem_DcmGetNumberOfFilteredDTC(
  P2VAR(uint16, AUTOMATIC, DEM_DCM_DATA)  NumberOfFilteredDTC
  )
{
  Dem_ReturnGetNumberOfFilteredDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_NUMBER_FAILED;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == NumberOfFilteredDTC)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    /* get relevant event range dependent on the origin */
    switch (Dem_Dcm_FilterDtcGetMemoryId())
    {
    case DEM_CFG_MEMORYID_PRIMARY:
      *NumberOfFilteredDTC = Dem_Dcm_FilterNumberMemory();
      lReturnValue = DEM_NUMBER_OK;
      break;
# if (DEM_FEATURE_NEED_SECONDARY == STD_ON)
    case DEM_CFG_MEMORYID_SECONDARY:
      *NumberOfFilteredDTC = Dem_Dcm_FilterNumberMemory();
      lReturnValue = DEM_NUMBER_OK;
      break;
# endif
# if (DEM_CFG_SUPPORT_MIRROR == STD_ON)
    case DEM_CFG_MEMORYID_MIRROR:
      break;
# endif
    default:
      break;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETNUMBEROFFILTEREDDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetNextFilteredDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnGetNextFilteredElementType, DEM_CODE)
Dem_DcmGetNextFilteredDTC(
  P2VAR(uint32, AUTOMATIC, DEM_DCM_DATA)  DTC,
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DTCStatus
  )
{
  Dem_ReturnGetNextFilteredElementType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_FILTERED_NO_MATCHING_ELEMENT;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == DTC)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == DTCStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == Dem_Dcm_FilterDtcGetFunctionPtr())
  { /* Invalid state - call SetDTCFilter before calling this function */
    Dem_Det_ErrorRegisterSet(DEM_E_INCONSISTENT_STATE)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    Dem_EventIdType lEventId;

    lEventId = (*Dem_Dcm_FilterDtcGetFunctionPtr())();

    if (lEventId != DEM_EVENT_INVALID)
    { /* Get return values only if valid EventId was returned */
      uint8 lEventStatus;
      { /* Only EventIds with a valid DTC number are processed here, so the EventId->DTC mapping will return always a valid DTC number */
        *DTC = Dem_Cfg_EventUdsDtc(lEventId);
      }

      lEventStatus = Dem_Util_DtcApplyExternalOnlyStatus(lEventId, Dem_Util_DtcGetStatus(lEventId));

      /* apply status availability mask */
      *DTCStatus = (uint8)(lEventStatus & Dem_Cfg_GlobalStatusMask());

      lReturnValue = DEM_FILTERED_OK;
    }
    /* else: No more matching DTCs */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETNEXTFILTEREDDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetDTCByOccurrenceTime
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnGetDTCByOccurrenceTimeType, DEM_CODE)
Dem_DcmGetDTCByOccurrenceTime(
  Dem_DTCRequestType  DTCRequest,
  P2VAR(uint32, AUTOMATIC, DEM_DCM_DATA)  DTC
  )
{
  Dem_ReturnGetDTCByOccurrenceTimeType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_OCCURR_NOT_AVAILABLE;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_MOST_REC_DET_CONFIRMED_DTC < DTCRequest)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == DTC)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    Dem_EventIdType lEventId;

    /* ----- Implementation ------------------------------------------------ */
    lEventId = DEM_EVENT_INVALID;

    switch (DTCRequest)
    {
    case DEM_FIRST_FAILED_DTC:
      lEventId = Dem_Mem_GetFirstFailedEvent();
      break;
    case DEM_MOST_RECENT_FAILED_DTC:
      lEventId = Dem_Mem_GetMostRecentFailedEvent();
      break;
    case DEM_FIRST_DET_CONFIRMED_DTC:
      lEventId = Dem_Mem_GetFirstConfirmedEvent();
      break;
    case DEM_MOST_REC_DET_CONFIRMED_DTC:
      lEventId = Dem_Mem_GetMostRecentConfmdEvent();
      break;
    default:
      break;
    }

    if (lEventId != DEM_EVENT_INVALID)
    { /* Only EventIds with a valid DTC number should be stored in, so the EventId->DTC mapping will return always a valid DTC number */
      {
        *DTC = Dem_Cfg_EventUdsDtc(lEventId);
        lReturnValue = DEM_OCCURR_OK;
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETDTCBYOCCURRENCETIME_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetNextFilteredRecord
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnGetNextFilteredElementType, DEM_CODE)
Dem_DcmGetNextFilteredRecord(
  P2VAR(uint32, AUTOMATIC, DEM_DCM_DATA)  DTC,                                                                                   /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  RecordNumber                                                                            /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Dem_ReturnGetNextFilteredElementType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_FILTERED_NO_MATCHING_ELEMENT;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == DTC)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == RecordNumber)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
# if (DEM_CFG_SUPPORT_SRECS == STD_ON)
    DEM_MEM_MEMORYINFO_PARAM_VARDEF
    Dem_Cfg_MemoryIndexType lMemoryIndex;
    Dem_Cfg_MemoryIndexType lMemoryIndexEnd;
    uint8 lSnapshotIndex;
#  if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
    uint8 lSnapshotTestMask;
#  endif
# endif

    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_SUPPORT_SRECS == STD_ON)
    DEM_MEM_MEMORYINFO_PRIMARY_INIT
    lMemoryIndex = Dem_Dcm_FilterRecordGetMemIndex();
    lMemoryIndexEnd = Dem_Mem_MemoryIndex_End();
    lSnapshotIndex = Dem_Dcm_FilterRecordGetSRecIndex();

    while (lMemoryIndex < lMemoryIndexEnd)
    {
      Dem_EventIdType lEventId;
      Dem_Mem_EntryPtrType lEntry;

      lEntry = Dem_Mem_MemoryGetEntry(lMemoryIndex);                                                                             /* PRQA S 0310, 3305 */ /* MD_DEM_11.4_nvm, MD_DEM_3305 */
      lEventId = Dem_Mem_EntryGetEventId(lEntry);
      if (DEM_EVENT_INVALID != lEventId)
      {
        {
          {
#  if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
            if (lSnapshotIndex < lEntry->SnapshotHeader)
            { /* Current snapshot is stored, return it */
#  elif (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
            if (lSnapshotIndex == 0)
            { /* Starting with the first record, we initialize the iterator needed to find supported record numbers */
              Dem_Cfg_EventSRecIterInit(lEventId, Dem_Dcm_FilterRecordGetIterator());                                            /* PRQA S 3198, 3417 */ /* MD_DEM_3198_fp, MD_DEM_12.10 */
            }
            lSnapshotTestMask = (uint8)(1U << lSnapshotIndex);
            while (FALSE != Dem_Cfg_EventSRecIterExists(lEventId, Dem_Dcm_FilterRecordGetIterator()))
            {
              uint8 lSRecId;
              lSRecId = Dem_Cfg_EventSRecIterGet(EventId, Dem_Dcm_FilterRecordGetIterator());

              /* Increment iterator in global state, the next iteration will continue with the next record */
              Dem_Cfg_EventSRecIterNext(EventId, Dem_Dcm_FilterRecordGetIterator());

              if (0 == (lEntry->SnapshotHeader & lSnapshotTestMask))
              { /* Continue immediately with the next possible record in this iteration, the Dcm always expects a record */
                ++lSnapshotIndex;
                lSnapshotTestMask = (uint8)(lSnapshotTestMask << 1U);
                continue;                                                                                                        /* PRQA S 0770 */ /* MD_DEM_14.5 */
              }
#  endif
              /* Increment in global state, the next iteration will continue with the next record */
              Dem_Dcm_FilterRecordSetMemIndex(lMemoryIndex);
              Dem_Dcm_FilterRecordSetSRecIndex((uint8)(lSnapshotIndex + 1));

              { /* Only EventIds with a valid DTC number are processed here */                                                   /* PRQA S 0715 */  /* MD_MSR_1.1_715 */
                /* -> DTC mapping will always return a valid DTC number */
                *DTC = Dem_Cfg_EventUdsDtc(lEventId);
              }
#  if (DEM_CFG_SUPPORT_SRECS_CALCULATED == STD_ON)
              *RecordNumber = (uint8)(lSnapshotIndex + 1);
#  endif
#  if (DEM_CFG_SUPPORT_SRECS_CONFIGURED == STD_ON)
              *RecordNumber = Dem_Cfg_SRecId(lSRecId);
#  endif
              return DEM_FILTERED_OK;
            }
          }
        }
      }
      ++lMemoryIndex;
      lSnapshotIndex = 0;
    }

    Dem_Dcm_FilterRecordSetMemIndex(lMemoryIndex);
    Dem_Dcm_FilterRecordSetSRecIndex(lSnapshotIndex);
# else
    DEM_IGNORE_UNUSED_ARGUMENT(DTC)                                                                                              /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(RecordNumber)                                                                                     /* PRQA S 3112 */ /* MD_DEM_14.2 */
# endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETNEXTFILTEREDRECORD_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 2006, 6030, 6080 */ /* MD_DEM_14.7, MD_MSR_STCYC, MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetNextFilteredDTCAndFDC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnGetNextFilteredElementType, DEM_CODE)
Dem_DcmGetNextFilteredDTCAndFDC(
  P2VAR(uint32, AUTOMATIC, DEM_DCM_DATA)  DTC,
  P2VAR(sint8, AUTOMATIC, DEM_DCM_DATA)  DTCFaultDetectionCounter
  )
{
  Dem_ReturnGetNextFilteredElementType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_FILTERED_NO_MATCHING_ELEMENT;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == DTC)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == DTCFaultDetectionCounter)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == Dem_Dcm_FilterDtcGetFunctionPtr())
  {  /* Invalid state - call SetDTCFilter before calling this function */
    Dem_Det_ErrorRegisterSet(DEM_E_INCONSISTENT_STATE)
  }
  else
# endif
  {
    Dem_EventIdType lEventId;
    uint8 lRepeatProcessing;

    /* ----- Implementation ------------------------------------------------ */
    do
    {
      lRepeatProcessing = FALSE;

      lEventId = (*Dem_Dcm_FilterDtcGetFunctionPtr())();

      if (lEventId != DEM_EVENT_INVALID)
      { /* Get return values only if valid EventId was returned */
        uint8 lFilterCriteria;

        lFilterCriteria = Dem_Dcm_FilterGetCriteria();

        { /* Only EventIds with a valid DTC number are processed here, so the EventId->DTC mapping will return always a valid DTC number */
          *DTC = Dem_Cfg_EventUdsDtc(lEventId);
        }

        if (FALSE != DEM_DCM_TEST_FILTER_USEFDC(lFilterCriteria))
        { /* FDC was already calculated during filtering */
          *DTCFaultDetectionCounter = Dem_Dcm_FilterDtcGetFdc();
          lReturnValue = DEM_FILTERED_OK;
        }
        else
        { /* Calculate FDC if filter criteria does not take FDC into account */

          Std_ReturnType lGetFdcReturnValue;
          sint8 lFdc;

          lGetFdcReturnValue = Dem_Util_DtcGetFaultDetectionCounter(lEventId, &lFdc);

          if (lGetFdcReturnValue == E_OK)
          {
            *DTCFaultDetectionCounter = lFdc;
            lReturnValue = DEM_FILTERED_OK;
          }
          else
          {
            /* no valid FDC, continue processing */
            lRepeatProcessing = TRUE;
          }
        }
      }
    } while (lRepeatProcessing != FALSE);
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETNEXTFILTEREDDTCANDFDC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetNextFilteredDTCAndSeverity
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnGetNextFilteredElementType, DEM_CODE)
Dem_DcmGetNextFilteredDTCAndSeverity(
  P2VAR(uint32, AUTOMATIC, DEM_DCM_DATA)  DTC,                                                                                   /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DTCStatus,                                                                              /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(Dem_DTCSeverityType, AUTOMATIC, DEM_DCM_DATA)  DTCSeverity,                                                              /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DTCFunctionalUnit                                                                       /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Dem_ReturnGetNextFilteredElementType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_FILTERED_NO_MATCHING_ELEMENT;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == DTC)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == DTCStatus)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == DTCSeverity)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == DTCFunctionalUnit)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == Dem_Dcm_FilterDtcGetFunctionPtr())
  {  /* Invalid state - call SetDTCFilter before calling this function */
    Dem_Det_ErrorRegisterSet(DEM_E_INCONSISTENT_STATE)
  }
  else
# endif
  {
# if (DEM_CFG_SUPPORT_SEVERITY == STD_ON)
    Dem_EventIdType                      lEventId;
# endif

    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_SUPPORT_SEVERITY == STD_ON)
    lEventId = (*Dem_Dcm_FilterDtcGetFunctionPtr())();

    if (lEventId != DEM_EVENT_INVALID)
    { /* Get return values only if valid EventId was returned */
      uint8 lEventStatus;
      { /* Only EventIds with a valid DTC number should be processed here, so the EventId->DTC mapping will return always a valid DTC number */
        *DTC = Dem_Cfg_EventUdsDtc(lEventId);
      }

      lEventStatus = Dem_Util_DtcApplyExternalOnlyStatus(lEventId, Dem_Util_DtcGetStatus(lEventId));

      /* apply status availability mask */
      *DTCStatus = (uint8)(lEventStatus & Dem_Cfg_GlobalStatusMask());

      *DTCSeverity       = Dem_Cfg_EventSeverity(lEventId);
      *DTCFunctionalUnit = Dem_Cfg_EventFunctionalUnit(lEventId);

      lReturnValue = DEM_FILTERED_OK;
    }
# else
    DEM_IGNORE_UNUSED_ARGUMENT(DTC)                                                                                              /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DTCStatus)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DTCSeverity)                                                                                      /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DTCFunctionalUnit)                                                                                /* PRQA S 3112 */ /* MD_DEM_14.2 */
# endif
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETNEXTFILTEREDDTCANDSEVERITY_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif
                                            /* Dcm <-> Dem : data protection */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmDisableDTCRecordUpdate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnDisableDTCRecordUpdateType, DEM_CODE)
Dem_DcmDisableDTCRecordUpdate(
  uint32  DTC,
  Dem_DTCOriginType  DTCOrigin
  )
{
  Dem_ReturnDisableDTCRecordUpdateType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
    lReturnValue = DEM_DISABLE_DTCRECUP_WRONG_DTC;
  }
  else
  if ((0 == DTCOrigin) || (DEM_DTC_ORIGIN_INVALID <= DTCOrigin))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_DISABLE_DTCRECUP_WRONG_DTCORIGIN;
  }
  else
# endif
  {
    Dem_EventIdType lEventId;
    uint8 lMemoryId;

    /* ----- Implementation ------------------------------------------------ */
    lEventId = Dem_Dcm_FindEventByDTCAndOrigin(DTC, DTCOrigin, &lMemoryId);
    if (DEM_CFG_MEMORYID_INVALID == lMemoryId)
    {
      lReturnValue = DEM_DISABLE_DTCRECUP_WRONG_DTCORIGIN;
    }
    else
    if (DEM_EVENT_INVALID == lEventId)
    {
      lReturnValue = DEM_DISABLE_DTCRECUP_WRONG_DTC;
    }
    else
    if ( (Dem_Dcm_FilterDataGetEventId() == lEventId)
      && (Dem_Dcm_FilterDataGetMemoryId() == lMemoryId) )
    { /* This is a polling call, not a new request */
      lReturnValue = Dem_Dcm_FilterDataGetState();
    }
    else
    {
      if (DEM_DCM_FILTERDATA_READY == Dem_Dcm_FilterDataGetState())
      {
        Dem_Det_ReportError(DEM_DCMDISABLEDTCRECORDUPDATE_APIID, DEM_E_WRONG_CONDITION)
        (void)Dem_DcmEnableDTCRecordUpdate();
      }
      if (DEM_DCM_FILTERDATA_IDLE == Dem_Dcm_FilterDataGetState())
      {
        Dem_Dcm_FilterDataSetEventId(lEventId);
        Dem_Dcm_FilterDataSetMemoryId(lMemoryId);
        if (DEM_ESM_STORED_STATUS_NONE == DEM_ESM_GET_STORED_STATUS(Dem_Util_DtcGetInternalStatus(lEventId)))
        { /* Event not stored - there is no data to be copied */
          /* Mark the buffer as unused - this can be used to verify the validity of statistic records */
          Dem_Cfg_ReadoutBuffer.EventId = DEM_EVENT_INVALID;
          /* Initialize 'no record stored', this allows a common test for the validity of stored records */
          Dem_Data_EntryInit(&Dem_Cfg_ReadoutBuffer);
          Dem_Dcm_FilterDataSetState(DEM_DCM_FILTERDATA_READY);
          lReturnValue = DEM_DISABLE_DTCRECUP_OK;
        }
        else
        { /* Event stored - copy on task to prevent concurrent modification */
          Dem_Dcm_FilterDataSetState(DEM_DCM_FILTERDATA_PENDING);
          lReturnValue = DEM_DISABLE_DTCRECUP_PENDING;
        }
      }
      else
      {
        Dem_Det_ReportError(DEM_DCMDISABLEDTCRECORDUPDATE_APIID, DEM_E_WRONG_CONDITION)
        lReturnValue = DEM_DISABLE_DTCRECUP_WRONG_DTC;
      }
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMDISABLEDTCRECORDUPDATE_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmEnableDTCRecordUpdate
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_DcmEnableDTCRecordUpdate(
  void
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if (DEM_DCM_FILTERDATA_READY == Dem_Dcm_FilterDataGetState())
    {
      Dem_Dcm_FilterDataSetState(DEM_DCM_FILTERDATA_IDLE);
      Dem_Dcm_FilterDataSetEventId(DEM_EVENT_INVALID);

      lReturnValue = E_OK;
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMENABLEDTCRECORDUPDATE_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif
                                                   /* Dcm <-> Dem : DTC data */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetOBDFreezeFrameData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_DcmGetOBDFreezeFrameData(
  P2VAR(uint32, AUTOMATIC, DEM_DCM_DATA)  DTC,                                                                                   /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DestBuffer,                                                                             /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint16, AUTOMATIC, DEM_DCM_DATA)  BufSize                                                                                /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (NULL_PTR == DTC)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == DestBuffer)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == BufSize)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    DEM_IGNORE_UNUSED_ARGUMENT(DTC)                                                                                              /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DestBuffer)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(BufSize)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */

    /* ----- Implementation ------------------------------------------------ */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETOBDFREEZEFRAMEDATA_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6080 */ /* MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetFreezeFrameDataByDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnGetFreezeFrameDataByDTCType, DEM_CODE)
Dem_DcmGetFreezeFrameDataByDTC(
  uint32  DTC,                                                                                                                   /* PRQA S 3206 */ /* MD_DEM_3206 */
  Dem_DTCOriginType  DTCOrigin,                                                                                                  /* PRQA S 3206 */ /* MD_DEM_3206 */
  uint8  RecordNumber,                                                                                                           /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DestBuffer,                                                                             /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint16, AUTOMATIC, DEM_DCM_DATA)  BufSize                                                                                /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Dem_ReturnGetFreezeFrameDataByDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
    lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTC;
  }
  else
  if ((0 == DTCOrigin) || (DEM_DTC_ORIGIN_INVALID <= DTCOrigin))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTCORIGIN;
  }
  else
  if (0xffU == RecordNumber)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER;
  }
  else
  if (NULL_PTR == DestBuffer)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
    lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTC;
  }
  else
  if (NULL_PTR == BufSize)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
    lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTC;
  }
  else
  if (DEM_DCM_FILTERDATA_READY != Dem_Dcm_FilterDataGetState())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
    lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTC;
  }
  else
# endif
  {
# if (DEM_CFG_SUPPORT_SRECS == STD_ON) \
  || ((DEM_FEATURE_NEED_FREEZEFRAME_OBDII == STD_ON) && (DEM_CFG_SUPPORT_OBDII_FREEZEFRAME_IN_SVC19 == STD_ON)) \
  || (DEM_FEATURE_NEED_FREEZEFRAME_WWHOBD == STD_ON)
    Dem_EventIdType lEventId;
    uint8 lMemoryId;
# endif

    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_SUPPORT_SRECS == STD_ON) \
    || ((DEM_FEATURE_NEED_FREEZEFRAME_OBDII == STD_ON) && (DEM_CFG_SUPPORT_OBDII_FREEZEFRAME_IN_SVC19 == STD_ON)) \
    || (DEM_FEATURE_NEED_FREEZEFRAME_WWHOBD == STD_ON)
    lEventId = Dem_Dcm_FindEventByDTCAndOrigin(DTC, DTCOrigin, &lMemoryId);
    if (DEM_CFG_MEMORYID_INVALID == lMemoryId)
    {
      lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTCORIGIN;
    }
    else
    if (DEM_EVENT_INVALID == lEventId)
    {
      lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTC;
    }
    else
#  if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
    if ((lEventId != Dem_Dcm_FilterDataGetEventId()) && (DEM_EVENT_INVALID != Dem_Dcm_FilterDataGetEventId()))
    {
      Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
      lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTC;
    }
    else
#  endif
    if (RecordNumber == 0x00)
    {
      {
        lReturnValue = DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER;
      }
    }
    else
    {
#  if (DEM_CFG_SUPPORT_SRECS == STD_ON)
      lReturnValue = Dem_Dcm_CopySRec(lEventId, RecordNumber, DestBuffer, BufSize);
#  else
      lReturnValue = DEM_GET_FFDATABYDTC_WRONG_RECORDNUMBER;
#  endif
    }

# else
    DEM_IGNORE_UNUSED_ARGUMENT(DTC)                                                                                              /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DTCOrigin)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(RecordNumber)                                                                                     /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DestBuffer)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(BufSize)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */

    lReturnValue = DEM_GET_FFDATABYDTC_WRONG_DTC;
# endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETFREEZEFRAMEDATABYDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetSizeOfFreezeFrameByDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnGetSizeOfDataByDTCType, DEM_CODE)
Dem_DcmGetSizeOfFreezeFrameByDTC(
  uint32  DTC,                                                                                                                   /* PRQA S 3206 */ /* MD_DEM_3206 */
  Dem_DTCOriginType  DTCOrigin,                                                                                                  /* PRQA S 3206 */ /* MD_DEM_3206 */
  uint8  RecordNumber,                                                                                                           /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint16, AUTOMATIC, DEM_DCM_DATA)  SizeOfFreezeFrame                                                                      /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Dem_ReturnGetSizeOfDataByDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
  }
  else
  if ((0 == DTCOrigin) || (DEM_DTC_ORIGIN_INVALID <= DTCOrigin))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTCORIGIN;
  }
  else
  if (NULL_PTR == SizeOfFreezeFrame)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
  }
  else
  if (DEM_DCM_FILTERDATA_READY != Dem_Dcm_FilterDataGetState())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
  }
  else
# endif
  {
# if (DEM_CFG_SUPPORT_SRECS == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_OBDII == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_WWHOBD == STD_ON)
    Dem_EventIdType lEventId;
    uint8 lMemoryId;
# endif

    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_SUPPORT_SRECS == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_OBDII == STD_ON) || (DEM_FEATURE_NEED_FREEZEFRAME_WWHOBD == STD_ON)
    lEventId = Dem_Dcm_FindEventByDTCAndOrigin(DTC, DTCOrigin, &lMemoryId);
    if (DEM_CFG_MEMORYID_INVALID == lMemoryId)
    {
      lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTCORIGIN;
    }
    else
    if (DEM_EVENT_INVALID == lEventId)
    {
      lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
    }
    else
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
    if ((lEventId != Dem_Dcm_FilterDataGetEventId()) && (DEM_EVENT_INVALID != Dem_Dcm_FilterDataGetEventId()))
    {
      Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
      lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
    }
    else
# endif
    if (RecordNumber == 0x00)
    {
      {
        lReturnValue = DEM_GETSIZEBYDTC_WRONG_RECNUM;
      }
    }
    else
    {
      lReturnValue = Dem_Dcm_GetSizeOfSRec(lEventId, RecordNumber, SizeOfFreezeFrame);
    }
# else
    DEM_IGNORE_UNUSED_ARGUMENT(DTC)                                                                                              /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DTCOrigin)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(RecordNumber)                                                                                     /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(SizeOfFreezeFrame)                                                                                /* PRQA S 3112 */ /* MD_DEM_14.2 */

    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
# endif /* (DEM_CFG_SUPPORT_SRECS == STD_ON) */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETSIZEOFFREEZEFRAMEBYDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetExtendedDataRecordByDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnGetExtendedDataRecordByDTCType, DEM_CODE)
Dem_DcmGetExtendedDataRecordByDTC(
  uint32  DTC,                                                                                                                   /* PRQA S 3206 */ /* MD_DEM_3206 */
  Dem_DTCOriginType  DTCOrigin,                                                                                                  /* PRQA S 3206 */ /* MD_DEM_3206 */
  uint8  ExtendedDataNumber,                                                                                                     /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint8, AUTOMATIC, DEM_DCM_DATA)  DestBuffer,                                                                             /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint16, AUTOMATIC, DEM_DCM_DATA)  BufSize                                                                                /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Dem_ReturnGetExtendedDataRecordByDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
    lReturnValue = DEM_RECORD_WRONG_DTC;
  }
  else
  if ((0 == DTCOrigin) || (DEM_DTC_ORIGIN_INVALID <= DTCOrigin))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_RECORD_WRONG_DTCORIGIN;
  }
  else
  if (0xfeU <= ExtendedDataNumber)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_RECORD_WRONG_DTC;
  }
  else
  if (NULL_PTR == DestBuffer)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
    lReturnValue = DEM_RECORD_WRONG_DTC;
  }
  else
  if (NULL_PTR == BufSize)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
    lReturnValue = DEM_RECORD_WRONG_DTC;
  }
  else
  if (DEM_DCM_FILTERDATA_READY != Dem_Dcm_FilterDataGetState())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
    lReturnValue = DEM_RECORD_WRONG_DTC;
  }
  else
# endif
  {
# if (DEM_CFG_SUPPORT_ERECS == STD_ON)
    Dem_EventIdType lEventId;
    uint8 lMemoryId;
# endif

    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_SUPPORT_ERECS == STD_ON)
    lEventId = Dem_Dcm_FindEventByDTCAndOrigin(DTC, DTCOrigin, &lMemoryId);
    if (DEM_CFG_MEMORYID_INVALID == lMemoryId)
    {
      lReturnValue = DEM_RECORD_WRONG_DTCORIGIN;
    }
    else
    if (DEM_EVENT_INVALID == lEventId)
    {
      lReturnValue = DEM_RECORD_WRONG_DTC;
    }
    else
    if ((ExtendedDataNumber == 0x00U) || (ExtendedDataNumber >= 0xf0U))
    {
      lReturnValue = DEM_RECORD_WRONG_NUMBER;
    }
    else
#  if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
    if ((lEventId != Dem_Dcm_FilterDataGetEventId()) && (DEM_EVENT_INVALID != Dem_Dcm_FilterDataGetEventId()))
    {
      Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
      lReturnValue = DEM_RECORD_WRONG_DTC;
    }
    else
#  endif
    {
      lReturnValue = Dem_Dcm_CopyERec(lEventId, ExtendedDataNumber, DestBuffer, BufSize);
    }
# else
    DEM_IGNORE_UNUSED_ARGUMENT(DTC)                                                                                              /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DTCOrigin)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(ExtendedDataNumber)                                                                               /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DestBuffer)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(BufSize)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */

    lReturnValue = DEM_RECORD_WRONG_NUMBER;
# endif /* if (DEM_CFG_SUPPORT_ERECS == STD_ON) */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETEXTENDEDDATARECORDBYDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmGetSizeOfExtendedDataRecordByDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnGetSizeOfDataByDTCType, DEM_CODE)
Dem_DcmGetSizeOfExtendedDataRecordByDTC(
  uint32  DTC,                                                                                                                   /* PRQA S 3206 */ /* MD_DEM_3206 */
  Dem_DTCOriginType  DTCOrigin,                                                                                                  /* PRQA S 3206 */ /* MD_DEM_3206 */
  uint8  ExtendedDataNumber,                                                                                                     /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint16, AUTOMATIC, DEM_DCM_DATA)  SizeOfExtendedDataRecord                                                               /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Dem_ReturnGetSizeOfDataByDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
  }
  else
  if ((0 == DTCOrigin) || (DEM_DTC_ORIGIN_INVALID <= DTCOrigin))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTCORIGIN;
  }
  else
  if (NULL_PTR == SizeOfExtendedDataRecord)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
  }
  else
  if (DEM_DCM_FILTERDATA_READY != Dem_Dcm_FilterDataGetState())
  {
    Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
  }
  else
# endif
  {
# if (DEM_CFG_SUPPORT_ERECS == STD_ON)
    Dem_EventIdType lEventId;
    uint8 lMemoryId;
# endif

    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_SUPPORT_ERECS == STD_ON)
    lEventId = Dem_Dcm_FindEventByDTCAndOrigin(DTC, DTCOrigin, &lMemoryId);
    if (DEM_CFG_MEMORYID_INVALID == lMemoryId)
    {
      lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTCORIGIN;
    }
    else
    if (DEM_EVENT_INVALID == lEventId)
    {
      lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
    }
    else
    if ( (ExtendedDataNumber == 0x00U)
      || ( (ExtendedDataNumber >= 0xf0U)
        && (ExtendedDataNumber <= 0xfeU)
       ) )
    {
      lReturnValue = DEM_GETSIZEBYDTC_WRONG_RECNUM;
    }
    else
#  if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
    if ((lEventId != Dem_Dcm_FilterDataGetEventId()) && (DEM_EVENT_INVALID != Dem_Dcm_FilterDataGetEventId()))
    {
      Dem_Det_ErrorRegisterSet(DEM_E_WRONG_CONDITION)
      lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTC;
    }
    else
#  endif
    {
      lReturnValue = Dem_Dcm_GetSizeOfERec(lEventId, ExtendedDataNumber, SizeOfExtendedDataRecord);
    }
# else
    DEM_IGNORE_UNUSED_ARGUMENT(DTC)                                                                                              /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DTCOrigin)                                                                                        /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(ExtendedDataNumber)                                                                               /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(SizeOfExtendedDataRecord)                                                                         /* PRQA S 3112 */ /* MD_DEM_14.2 */

    lReturnValue = DEM_GETSIZEBYDTC_WRONG_RECNUM;
# endif /* if (DEM_CFG_SUPPORT_ERECS == STD_ON) */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMGETSIZEOFEXTENDEDDATARECORDBYDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif
                                                  /* Dcm <-> Dem : Clear DTC */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmClearDTC
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnClearDTCType, DEM_CODE)
Dem_DcmClearDTC(
  uint32  DTC,
  Dem_DTCFormatType  DTCFormat,
  Dem_DTCOriginType  DTCOrigin
  )
{
  Dem_ReturnClearDTCType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
    lReturnValue = DEM_CLEAR_FAILED;
  }
  else
  if ((DEM_DTC_FORMAT_UDS != DTCFormat) && (DEM_DTC_FORMAT_OBD != DTCFormat))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_CLEAR_WRONG_DTC;
  }
  else
  if ((0 == DTCOrigin) || (DEM_DTC_ORIGIN_INVALID <= DTCOrigin))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
    lReturnValue = DEM_GETSIZEBYDTC_WRONG_DTCORIGIN;
  }
  else
# endif
  {
    Dem_Queue_ClearRequestType lClearRequest;

    /* ----- Implementation ------------------------------------------------ */
    lClearRequest.ClearFormat = DTCFormat;
    lClearRequest.ClearMemoryId = Dem_Dcm_MemoryIdFromOrigin(DTCOrigin);
    lClearRequest.ClearClient = DEM_DCM_CLIENT_DCM;

    lReturnValue = Dem_Dcm_ClearDtc_Internal(DTC, &lClearRequest);
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMCLEARDTC_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif
                                       /* Dcm <-> Dem : Control DTC Settings */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmDisableDTCSetting
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnControlDTCSettingType, DEM_CODE)
Dem_DcmDisableDTCSetting(
  Dem_DTCGroupType DTCGroup,
  Dem_DTCKindType  DTCKind
  )
{
  Dem_ReturnControlDTCSettingType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_CONTROL_DTC_SETTING_N_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_DTC_KIND_INVALID <= DTCKind)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ((DEM_DTC_GROUP_ALL_DTCS == DTCGroup) && (DEM_DTC_KIND_ALL_DTCS == DTCKind))
    {
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: StateManager */
      Dem_EnterCritical_StateManager();                                                                                          /* PRQA S 3109 */ /* MD_MSR_14.3 */

# if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
      Dem_NextEnableConditionStates = DEM_ESM_RESET_ENABLECONDITION(Dem_NextEnableConditionStates, DEM_ENABLECONDITION_CONTROLDTCSETTING);
# endif
      Dem_CurrentEnableConditionStates = DEM_ESM_RESET_ENABLECONDITION(Dem_CurrentEnableConditionStates, DEM_ENABLECONDITION_CONTROLDTCSETTING);

      Dem_LeaveCritical_StateManager();                                                                                          /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: StateManager */

      lReturnValue = DEM_CONTROL_DTC_SETTING_OK;
# if (DEM_CFG_NOTIFY_CONTROL_DTC_SETTING == STD_ON)
      (void)Dem_Cfg_GlobalCbkControlDtcSetting(FALSE);                                                                           /* PRQA S 3423 */ /* MD_DEM_3423 */
# endif
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMDISABLEDTCSETTING_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmEnableDTCSetting
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Dem_ReturnControlDTCSettingType, DEM_CODE)
Dem_DcmEnableDTCSetting(
  Dem_DTCGroupType  DTCGroup,
  Dem_DTCKindType  DTCKind
  )
{
  Dem_ReturnControlDTCSettingType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = DEM_CONTROL_DTC_SETTING_N_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if (DEM_DTC_KIND_INVALID <= DTCKind)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    if ((DEM_DTC_GROUP_ALL_DTCS == DTCGroup) && (DEM_DTC_KIND_ALL_DTCS == DTCKind))
    {
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: StateManager */
      Dem_EnterCritical_StateManager();                                                                                          /* PRQA S 3109 */ /* MD_MSR_14.3 */

# if (DEM_FEATURE_NEED_DEFERRED_ENABLE_CONDITIONS == STD_ON)
      Dem_NextEnableConditionStates = DEM_ESM_SET_ENABLECONDITION(Dem_NextEnableConditionStates, DEM_ENABLECONDITION_CONTROLDTCSETTING);
# else
      Dem_CurrentEnableConditionStates = DEM_ESM_SET_ENABLECONDITION(Dem_CurrentEnableConditionStates, DEM_ENABLECONDITION_CONTROLDTCSETTING);
# endif

      Dem_LeaveCritical_StateManager();                                                                                          /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: StateManager */
      lReturnValue = DEM_CONTROL_DTC_SETTING_OK;
# if (DEM_CFG_NOTIFY_CONTROL_DTC_SETTING == STD_ON)
      (void)Dem_Cfg_GlobalCbkControlDtcSetting(TRUE);                                                                            /* PRQA S 3423 */ /* MD_DEM_3423 */
# endif
    }
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMENABLEDTCSETTING_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}                                                                                                                                /* PRQA S 6030, 6080 */ /* MD_MSR_STCYC, MD_MSR_STMIF */
#endif

                                   /* Dcm <-> Dem : Control DTC Notification */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmControlDTCStatusChangedNotification
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_DcmControlDTCStatusChangedNotification(
  boolean TriggerNotification                                                                                                    /* PRQA S 3206 */ /* MD_DEM_3206 */
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    /* not supported */
    DEM_IGNORE_UNUSED_ARGUMENT(TriggerNotification)                                                                              /* PRQA S 3112 */ /* MD_DEM_14.2 */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMCONTROLDTCSTATUSCHANGEDNOTIFICATION_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif
}
#endif

                                                   /* Dcm <-> Dem : OBD VIDs */
/* ------------------------------------------------------------------------- */
                                                   /* Dcm <-> Dem : OBD PIDs */
/* ------------------------------------------------------------------------- */
                                           /* Dcm <-> Dem : Cancel Operation */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DCM == STD_ON)
/* ****************************************************************************
 % Dem_DcmCancelOperation
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(void, DEM_CODE)
Dem_DcmCancelOperation(
  void
  )
{
  Dem_Det_ErrorRegisterDefine()

  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
# endif
  {
    uint8 lClearState;

    /* ----- Implementation ------------------------------------------------ */
/* >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Enter Critical Section: DcmApi */
    Dem_EnterCritical_DcmApi();                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */

    lClearState = Dem_Queue_GetClearState();
    if (DEM_QUEUE_CLEARSTATE_IDLE != lClearState)
    { /* clear is currently in progress */
      Dem_Queue_SetClearState(DEM_QUEUE_SETCLEARSTATE_CANCEL(lClearState));
    }

    if (DEM_DCM_FILTERDATA_IDLE != Dem_Dcm_FilterDataGetState())
    {
      Dem_Dcm_FilterSetCancelled();
    }

    Dem_LeaveCritical_DcmApi();                                                                                                  /* PRQA S 3109 */ /* MD_MSR_14.3 */
/* <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< Leave Critical Section: DcmApi */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DCMCANCELOPERATION_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif
}
#endif

                                             /* Permanent Storage Activation */
/* ------------------------------------------------------------------------- */
                                                               /* B1 Counter */
/* ------------------------------------------------------------------------- */
                                                                 /* PID Data */
/* ------------------------------------------------------------------------- */
                                                    /* Interface Dlt <-> Dem */
/* ------------------------------------------------------------------------- */

#if (DEM_CFG_SUPPORT_DLT == STD_ON)
/* ****************************************************************************
 % Dem_DltGetMostRecentFreezeFrameRecordData
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_DltGetMostRecentFreezeFrameRecordData(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint8, AUTOMATIC, DEM_DLT_DATA)  DestBuffer,                                                                             /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint8, AUTOMATIC, DEM_DLT_DATA)  BufSize                                                                                 /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if ((DEM_EVENT_INVALID == EventId) || (Dem_Cfg_GlobalEventCount() <= EventId))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == DestBuffer)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == BufSize)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    DEM_IGNORE_UNUSED_ARGUMENT(EventId)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DestBuffer)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(BufSize)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DLTGETMOSTRECENTFREEZEFRAMERECORDDATA_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif

#if (DEM_CFG_SUPPORT_DLT == STD_ON)
/* ****************************************************************************
 % Dem_DltGetAllExtendedDataRecords
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_DltGetAllExtendedDataRecords(
  Dem_EventIdType  EventId,                                                                                                      /* PRQA S 3206 */ /* MD_DEM_3206 */
  P2VAR(uint8, AUTOMATIC, DEM_DLT_DATA)  DestBuffer,                                                                             /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  P2VAR(uint8, AUTOMATIC, DEM_DLT_DATA)  BufSize                                                                                 /* PRQA S 3206, 3673 */ /* MD_DEM_3206, MD_DEM_16.7 */
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

  lReturnValue = E_NOT_OK;
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
  if ((DEM_EVENT_INVALID == EventId) || (Dem_Cfg_GlobalEventCount() <= EventId))
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_DATA)
  }
  else
  if (NULL_PTR == DestBuffer)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
  if (NULL_PTR == BufSize)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
    DEM_IGNORE_UNUSED_ARGUMENT(EventId)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(DestBuffer)                                                                                       /* PRQA S 3112 */ /* MD_DEM_14.2 */
    DEM_IGNORE_UNUSED_ARGUMENT(BufSize)                                                                                          /* PRQA S 3112 */ /* MD_DEM_14.2 */
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_DLTGETALLEXTENDEDDATARECORDS_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif

                                                     /* Extension to Autosar */
/* ------------------------------------------------------------------------- */

/* ****************************************************************************
 % Dem_PostRunRequested
 *****************************************************************************/
/*!
 * Internal comment removed.
 *
 *
 */
FUNC(Std_ReturnType, DEM_CODE)
Dem_PostRunRequested(
  P2VAR(boolean, AUTOMATIC, DEM_APPL_DATA)  IsRequested
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  lReturnValue = E_NOT_OK;
#endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
#if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (NULL_PTR == IsRequested)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_PARAM_POINTER)
  }
  else
#endif
  {
    /* ----- Implementation ------------------------------------------------ */
#if (DEM_FEATURE_NEED_NVM_IMMEDIATE == STD_ON)
    if ( (DEM_INIT_INITIALIZED == Dem_InitState)
      && (DEM_NVM_COMMIT_WRITING == Dem_Nvm_CommitData.WriteState)
      && (DEM_NVM_BLOCKSTATE_UNMODIFIED != Dem_Nvm_GetBlockState(Dem_Nvm_CommitData.MemoryIndex)) )
    { /* Currently waiting for NvM JobResult, and the same block is still in the process
         of committing a previous data set - we are not allowed to mark this block using
         NvM_SetRamBlockStatus -> return TRUE to request more time untile the situation
         has resulved itself */
      *IsRequested = TRUE;
    }
    else
    {
      *IsRequested = FALSE;
    }
    lReturnValue = E_OK;
#else
  /* No immediate Nv-Write is supported, always return false */
    *IsRequested = FALSE;
    lReturnValue = E_OK;
#endif
  }

  /* ----- Development Error Report ---------------------------------------- */
#if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_POSTRUNREQUESTED_APIID, Dem_Det_ErrorRegisterGet())
  }
#endif

  return lReturnValue;
}

#if (DEM_CFG_SUPPORT_NVM_APPL_SYNCHRONIZE == STD_ON)
/* ****************************************************************************
 % Dem_RequestNvSynchronization
 *****************************************************************************/
FUNC(Std_ReturnType, DEM_CODE)
Dem_RequestNvSynchronization(
  void
  )
{
  Std_ReturnType lReturnValue;
  Dem_Det_ErrorRegisterDefine()

# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  lReturnValue = E_NOT_OK;
# endif
  Dem_Det_ErrorRegisterSet(DEM_E_NO_ERROR)

  /* ----- Development Error Checks ---------------------------------------- */
# if (DEM_CFG_SUPPORT_ERROR_CHECKS == STD_ON)
  if (DEM_INIT_INITIALIZED != Dem_InitState)
  {
    Dem_Det_ErrorRegisterSet(DEM_E_UNINIT)
  }
  else
# endif
  {
    /* ----- Implementation ------------------------------------------------ */
# if (DEM_CFG_USE_NVM == STD_ON)
    Dem_Nvm_SynchronizationRequest = TRUE;
    lReturnValue = E_OK;
# else
    lReturnValue = E_NOT_OK;
# endif
  }

  /* ----- Development Error Report ---------------------------------------- */
# if (DEM_CFG_USE_DET == STD_ON)
  if (DEM_E_NO_ERROR != Dem_Det_ErrorRegisterGet())
  {
    Dem_Det_ReportError(DEM_REQUESTNVSYNCHRONIZATION_APIID, Dem_Det_ErrorRegisterGet())
  }
# endif

  return lReturnValue;
}
#endif

#define DEM_STOP_SEC_CODE
#include "MemMap.h"                                                                                                              /* PRQA S 5087 */ /* MD_MSR_19.1 */

/* module specific MISRA deviations:

   MD_DEM_1.1_612
     Description: Rule 1.1
                  All code shall conform to ISO 9899:1990 C programming language, ISO 9899, amended and corrected by
                  ISO/IEC 9899/COR1:1995, ISO/IEC 9899/AMD1:1995, and ISO/IEC 9899/COR2: 1996
     Reason:      Depending on the configuration size the generated tables can
                  exceed the C90 limit of 32767 bytes
     Risk:        Compilation error.
     Prevention:  Compiler compatibility is tested during integration.

   MD_DEM_1.2:
     Description: Rule 1.2
                  No reliance shall be placed on undefined or unspecified behaviour.
     Reason:      False positive. Variable is initialized correctly on all code paths.
     Risk:        None.
     Prevention:  None.

   MD_DEM_3.1:
     Description: Rule 3.1
                  All usage of implementation-defined behaviour shall be documented.
     Reason:      Using the ~ operator avoids errors in manually typed bit masks.
     Risk:        May generate compiler warnings although explicit casts are used.
     Prevention:  None.

   MD_DEM_5.1:
     Description: Rule 5.1
                  Identifiers (internal and external) shall not rely on the significance of more than 31 characters.
     Reason:      Code maintainability requires structured names conflicting with this limitation.
     Risk:        Compilation errors are possible.
     Prevention:  Compiler compatibility is tested during integration.

   MD_DEM_5.1_API
     Description: Rule 5.1
                  Identifiers (internal and external) shall not rely on the significance of more than 31 characters.
     Reason:      The API is standardized and a change would break compliance.
     Risk:        Compilation errors are possible.
     Prevention:  Compiler compatibility is tested during integration.

   MD_DEM_8.7:
     Description: Rule 8.7
                  Objects shall be defined at block scope if they are only accessed from within a single function.
     Reason:      Vector style guide prevents usage of static variables in function scope
     Risk:        None.
     Prevention:  None.

   MD_DEM_11.1:
     Decription:  Rule 11.1
                  Conversions shall not be performed between a pointer to a function and any type other than an integral type.
     Reason:      Different types of callback functions need to be supported through a generic mechanism
     Risk:        Functions are cast to the wrong type before calling.
     Prevention:  The correct function type is indicated by type tagging. The correct cast is verified during code review.

   MD_DEM_11.4_cpy:
     Description: Rule 11.4
                  A cast should not be performed between a pointer to object type and a different pointer to object
                  type.
     Reason:      Use of memcopy requires common pointer type.
     Risk:        Data corruption due to miscast.
     Prevention:  Covered by descriptive pointer types and code review for correct usage.

   MD_DEM_11.4_nvm:
     Description: Rule 11.4
                  A cast should not be performed between a pointer to object type and a different pointer to object
                  type.
     Reason:      Mechanism for Nv handling requires common pointer type
     Risk:        None. Pointers are initially aligned and only cast due to common API later on.
     Prevention:  Covered by descriptive pointer types and code review for correct usage.

   MD_DEM_11.5:
     Description: Rule 11.5
                  A cast shall not be performed that removes any const or volatile qualification from the type
                  addressed by a pointer.
     Reason:      MemSet and MemCpy are defined as taking an unqualified pointer.
     Risk:        None.
     Prevention:  Safe access of shared data is verified during code review.

   MD_DEM_12.4_cs:
     Description: Rule 12.4
                  The right hand operand of a logical && or || operator shall not contain side effects
     Reason:      The function must be called in a critical section, so the access to volatile variables does not
                  apply as side effect.
     Risk:        Additional calls might be introduces later outside the critical section.
     Prevention:  Requirement for critical section is documented and compliance is assured during code review.

   MD_DEM_12.4_cf:
     Description: Rule 12.4
                  The right hand operand of a logical && or || operator shall not contain side effects
     Reason:      The function called on the right hand side has no side effects.
     Risk:        The function may introduce side effects at a later time.
     Prevention:  Code analysis (e.g. MISRA).

   MD_DEM_12.4_m:
     Description: Rule 12.4
                  The right hand operand of a logical && or || operator shall not contain side effects
     Reason:      The right hand operand may only be evaluated if the left hand operator is valid. This is more
                  maintainable than introducing additional levels of nesting, since nesting does reduce readibility
                  and does not reduce the risk of missing the order dependency of the two terms.
     Risk:        Later rework might miss the dependency and turn the order of checks around.
     Prevention:  Code analysis (e.g. MISRA) and review.

   MD_DEM_12.10:
     Description: Rule 12.10
                  The comma operator shall not be used.
     Reason:      Maintainability
     Risk:        None
     Prevention:  In code the use is invisible. In configuration the scope is limited enough to not affect
                  maintainability

   MD_DEM_13.6:
     Description: Rule 13.6
                  Numeric variables being used within a for loop for iteration counting shall not be modified in the
                  body of the loop.
     Reason:      Efficiency, to prevent additional check for overflow.
     Risk:        Difficult to maintain.
     Prevention:  Correctness is ensured in test suite.

   MD_DEM_13.7:
     Description: Rule 13.7
                  Boolean operations whose results are invariant shall not be permitted.
     Reason:      The expression is not invariant. Depending on supported features invariant value is possible but
                  the resulting code modification will adversely affect maintainability of already complicated code
                  paths.
     Risk:        Compiler warnings or compiler errors depending on configuration.
     Prevention:  None.

   MD_DEM_14.1:
     Description: Rule 14.1
                  This switch default label is unreachable.
     Reason:      Switch default labels are mandatory due to mandatory MISRA rule 15.3 'The final clause of a switch
                  statement shall be the default clause.'.
     Risk:        Compiler warnings or compiler errors depending on configuration.
                  Default branch cannot be tested.
     Prevention:  None.

   MD_DEM_14.2:
     Description: Rule 14.2
                  All non-null statements shall either (i) have at least one side-effect however executed, or
                  (ii) cause control flow to change
     Reason:      This statement is used to avoid warnings caused by unused parameters. Parameters are defined by
                  standardized API requirements, and not needed in case a feature is disabled by configuration.
                  It is either impossible due to API standardization or necessary code duplication (severe maintenance
                  increase) to provide feature dependent APIs with different signatures.
     Risk:        Unavoidable compiler warning or error because of either unused statements or unused parameter.
     Prevention:  None.

   MD_DEM_14.5:
     Description: Rule 14.5
                  The continue statement shall not be used
     Reason:      The continue statement is used in a circumstance where a different approach would reduce efficiency
                  or maintainability due to increased complexity.
     Risk:        None.
     Prevention:  None.

   MD_DEM_14.6_err:
     Description: Rule 14.6
                  For any iteration statement there shall be at most one break statement used for loop termination.
     Reason:      The loop needs multiple exit points since error conditions cannot be verified prior to the loop.
     Risk:        None.
     Prevention:  None.

   MD_DEM_14.6_opt:
     Description: Rule 14.6
                  For any iteration statement there shall be at most one break statement used for loop termination.
     Reason:      Increased efficiency on the time critical path
     Risk:        Maintainability is adversely affected.
     Prevention:  The break statement is documented.

   MD_DEM_14.7:
     Description: Rule 14.7
                  A function shall have a single point of exit at the end of the function.
     Reason:      Due to maintainability problems the control flow through the function shall not be complicated even
                  further.
     Risk:        Maintainability is adversely affected.
     Prevention:  None.

   MD_DEM_15.2:
     Description: Rule 15.2
                  An unconditional break statement shall terminate every non-empty switch clause.
     Reason:      The fall-through is preferred to an if-else cascade to avoid code duplication in this particular
                  circumstance.
     Risk:        Adverse effect on maintainability.
     Prevention:  The fall-through is documented.

   MD_DEM_16.4_dcm:
     Description: Rule 16.4
                  The identifiers used in the declaration and definition of a function shall be identical
     Reason:      Dcm generates its own prototypes based on a generic algorithm.
     Risk:        Dcm prototypes can deviate from the implementation.
     Prevention:  Verify compatibility during integraton tests.

   MD_DEM_16.4_rte:
     Description: Rule 16.4
                  The identifiers used in the declaration and definition of a function shall be identical
     Reason:      Port-Defined arguments are not generated with the correct name. This can currently not be influenced
                  due to the RTE being a third party module.
     Risk:        None. The generated prototypes are never used directly but only from generated RTE code.
     Prevention:  None.

   MD_DEM_16.7:
     Description: Rule 16.7
                  A pointer parameter in a function prototype should be declared as pointer to const if the pointer is
                  not used to modify the addressed object.
     Reason:      The API is standardized and a change would break compliance.
     Risk:        None.
     Prevention:  None.

   MD_DEM_16.7_False:
     Description: Rule 16.7
                  A pointer parameter in a function prototype should be declared as pointer to const if the pointer is
                  not used to modify the addressed object.
     Reason:      The data behind the pointer is modified, or modified in some configurations. This is a false positive.
     Risk:        None.
     Prevention:  None.

   MD_DEM_16.7_Internal:
     Description: Rule 16.7
                  A pointer parameter in a function prototype should be declared as pointer to const if the pointer is
                  not used to modify the addressed object.
     Reason:      The API has to be compatible to a common prototype
     Risk:        None.
     Prevention:  None.

   MD_DEM_16.7_Design:
     Description: Rule 16.7
                  A pointer parameter in a function prototype should be declared as pointer to const if the pointer is
                  not used to modify the addressed object.
     Reason:      The function has write access to shared state. The caller may not rely on constancy. Even if the
                  current implementation does not need write access, this is allowed to change. A stable interface is
                  preferred to adhering to this rule.
     Risk:        None.
     Prevention:  None.

   MD_DEM_8.12:
     Description: Rule 8.12
                  When an array is declared with external linkage, its size shall be stated explicitly or defined
                  implicitly by initialisation.
     Reason:      Prevent compiler optimization based on known array size.
     Risk:        None. The static code is not allowed to access this array directly.
     Prevention:  Code inspection.

   MD_DEM_18.4:
     Description: Rule 18.4
                  Unions shall not be used
     Reason:      Data without shared lifetime is stored in union for efficiency.
     Risk:        None due to no shared lifetime.
     Prevention:  None.

   MD_DEM_19.4:
     Description: Rule 19.4
                  C macros shall only expand to a braced initialiser, a constant, a parenthesised expression, a type
                  qualifier, a storage class specifier, or a do-while-zero construct.
     Reason:      The macro does not encapsulate a type but an empty argument list. This is part of a mechanism to
                  remove unneeded parameters from functions, based on configuration.
     Risk:        None.
     Prevention:  None.

   MD_DEM_19.6:
     Description: Rule 19.6
                  #undef shall not be used.
     Reason:      The use of undef improves maintainability when compared to the expressions required to avoid
                  redefinition.
     Risk:        None.
     Prevention:  None.

   MD_DEM_19.13:
     Description: Rule 19.13
                  K&R compilers do not support the ISO glue operator '##'.
     Reason:      This kind of implementation creates the least MISRA warnings.
     Risk:        K&R compilers will not work.
     Prevention:  Integration test using target compiler, error directives to detect evaluation errors.

   MD_DEM_19.15:
     Description: Rule 19.15
                  Precautions shall be taken in order to prevent the contents of a header file being included twice.
     Reason:      Precautions HAVE been taken, this violation is a false positive.
     Risk:        None.
     Prevention:  None.

   MD_DEM_20.2:
     Description: Rule 20.2
                  The names of standard library macros, objects and functions shall not be reused.
     Reason:      Included from vector standard library.
     Risk:        Name collision with different standard library.
     Prevention:  None.

   MD_DEM_21.1:
     Description: Rule 21.1
                  Minimisation of run-time failures shall be ensured by the use of at least one of (a) static analysis
                  tools/techniques; (b) dynamic analysis tools/techniques; (c) explicit coding of checks to handle
                  run-time faults.
     Reason:      False positive due to insufficient data flow analysis. Despite thorough review no defect could be
                  recognized.
     Risk:        Run-Time failure might be introduced by later code changes.
     Prevention:  None.

   MD_DEM_3197_na:
     Description: Rule N/A
                  The initialiser for '%s' is always modified before being used.
     Reason:      Assignment is necessary for an inactive code branch. Reworking the code would have negative effects
                  on maintainability, which is deemed more important.
     Risk:        None.
     Prevention:  None.

   MD_DEM_3198_fp:
     Description: Rule N/A
                  The value assigned to '%s' is always modified before being used.
     Reason:      False positive.
     Risk:        None.
     Prevention:  None.

   MD_DEM_3198_na:
     Description: Rule N/A
                  The value assigned to '%s' is always modified before being used.
     Reason:      Assignment is necessary for an inactive code branch. Reworking the code would have negative effects
                  on maintainability, which is deemed more important.
     Risk:        None.
     Prevention:  None.

   MD_DEM_3305:
     Description: Rule N/A
                  Pointer cast to stricter alignment
     Reason:      Already aligned pointers are handled in a generic way.
     Risk:        None.
     Prevention:  None.

   MD_DEM_3305:
     Description: Rule N/A
                  The parameter '%s' is not used in this function.
     Reason:      API / Standardized API is not adapted based on configuration
     Risk:        None.
     Prevention:  None.

   MD_DEM_3423:
     Description: Rule N/A
                  Redundant cast at top level
     Reason:      Generic macro generation results in additional cast.
     Risk:        None.
     Prevention:  None.

   MD_DEM_TEST:
     Description: Multiple rules
     Reason:      Test code does not respect MISRA coding standard
     Risk:        None.
     Prevention:  None.

*/

/* ********************************************************************************************************************
 *  END OF FILE: DEM.C
 *********************************************************************************************************************/
